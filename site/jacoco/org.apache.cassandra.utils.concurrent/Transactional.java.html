<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Transactional.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils.concurrent</a> &gt; <span class="el_source">Transactional.java</span></div><h1>Transactional.java</h1><pre class="source lang-java linenums">/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* &quot;License&quot;); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
package org.apache.cassandra.utils.concurrent;

import static org.apache.cassandra.utils.Throwables.maybeFail;
import static org.apache.cassandra.utils.Throwables.merge;

/**
 * An abstraction for Transactional behaviour. An object implementing this interface has a lifetime
 * of the following pattern:
 *
 * Throwable failure = null;
 * try (Transactional t1, t2 = ...)
 * {
 *     // do work with t1 and t2
 *     t1.prepareToCommit();
 *     t2.prepareToCommit();
 *     failure = t1.commit(failure);
 *     failure = t2.commit(failure);
 * }
 * logger.error(failure);
 *
 * If something goes wrong before commit() is called on any transaction, then on exiting the try block
 * the auto close method should invoke cleanup() and then abort() to reset any state.
 * If everything completes normally, then on exiting the try block the auto close method will invoke cleanup
 * to release any temporary state/resources
 *
 * All exceptions and assertions that may be thrown should be checked and ruled out during commit preparation.
 * Commit should generally never throw an exception unless there is a real correctness-affecting exception that
 * cannot be moved to prepareToCommit, in which case this operation MUST be executed before any other commit
 * methods in the object graph.
 *
 * If exceptions are generated by commit after this initial moment, it is not at all clear what the correct behaviour
 * of the system should be, and so simply logging the exception is likely best (since it may have been an issue
 * during cleanup, say), and rollback cannot now occur. As such all exceptions and assertions that may be thrown
 * should be checked and ruled out during commit preparation.
 *
 * Since Transactional implementations will abort any changes they've made if calls to prepareToCommit() and commit()
 * aren't made prior to calling close(), the semantics of its close() method differ significantly from
 * most AutoCloseable implementations.
 */
public interface Transactional extends AutoCloseable
{
    /**
     * A simple abstract implementation of Transactional behaviour.
     * In general this should be used as the base class for any transactional implementations.
     *
     * If the implementation wraps any internal Transactional objects, it must proxy every
     * commit() and abort() call onto each internal object to ensure correct behaviour
     */
<span class="fc" id="L67">    abstract class AbstractTransactional implements Transactional</span>
    {
<span class="fc" id="L69">        public enum State</span>
        {
<span class="fc" id="L71">            IN_PROGRESS,</span>
<span class="fc" id="L72">            READY_TO_COMMIT,</span>
<span class="fc" id="L73">            COMMITTED,</span>
<span class="fc" id="L74">            ABORTED;</span>
        }

<span class="fc" id="L77">        private State state = State.IN_PROGRESS;</span>

        // the methods for actually performing the necessary behaviours, that are themselves protected against
        // improper use by the external implementations provided by this class. empty default implementations
        // could be provided, but we consider it safer to force implementers to consider explicitly their presence

        protected abstract Throwable doCommit(Throwable accumulate);
        protected abstract Throwable doAbort(Throwable accumulate);

        // these only needs to perform cleanup of state unique to this instance; any internal
        // Transactional objects will perform cleanup in the commit() or abort() calls

        /**
         * perform an exception-safe pre-abort/commit cleanup;
         * this will be run after prepareToCommit (so before commit), and before abort
         */
<span class="fc" id="L93">        protected Throwable doPreCleanup(Throwable accumulate){ return accumulate; }</span>

        /**
         * perform an exception-safe post-abort cleanup
         */
<span class="fc" id="L98">        protected Throwable doPostCleanup(Throwable accumulate){ return accumulate; }</span>

        /**
         * Do any preparatory work prior to commit. This method should throw any exceptions that can be encountered
         * during the finalization of the behaviour.
         */
        protected abstract void doPrepare();

        /**
         * commit any effects of this transaction object graph, then cleanup; delegates first to doCommit, then to doCleanup
         */
        public final Throwable commit(Throwable accumulate)
        {
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">            if (state != State.READY_TO_COMMIT)</span>
<span class="nc" id="L112">                throw new IllegalStateException(&quot;Cannot commit unless READY_TO_COMMIT; state is &quot; + state);</span>
<span class="fc" id="L113">            accumulate = doCommit(accumulate);</span>
<span class="fc" id="L114">            accumulate = doPostCleanup(accumulate);</span>
<span class="fc" id="L115">            state = State.COMMITTED;</span>
<span class="fc" id="L116">            return accumulate;</span>
        }

        /**
         * rollback any effects of this transaction object graph; delegates first to doCleanup, then to doAbort
         */
        public final Throwable abort(Throwable accumulate)
        {
<span class="nc bnc" id="L124" title="All 2 branches missed.">            if (state == State.ABORTED)</span>
<span class="nc" id="L125">                return accumulate;</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">            if (state == State.COMMITTED)</span>
            {
                try
                {
<span class="nc" id="L130">                    throw new IllegalStateException(&quot;Attempted to abort a committed operation&quot;);</span>
                }
<span class="nc" id="L132">                catch (Throwable t)</span>
                {
<span class="nc" id="L134">                    accumulate = merge(accumulate, t);</span>
                }
<span class="nc" id="L136">                return accumulate;</span>
            }
<span class="nc" id="L138">            state = State.ABORTED;</span>
            // we cleanup first so that, e.g., file handles can be released prior to deletion
<span class="nc" id="L140">            accumulate = doPreCleanup(accumulate);</span>
<span class="nc" id="L141">            accumulate = doAbort(accumulate);</span>
<span class="nc" id="L142">            accumulate = doPostCleanup(accumulate);</span>
<span class="nc" id="L143">            return accumulate;</span>
        }

        // if we are committed or aborted, then we are done; otherwise abort
        public final void close()
        {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            switch (state)</span>
            {
                case COMMITTED:
                case ABORTED:
<span class="fc" id="L153">                    break;</span>
                default:
<span class="nc" id="L155">                    abort();</span>
            }
<span class="fc" id="L157">        }</span>

        /**
         * The first phase of commit: delegates to doPrepare(), with valid state transition enforcement.
         * This call should be propagated onto any child objects participating in the transaction
         */
        public final void prepareToCommit()
        {
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">            if (state != State.IN_PROGRESS)</span>
<span class="nc" id="L166">                throw new IllegalStateException(&quot;Cannot prepare to commit unless IN_PROGRESS; state is &quot; + state);</span>

<span class="fc" id="L168">            doPrepare();</span>
<span class="fc" id="L169">            maybeFail(doPreCleanup(null));</span>
<span class="fc" id="L170">            state = State.READY_TO_COMMIT;</span>
<span class="fc" id="L171">        }</span>

        /**
         * convenience method to both prepareToCommit() and commit() in one operation;
         * only of use to outer-most transactional object of an object graph
         */
        public Object finish()
        {
<span class="fc" id="L179">            prepareToCommit();</span>
<span class="fc" id="L180">            commit();</span>
<span class="fc" id="L181">            return this;</span>
        }

        // convenience method wrapping abort, and throwing any exception encountered
        // only of use to (and to be used by) outer-most object in a transactional graph
        public final void abort()
        {
<span class="nc" id="L188">            maybeFail(abort(null));</span>
<span class="nc" id="L189">        }</span>

        // convenience method wrapping commit, and throwing any exception encountered
        // only of use to (and to be used by) outer-most object in a transactional graph
        public final void commit()
        {
<span class="fc" id="L195">            maybeFail(commit(null));</span>
<span class="fc" id="L196">        }</span>

        public final State state()
        {
<span class="fc" id="L200">            return state;</span>
        }
    }

    // commit should generally never throw an exception, and preferably never generate one,
    // but if it does generate one it should accumulate it in the parameter and return the result
    // IF a commit implementation has a real correctness affecting exception that cannot be moved to
    // prepareToCommit, it MUST be executed before any other commit methods in the object graph
    Throwable commit(Throwable accumulate);

    // release any resources, then rollback all state changes (unless commit() has already been invoked)
    Throwable abort(Throwable accumulate);

    void prepareToCommit();

    // close() does not throw
    public void close();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>