<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FBUtilities.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">FBUtilities.java</span></div><h1>FBUtilities.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

import java.io.*;
import java.lang.reflect.Field;
import java.math.BigInteger;
import java.net.*;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.*;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.base.Strings;
import com.google.common.util.concurrent.Uninterruptibles;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.util.concurrent.FastThreadLocal;
import org.apache.cassandra.auth.IAuthenticator;
import org.apache.cassandra.auth.IAuthorizer;
import org.apache.cassandra.auth.IRoleManager;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.dht.LocalPartitioner;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.metadata.MetadataComponent;
import org.apache.cassandra.io.sstable.metadata.MetadataType;
import org.apache.cassandra.io.sstable.metadata.ValidationMetadata;
import org.apache.cassandra.io.util.DataOutputBuffer;
import org.apache.cassandra.io.util.DataOutputBufferFixed;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.net.AsyncOneResponse;

import org.codehaus.jackson.JsonFactory;
import org.codehaus.jackson.map.ObjectMapper;

<span class="pc bpc" id="L71" title="1 of 2 branches missed.">public class FBUtilities</span>
{
<span class="fc" id="L73">    private static final Logger logger = LoggerFactory.getLogger(FBUtilities.class);</span>

<span class="fc" id="L75">    private static final ObjectMapper jsonMapper = new ObjectMapper(new JsonFactory());</span>

    public static final String UNKNOWN_RELEASE_VERSION = &quot;Unknown&quot;;

<span class="fc" id="L79">    public static final BigInteger TWO = new BigInteger(&quot;2&quot;);</span>
    private static final String DEFAULT_TRIGGER_DIR = &quot;triggers&quot;;

<span class="fc" id="L82">    private static final String OPERATING_SYSTEM = System.getProperty(&quot;os.name&quot;).toLowerCase();</span>
<span class="fc" id="L83">    public static final boolean isWindows = OPERATING_SYSTEM.contains(&quot;windows&quot;);</span>
<span class="fc" id="L84">    public static final boolean isLinux = OPERATING_SYSTEM.contains(&quot;linux&quot;);</span>

    private static volatile InetAddress localInetAddress;
    private static volatile InetAddress broadcastInetAddress;
    private static volatile InetAddress broadcastRpcAddress;

    private static volatile String previousReleaseVersionString;

    public static int getAvailableProcessors()
    {
<span class="fc" id="L94">        String availableProcessors = System.getProperty(&quot;cassandra.available_processors&quot;);</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(availableProcessors))</span>
<span class="nc" id="L96">            return Integer.parseInt(availableProcessors);</span>
        else
<span class="fc" id="L98">            return Runtime.getRuntime().availableProcessors();</span>
    }

<span class="fc" id="L101">    private static final FastThreadLocal&lt;MessageDigest&gt; localMD5Digest = new FastThreadLocal&lt;MessageDigest&gt;()</span>
<span class="fc" id="L102">    {</span>
        @Override
        protected MessageDigest initialValue()
        {
<span class="nc" id="L106">            return newMessageDigest(&quot;MD5&quot;);</span>
        }
    };

    public static final int MAX_UNSIGNED_SHORT = 0xFFFF;

    public static MessageDigest threadLocalMD5Digest()
    {
<span class="nc" id="L114">        MessageDigest md = localMD5Digest.get();</span>
<span class="nc" id="L115">        md.reset();</span>
<span class="nc" id="L116">        return md;</span>
    }

    public static MessageDigest newMessageDigest(String algorithm)
    {
        try
        {
<span class="nc" id="L123">            return MessageDigest.getInstance(algorithm);</span>
        }
<span class="nc" id="L125">        catch (NoSuchAlgorithmException nsae)</span>
        {
<span class="nc" id="L127">            throw new RuntimeException(&quot;the requested digest algorithm (&quot; + algorithm + &quot;) is not available&quot;, nsae);</span>
        }
    }

    /**
     * Please use getBroadcastAddress instead. You need this only when you have to listen/connect.
     */
    public static InetAddress getLocalAddress()
    {
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (localInetAddress == null)</span>
            try
            {
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">                localInetAddress = DatabaseDescriptor.getListenAddress() == null</span>
<span class="nc" id="L140">                                    ? InetAddress.getLocalHost()</span>
<span class="fc" id="L141">                                    : DatabaseDescriptor.getListenAddress();</span>
            }
<span class="nc" id="L143">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L145">                throw new RuntimeException(e);</span>
<span class="fc" id="L146">            }</span>
<span class="fc" id="L147">        return localInetAddress;</span>
    }

    public static InetAddress getBroadcastAddress()
    {
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (broadcastInetAddress == null)</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">            broadcastInetAddress = DatabaseDescriptor.getBroadcastAddress() == null</span>
<span class="fc" id="L154">                                 ? getLocalAddress()</span>
<span class="pc" id="L155">                                 : DatabaseDescriptor.getBroadcastAddress();</span>
<span class="fc" id="L156">        return broadcastInetAddress;</span>
    }

    /**
     * &lt;b&gt;THIS IS FOR TESTING ONLY!!&lt;/b&gt;
     */
    @VisibleForTesting
    public static void setBroadcastInetAddress(InetAddress addr)
    {
<span class="nc" id="L165">        broadcastInetAddress = addr;</span>
<span class="nc" id="L166">    }</span>

    public static InetAddress getBroadcastRpcAddress()
    {
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (broadcastRpcAddress == null)</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            broadcastRpcAddress = DatabaseDescriptor.getBroadcastRpcAddress() == null</span>
<span class="fc" id="L172">                                   ? DatabaseDescriptor.getRpcAddress()</span>
<span class="pc" id="L173">                                   : DatabaseDescriptor.getBroadcastRpcAddress();</span>
<span class="fc" id="L174">        return broadcastRpcAddress;</span>
    }

    public static Collection&lt;InetAddress&gt; getAllLocalAddresses()
    {
<span class="fc" id="L179">        Set&lt;InetAddress&gt; localAddresses = new HashSet&lt;InetAddress&gt;();</span>
        try
        {
<span class="fc" id="L182">            Enumeration&lt;NetworkInterface&gt; nets = NetworkInterface.getNetworkInterfaces();</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            if (nets != null)</span>
            {
<span class="fc bfc" id="L185" title="All 2 branches covered.">                while (nets.hasMoreElements())</span>
<span class="fc" id="L186">                    localAddresses.addAll(Collections.list(nets.nextElement().getInetAddresses()));</span>
            }
        }
<span class="nc" id="L189">        catch (SocketException e)</span>
        {
<span class="nc" id="L191">            throw new AssertionError(e);</span>
<span class="fc" id="L192">        }</span>
<span class="fc" id="L193">        return localAddresses;</span>
    }

    public static String getNetworkInterface(InetAddress localAddress)
    {
        try
        {
<span class="fc bfc" id="L200" title="All 2 branches covered.">            for(NetworkInterface ifc : Collections.list(NetworkInterface.getNetworkInterfaces()))</span>
            {
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                if(ifc.isUp())</span>
                {
<span class="fc bfc" id="L204" title="All 2 branches covered.">                    for(InetAddress addr : Collections.list(ifc.getInetAddresses()))</span>
                    {
<span class="fc bfc" id="L206" title="All 2 branches covered.">                        if (addr.equals(localAddress))</span>
<span class="fc" id="L207">                            return ifc.getDisplayName();</span>
<span class="fc" id="L208">                    }</span>
                }
<span class="fc" id="L210">            }</span>
        }
<span class="pc" id="L212">        catch (SocketException e) {}</span>
<span class="fc" id="L213">        return null;</span>
    }

    /**
     * Given two bit arrays represented as BigIntegers, containing the given
     * number of significant bits, calculate a midpoint.
     *
     * @param left The left point.
     * @param right The right point.
     * @param sigbits The number of bits in the points that are significant.
     * @return A midpoint that will compare bitwise halfway between the params, and
     * a boolean representing whether a non-zero lsbit remainder was generated.
     */
    public static Pair&lt;BigInteger,Boolean&gt; midpoint(BigInteger left, BigInteger right, int sigbits)
    {
        BigInteger midpoint;
        boolean remainder;
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (left.compareTo(right) &lt; 0)</span>
        {
<span class="nc" id="L232">            BigInteger sum = left.add(right);</span>
<span class="nc" id="L233">            remainder = sum.testBit(0);</span>
<span class="nc" id="L234">            midpoint = sum.shiftRight(1);</span>
<span class="nc" id="L235">        }</span>
        else
        {
<span class="nc" id="L238">            BigInteger max = TWO.pow(sigbits);</span>
            // wrapping case
<span class="nc" id="L240">            BigInteger distance = max.add(right).subtract(left);</span>
<span class="nc" id="L241">            remainder = distance.testBit(0);</span>
<span class="nc" id="L242">            midpoint = distance.shiftRight(1).add(left).mod(max);</span>
        }
<span class="nc" id="L244">        return Pair.create(midpoint, remainder);</span>
    }

    public static int compareUnsigned(byte[] bytes1, byte[] bytes2, int offset1, int offset2, int len1, int len2)
    {
<span class="nc" id="L249">        return FastByteOperations.compareUnsigned(bytes1, offset1, len1, bytes2, offset2, len2);</span>
    }

    public static int compareUnsigned(byte[] bytes1, byte[] bytes2)
    {
<span class="nc" id="L254">        return compareUnsigned(bytes1, bytes2, 0, 0, bytes1.length, bytes2.length);</span>
    }

    /**
     * @return The bitwise XOR of the inputs. The output will be the same length as the
     * longer input, but if either input is null, the output will be null.
     */
    public static byte[] xor(byte[] left, byte[] right)
    {
<span class="nc bnc" id="L263" title="All 4 branches missed.">        if (left == null || right == null)</span>
<span class="nc" id="L264">            return null;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (left.length &gt; right.length)</span>
        {
<span class="nc" id="L267">            byte[] swap = left;</span>
<span class="nc" id="L268">            left = right;</span>
<span class="nc" id="L269">            right = swap;</span>
        }

        // left.length is now &lt;= right.length
<span class="nc" id="L273">        byte[] out = Arrays.copyOf(right, right.length);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        for (int i = 0; i &lt; left.length; i++)</span>
        {
<span class="nc" id="L276">            out[i] = (byte)((left[i] &amp; 0xFF) ^ (right[i] &amp; 0xFF));</span>
        }
<span class="nc" id="L278">        return out;</span>
    }

    public static void sortSampledKeys(List&lt;DecoratedKey&gt; keys, Range&lt;Token&gt; range)
    {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (range.left.compareTo(range.right) &gt;= 0)</span>
        {
            // range wraps.  have to be careful that we sort in the same order as the range to find the right midpoint.
<span class="nc" id="L286">            final Token right = range.right;</span>
<span class="nc" id="L287">            Comparator&lt;DecoratedKey&gt; comparator = new Comparator&lt;DecoratedKey&gt;()</span>
<span class="nc" id="L288">            {</span>
                public int compare(DecoratedKey o1, DecoratedKey o2)
                {
<span class="nc bnc" id="L291" title="All 4 branches missed.">                    if ((right.compareTo(o1.getToken()) &lt; 0 &amp;&amp; right.compareTo(o2.getToken()) &lt; 0)</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">                        || (right.compareTo(o1.getToken()) &gt; 0 &amp;&amp; right.compareTo(o2.getToken()) &gt; 0))</span>
                    {
                        // both tokens are on the same side of the wrap point
<span class="nc" id="L295">                        return o1.compareTo(o2);</span>
                    }
<span class="nc" id="L297">                    return o2.compareTo(o1);</span>
                }
            };
<span class="nc" id="L300">            Collections.sort(keys, comparator);</span>
<span class="nc" id="L301">        }</span>
        else
        {
            // unwrapped range (left &lt; right).  standard sort is all we need.
<span class="nc" id="L305">            Collections.sort(keys);</span>
        }
<span class="nc" id="L307">    }</span>

    public static String resourceToFile(String filename) throws ConfigurationException
    {
<span class="nc" id="L311">        ClassLoader loader = FBUtilities.class.getClassLoader();</span>
<span class="nc" id="L312">        URL scpurl = loader.getResource(filename);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (scpurl == null)</span>
<span class="nc" id="L314">            throw new ConfigurationException(&quot;unable to locate &quot; + filename);</span>

<span class="nc" id="L316">        return new File(scpurl.getFile()).getAbsolutePath();</span>
    }

    public static File cassandraTriggerDir()
    {
<span class="fc" id="L321">        File triggerDir = null;</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if (System.getProperty(&quot;cassandra.triggers_dir&quot;) != null)</span>
        {
<span class="nc" id="L324">            triggerDir = new File(System.getProperty(&quot;cassandra.triggers_dir&quot;));</span>
        }
        else
        {
<span class="fc" id="L328">            URL confDir = FBUtilities.class.getClassLoader().getResource(DEFAULT_TRIGGER_DIR);</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">            if (confDir != null)</span>
<span class="nc" id="L330">                triggerDir = new File(confDir.getFile());</span>
        }
<span class="pc bpc" id="L332" title="3 of 4 branches missed.">        if (triggerDir == null || !triggerDir.exists())</span>
        {
<span class="fc" id="L334">            logger.warn(&quot;Trigger directory doesn't exist, please create it and try again.&quot;);</span>
<span class="fc" id="L335">            return null;</span>
        }
<span class="nc" id="L337">        return triggerDir;</span>
    }

    public static void setPreviousReleaseVersionString(String previousReleaseVersionString)
    {
<span class="fc" id="L342">        FBUtilities.previousReleaseVersionString = previousReleaseVersionString;</span>
<span class="fc" id="L343">    }</span>

    public static String getPreviousReleaseVersionString()
    {
<span class="fc" id="L347">        return previousReleaseVersionString;</span>
    }

    public static String getReleaseVersionString()
    {
<span class="fc" id="L352">        try (InputStream in = FBUtilities.class.getClassLoader().getResourceAsStream(&quot;org/apache/cassandra/config/version.properties&quot;))</span>
        {
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">            if (in == null)</span>
            {
<span class="nc" id="L356">                return System.getProperty(&quot;cassandra.releaseVersion&quot;, UNKNOWN_RELEASE_VERSION);</span>
            }
<span class="fc" id="L358">            Properties props = new Properties();</span>
<span class="fc" id="L359">            props.load(in);</span>
<span class="fc" id="L360">            return props.getProperty(&quot;CassandraVersion&quot;);</span>
        }
<span class="nc" id="L362">        catch (Exception e)</span>
        {
<span class="nc" id="L364">            JVMStabilityInspector.inspectThrowable(e);</span>
<span class="nc" id="L365">            logger.warn(&quot;Unable to load version.properties&quot;, e);</span>
<span class="nc" id="L366">            return &quot;debug version&quot;;</span>
        }
    }

    public static String getReleaseVersionMajor()
    {
<span class="fc" id="L372">        String releaseVersion = FBUtilities.getReleaseVersionString();</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        if (FBUtilities.UNKNOWN_RELEASE_VERSION.equals(releaseVersion))</span>
        {
<span class="nc" id="L375">            throw new AssertionError(&quot;Release version is unknown&quot;);</span>
        }
<span class="fc" id="L377">        return releaseVersion.substring(0, releaseVersion.indexOf('.'));</span>
    }

    public static long timestampMicros()
    {
        // we use microsecond resolution for compatibility with other client libraries, even though
        // we can't actually get microsecond precision.
<span class="fc" id="L384">        return System.currentTimeMillis() * 1000;</span>
    }

    public static int nowInSeconds()
    {
<span class="fc" id="L389">        return (int) (System.currentTimeMillis() / 1000);</span>
    }

    public static &lt;T&gt; List&lt;T&gt; waitOnFutures(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures)
    {
<span class="fc" id="L394">        return waitOnFutures(futures, -1, null);</span>
    }

    /**
     * Block for a collection of futures, with optional timeout.
     *
     * @param futures
     * @param timeout The number of units to wait in total. If this value is less than or equal to zero,
     *           no tiemout value will be passed to {@link Future#get()}.
     * @param units The units of timeout.
     */
    public static &lt;T&gt; List&lt;T&gt; waitOnFutures(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures, long timeout, TimeUnit units)
    {
<span class="fc" id="L407">        long endNanos = 0;</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (timeout &gt; 0)</span>
<span class="nc" id="L409">            endNanos = System.nanoTime() + units.toNanos(timeout);</span>
<span class="fc" id="L410">        List&lt;T&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L411">        Throwable fail = null;</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        for (Future&lt;? extends T&gt; f : futures)</span>
        {
            try
            {
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">                if (endNanos == 0)</span>
                {
<span class="fc" id="L418">                    results.add(f.get());</span>
                }
                else
                {
<span class="nc" id="L422">                    long waitFor = Math.max(1, endNanos - System.nanoTime());</span>
<span class="nc" id="L423">                    results.add(f.get(waitFor, TimeUnit.NANOSECONDS));</span>
                }
            }
<span class="nc" id="L426">            catch (Throwable t)</span>
            {
<span class="nc" id="L428">                fail = Throwables.merge(fail, t);</span>
<span class="fc" id="L429">            }</span>
<span class="fc" id="L430">        }</span>
<span class="fc" id="L431">        Throwables.maybeFail(fail);</span>
<span class="fc" id="L432">        return results;</span>
    }

    public static &lt;T&gt; T waitOnFuture(Future&lt;T&gt; future)
    {
        try
        {
<span class="fc" id="L439">            return future.get();</span>
        }
<span class="nc" id="L441">        catch (ExecutionException ee)</span>
        {
<span class="nc" id="L443">            throw new RuntimeException(ee);</span>
        }
<span class="nc" id="L445">        catch (InterruptedException ie)</span>
        {
<span class="nc" id="L447">            throw new AssertionError(ie);</span>
        }
    }

    public static void waitOnFutures(List&lt;AsyncOneResponse&gt; results, long ms) throws TimeoutException
    {
<span class="nc bnc" id="L453" title="All 2 branches missed.">        for (AsyncOneResponse result : results)</span>
<span class="nc" id="L454">            result.get(ms, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L455">    }</span>

    public static &lt;T&gt; Future&lt;? extends T&gt; waitOnFirstFuture(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures)
    {
<span class="nc" id="L459">        return waitOnFirstFuture(futures, 100);</span>
    }
    /**
     * Only wait for the first future to finish from a list of futures. Will block until at least 1 future finishes.
     * @param futures The futures to wait on
     * @return future that completed.
     */
    public static &lt;T&gt; Future&lt;? extends T&gt; waitOnFirstFuture(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures, long delay)
    {
        while (true)
        {
<span class="nc bnc" id="L470" title="All 2 branches missed.">            for (Future&lt;? extends T&gt; f : futures)</span>
            {
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (f.isDone())</span>
                {
                    try
                    {
<span class="nc" id="L476">                        f.get();</span>
                    }
<span class="nc" id="L478">                    catch (InterruptedException e)</span>
                    {
<span class="nc" id="L480">                        throw new AssertionError(e);</span>
                    }
<span class="nc" id="L482">                    catch (ExecutionException e)</span>
                    {
<span class="nc" id="L484">                        throw new RuntimeException(e);</span>
<span class="nc" id="L485">                    }</span>
<span class="nc" id="L486">                    return f;</span>
                }
<span class="nc" id="L488">            }</span>
<span class="nc" id="L489">            Uninterruptibles.sleepUninterruptibly(delay, TimeUnit.MILLISECONDS);</span>
        }
    }
    /**
     * Create a new instance of a partitioner defined in an SSTable Descriptor
     * @param desc Descriptor of an sstable
     * @return a new IPartitioner instance
     * @throws IOException
     */
    public static IPartitioner newPartitioner(Descriptor desc) throws IOException
    {
<span class="nc" id="L500">        EnumSet&lt;MetadataType&gt; types = EnumSet.of(MetadataType.VALIDATION, MetadataType.HEADER);</span>
<span class="nc" id="L501">        Map&lt;MetadataType, MetadataComponent&gt; sstableMetadata = desc.getMetadataSerializer().deserialize(desc, types);</span>
<span class="nc" id="L502">        ValidationMetadata validationMetadata = (ValidationMetadata) sstableMetadata.get(MetadataType.VALIDATION);</span>
<span class="nc" id="L503">        SerializationHeader.Component header = (SerializationHeader.Component) sstableMetadata.get(MetadataType.HEADER);</span>
<span class="nc" id="L504">        return newPartitioner(validationMetadata.partitioner, Optional.of(header.getKeyType()));</span>
    }

    public static IPartitioner newPartitioner(String partitionerClassName) throws ConfigurationException
    {
<span class="fc" id="L509">        return newPartitioner(partitionerClassName, Optional.empty());</span>
    }

    @VisibleForTesting
    static IPartitioner newPartitioner(String partitionerClassName, Optional&lt;AbstractType&lt;?&gt;&gt; comparator) throws ConfigurationException
    {
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">        if (!partitionerClassName.contains(&quot;.&quot;))</span>
<span class="nc" id="L516">            partitionerClassName = &quot;org.apache.cassandra.dht.&quot; + partitionerClassName;</span>

<span class="pc bpc" id="L518" title="1 of 2 branches missed.">        if (partitionerClassName.equals(&quot;org.apache.cassandra.dht.LocalPartitioner&quot;))</span>
        {
<span class="nc bnc" id="L520" title="All 4 branches missed.">            assert comparator.isPresent() : &quot;Expected a comparator for local partitioner&quot;;</span>
<span class="nc" id="L521">            return new LocalPartitioner(comparator.get());</span>
        }
<span class="fc" id="L523">        return FBUtilities.instanceOrConstruct(partitionerClassName, &quot;partitioner&quot;);</span>
    }

    public static IAuthorizer newAuthorizer(String className) throws ConfigurationException
    {
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        if (!className.contains(&quot;.&quot;))</span>
<span class="fc" id="L529">            className = &quot;org.apache.cassandra.auth.&quot; + className;</span>
<span class="fc" id="L530">        return FBUtilities.construct(className, &quot;authorizer&quot;);</span>
    }

    public static IAuthenticator newAuthenticator(String className) throws ConfigurationException
    {
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        if (!className.contains(&quot;.&quot;))</span>
<span class="fc" id="L536">            className = &quot;org.apache.cassandra.auth.&quot; + className;</span>
<span class="fc" id="L537">        return FBUtilities.construct(className, &quot;authenticator&quot;);</span>
    }

    public static IRoleManager newRoleManager(String className) throws ConfigurationException
    {
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        if (!className.contains(&quot;.&quot;))</span>
<span class="fc" id="L543">            className = &quot;org.apache.cassandra.auth.&quot; + className;</span>
<span class="fc" id="L544">        return FBUtilities.construct(className, &quot;role manager&quot;);</span>
    }

    /**
     * @return The Class for the given name.
     * @param classname Fully qualified classname.
     * @param readable Descriptive noun for the role the class plays.
     * @throws ConfigurationException If the class cannot be found.
     */
    public static &lt;T&gt; Class&lt;T&gt; classForName(String classname, String readable) throws ConfigurationException
    {
        try
        {
<span class="fc" id="L557">            return (Class&lt;T&gt;)Class.forName(classname);</span>
        }
<span class="nc" id="L559">        catch (ClassNotFoundException | NoClassDefFoundError e)</span>
        {
<span class="nc" id="L561">            throw new ConfigurationException(String.format(&quot;Unable to find %s class '%s'&quot;, readable, classname), e);</span>
        }
    }

    /**
     * Constructs an instance of the given class, which must have a no-arg or default constructor.
     * @param classname Fully qualified classname.
     * @param readable Descriptive noun for the role the class plays.
     * @throws ConfigurationException If the class cannot be found.
     */
    public static &lt;T&gt; T instanceOrConstruct(String classname, String readable) throws ConfigurationException
    {
<span class="fc" id="L573">        Class&lt;T&gt; cls = FBUtilities.classForName(classname, readable);</span>
        try
        {
<span class="fc" id="L576">            Field instance = cls.getField(&quot;instance&quot;);</span>
<span class="fc" id="L577">            return cls.cast(instance.get(null));</span>
        }
<span class="fc" id="L579">        catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e)</span>
        {
            // Could not get instance field. Try instantiating.
<span class="fc" id="L582">            return construct(cls, classname, readable);</span>
        }
    }

    /**
     * Constructs an instance of the given class, which must have a no-arg or default constructor.
     * @param classname Fully qualified classname.
     * @param readable Descriptive noun for the role the class plays.
     * @throws ConfigurationException If the class cannot be found.
     */
    public static &lt;T&gt; T construct(String classname, String readable) throws ConfigurationException
    {
<span class="fc" id="L594">        Class&lt;T&gt; cls = FBUtilities.classForName(classname, readable);</span>
<span class="fc" id="L595">        return construct(cls, classname, readable);</span>
    }

    private static &lt;T&gt; T construct(Class&lt;T&gt; cls, String classname, String readable) throws ConfigurationException
    {
        try
        {
<span class="fc" id="L602">            return cls.newInstance();</span>
        }
<span class="nc" id="L604">        catch (IllegalAccessException e)</span>
        {
<span class="nc" id="L606">            throw new ConfigurationException(String.format(&quot;Default constructor for %s class '%s' is inaccessible.&quot;, readable, classname));</span>
        }
<span class="nc" id="L608">        catch (InstantiationException e)</span>
        {
<span class="nc" id="L610">            throw new ConfigurationException(String.format(&quot;Cannot use abstract class '%s' as %s.&quot;, classname, readable));</span>
        }
<span class="nc" id="L612">        catch (Exception e)</span>
        {
            // Catch-all because Class.newInstance() &quot;propagates any exception thrown by the nullary constructor, including a checked exception&quot;.
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (e.getCause() instanceof ConfigurationException)</span>
<span class="nc" id="L616">                throw (ConfigurationException)e.getCause();</span>
<span class="nc" id="L617">            throw new ConfigurationException(String.format(&quot;Error instantiating %s class '%s'.&quot;, readable, classname), e);</span>
        }
    }

    public static &lt;T&gt; NavigableSet&lt;T&gt; singleton(T column, Comparator&lt;? super T&gt; comparator)
    {
<span class="nc" id="L623">        NavigableSet&lt;T&gt; s = new TreeSet&lt;T&gt;(comparator);</span>
<span class="nc" id="L624">        s.add(column);</span>
<span class="nc" id="L625">        return s;</span>
    }

    public static &lt;T&gt; NavigableSet&lt;T&gt; emptySortedSet(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc" id="L630">        return new TreeSet&lt;T&gt;(comparator);</span>
    }

    /**
     * Make straing out of the given {@code Map}.
     *
     * @param map Map to make string.
     * @return String representation of all entries in the map,
     *         where key and value pair is concatenated with ':'.
     */
    @Nonnull
    public static String toString(@Nullable Map&lt;?, ?&gt; map)
    {
<span class="nc bnc" id="L643" title="All 2 branches missed.">        if (map == null)</span>
<span class="nc" id="L644">            return &quot;&quot;;</span>
<span class="nc" id="L645">        Joiner.MapJoiner joiner = Joiner.on(&quot;, &quot;).withKeyValueSeparator(&quot;:&quot;);</span>
<span class="nc" id="L646">        return joiner.join(map);</span>
    }

    /**
     * Used to get access to protected/private field of the specified class
     * @param klass - name of the class
     * @param fieldName - name of the field
     * @return Field or null on error
     */
    public static Field getProtectedField(Class klass, String fieldName)
    {
        try
        {
<span class="fc" id="L659">            Field field = klass.getDeclaredField(fieldName);</span>
<span class="fc" id="L660">            field.setAccessible(true);</span>
<span class="fc" id="L661">            return field;</span>
        }
<span class="nc" id="L663">        catch (Exception e)</span>
        {
<span class="nc" id="L665">            throw new AssertionError(e);</span>
        }
    }

    public static &lt;T&gt; CloseableIterator&lt;T&gt; closeableIterator(Iterator&lt;T&gt; iterator)
    {
<span class="nc" id="L671">        return new WrappedCloseableIterator&lt;T&gt;(iterator);</span>
    }

    public static Map&lt;String, String&gt; fromJsonMap(String json)
    {
        try
        {
<span class="nc" id="L678">            return jsonMapper.readValue(json, Map.class);</span>
        }
<span class="nc" id="L680">        catch (IOException e)</span>
        {
<span class="nc" id="L682">            throw new RuntimeException(e);</span>
        }
    }

    public static List&lt;String&gt; fromJsonList(String json)
    {
        try
        {
<span class="nc" id="L690">            return jsonMapper.readValue(json, List.class);</span>
        }
<span class="nc" id="L692">        catch (IOException e)</span>
        {
<span class="nc" id="L694">            throw new RuntimeException(e);</span>
        }
    }

    public static String json(Object object)
    {
        try
        {
<span class="nc" id="L702">            return jsonMapper.writeValueAsString(object);</span>
        }
<span class="nc" id="L704">        catch (IOException e)</span>
        {
<span class="nc" id="L706">            throw new RuntimeException(e);</span>
        }
    }

    public static String prettyPrintMemory(long size)
    {
<span class="fc" id="L712">        return prettyPrintMemory(size, false);</span>
    }

    public static String prettyPrintMemory(long size, boolean includeSpace)
    {
<span class="fc bfc" id="L717" title="All 2 branches covered.">        if (size &gt;= 1 &lt;&lt; 30)</span>
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">            return String.format(&quot;%.3f%sGiB&quot;, size / (double) (1 &lt;&lt; 30), includeSpace ? &quot; &quot; : &quot;&quot;);</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">        if (size &gt;= 1 &lt;&lt; 20)</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">            return String.format(&quot;%.3f%sMiB&quot;, size / (double) (1 &lt;&lt; 20), includeSpace ? &quot; &quot; : &quot;&quot;);</span>
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">        return String.format(&quot;%.3f%sKiB&quot;, size / (double) (1 &lt;&lt; 10), includeSpace ? &quot; &quot; : &quot;&quot;);</span>
    }

    public static String prettyPrintMemoryPerSecond(long rate)
    {
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        if (rate &gt;= 1 &lt;&lt; 30)</span>
<span class="nc" id="L727">            return String.format(&quot;%.3fGiB/s&quot;, rate / (double) (1 &lt;&lt; 30));</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (rate &gt;= 1 &lt;&lt; 20)</span>
<span class="nc" id="L729">            return String.format(&quot;%.3fMiB/s&quot;, rate / (double) (1 &lt;&lt; 20));</span>
<span class="fc" id="L730">        return String.format(&quot;%.3fKiB/s&quot;, rate / (double) (1 &lt;&lt; 10));</span>
    }

    public static String prettyPrintMemoryPerSecond(long bytes, long timeInNano)
    {
        // We can't sanely calculate a rate over 0 nanoseconds
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">        if (timeInNano == 0)</span>
<span class="nc" id="L737">            return &quot;NaN  KiB/s&quot;;</span>

<span class="fc" id="L739">        long rate = (long) (((double) bytes / timeInNano) * 1000 * 1000 * 1000);</span>

<span class="fc" id="L741">        return prettyPrintMemoryPerSecond(rate);</span>
    }

    /**
     * Starts and waits for the given @param pb to finish.
     * @throws java.io.IOException on non-zero exit code
     */
    public static void exec(ProcessBuilder pb) throws IOException
    {
<span class="nc" id="L750">        Process p = pb.start();</span>
        try
        {
<span class="nc" id="L753">            int errCode = p.waitFor();</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">            if (errCode != 0)</span>
            {
<span class="nc" id="L756">            	try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));</span>
<span class="nc" id="L757">                     BufferedReader err = new BufferedReader(new InputStreamReader(p.getErrorStream())))</span>
                {
<span class="nc" id="L759">            		String lineSep = System.getProperty(&quot;line.separator&quot;);</span>
<span class="nc" id="L760">	                StringBuilder sb = new StringBuilder();</span>
	                String str;
<span class="nc bnc" id="L762" title="All 2 branches missed.">	                while ((str = in.readLine()) != null)</span>
<span class="nc" id="L763">	                    sb.append(str).append(lineSep);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">	                while ((str = err.readLine()) != null)</span>
<span class="nc" id="L765">	                    sb.append(str).append(lineSep);</span>
<span class="nc" id="L766">	                throw new IOException(&quot;Exception while executing the command: &quot;+ StringUtils.join(pb.command(), &quot; &quot;) +</span>
	                                      &quot;, command error Code: &quot; + errCode +
<span class="nc" id="L768">	                                      &quot;, command output: &quot;+ sb.toString());</span>
<span class="nc bnc" id="L769" title="All 8 branches missed.">                }</span>
            }
        }
<span class="nc" id="L772">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L774">            throw new AssertionError(e);</span>
<span class="nc" id="L775">        }</span>
<span class="nc" id="L776">    }</span>

    public static void updateChecksumInt(Checksum checksum, int v)
    {
<span class="fc" id="L780">        checksum.update((v &gt;&gt;&gt; 24) &amp; 0xFF);</span>
<span class="fc" id="L781">        checksum.update((v &gt;&gt;&gt; 16) &amp; 0xFF);</span>
<span class="fc" id="L782">        checksum.update((v &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="fc" id="L783">        checksum.update((v &gt;&gt;&gt; 0) &amp; 0xFF);</span>
<span class="fc" id="L784">    }</span>

    /**
      * Updates checksum with the provided ByteBuffer at the given offset + length.
      * Resets position and limit back to their original values on return.
      * This method is *NOT* thread-safe.
      */
    public static void updateChecksum(CRC32 checksum, ByteBuffer buffer, int offset, int length)
    {
<span class="fc" id="L793">        int position = buffer.position();</span>
<span class="fc" id="L794">        int limit = buffer.limit();</span>

<span class="fc" id="L796">        buffer.position(offset).limit(offset + length);</span>
<span class="fc" id="L797">        checksum.update(buffer);</span>

<span class="fc" id="L799">        buffer.position(position).limit(limit);</span>
<span class="fc" id="L800">    }</span>

    /**
     * Updates checksum with the provided ByteBuffer.
     * Resets position back to its original values on return.
     * This method is *NOT* thread-safe.
     */
    public static void updateChecksum(CRC32 checksum, ByteBuffer buffer)
    {
<span class="nc" id="L809">        int position = buffer.position();</span>
<span class="nc" id="L810">        checksum.update(buffer);</span>
<span class="nc" id="L811">        buffer.position(position);</span>
<span class="nc" id="L812">    }</span>

    public static long abs(long index)
    {
<span class="fc" id="L816">        long negbit = index &gt;&gt; 63;</span>
<span class="fc" id="L817">        return (index ^ negbit) - negbit;</span>
    }

    private static final class WrappedCloseableIterator&lt;T&gt;
        extends AbstractIterator&lt;T&gt; implements CloseableIterator&lt;T&gt;
    {
        private final Iterator&lt;T&gt; source;
        public WrappedCloseableIterator(Iterator&lt;T&gt; source)
<span class="nc" id="L825">        {</span>
<span class="nc" id="L826">            this.source = source;</span>
<span class="nc" id="L827">        }</span>

        protected T computeNext()
        {
<span class="nc bnc" id="L831" title="All 2 branches missed.">            if (!source.hasNext())</span>
<span class="nc" id="L832">                return endOfData();</span>
<span class="nc" id="L833">            return source.next();</span>
        }

<span class="nc" id="L836">        public void close() {}</span>
    }

    public static &lt;T&gt; byte[] serialize(T object, IVersionedSerializer&lt;T&gt; serializer, int version)
    {
<span class="nc" id="L841">        int size = (int) serializer.serializedSize(object, version);</span>

<span class="nc" id="L843">        try (DataOutputBuffer buffer = new DataOutputBufferFixed(size))</span>
        {
<span class="nc" id="L845">            serializer.serialize(object, buffer, version);</span>
<span class="nc bnc" id="L846" title="All 6 branches missed.">            assert buffer.getLength() == size &amp;&amp; buffer.getData().length == size</span>
<span class="nc" id="L847">                : String.format(&quot;Final buffer length %s to accommodate data size of %s (predicted %s) for %s&quot;,</span>
<span class="nc" id="L848">                        buffer.getData().length, buffer.getLength(), size, object);</span>
<span class="nc" id="L849">            return buffer.getData();</span>
        }
<span class="nc" id="L851">        catch (IOException e)</span>
        {
            // We're doing in-memory serialization...
<span class="nc" id="L854">            throw new AssertionError(e);</span>
        }
    }

    public static long copy(InputStream from, OutputStream to, long limit) throws IOException
    {
<span class="nc" id="L860">        byte[] buffer = new byte[64]; // 64 byte buffer</span>
<span class="nc" id="L861">        long copied = 0;</span>
<span class="nc" id="L862">        int toCopy = buffer.length;</span>
        while (true)
        {
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if (limit &lt; buffer.length + copied)</span>
<span class="nc" id="L866">                toCopy = (int) (limit - copied);</span>
<span class="nc" id="L867">            int sofar = from.read(buffer, 0, toCopy);</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">            if (sofar == -1)</span>
<span class="nc" id="L869">                break;</span>
<span class="nc" id="L870">            to.write(buffer, 0, sofar);</span>
<span class="nc" id="L871">            copied += sofar;</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">            if (limit == copied)</span>
<span class="nc" id="L873">                break;</span>
<span class="nc" id="L874">        }</span>
<span class="nc" id="L875">        return copied;</span>
    }

    public static File getToolsOutputDirectory()
    {
<span class="nc" id="L880">        File historyDir = new File(System.getProperty(&quot;user.home&quot;), &quot;.cassandra&quot;);</span>
<span class="nc" id="L881">        FileUtils.createDirectory(historyDir);</span>
<span class="nc" id="L882">        return historyDir;</span>
    }

    public static void updateWithShort(MessageDigest digest, int val)
    {
<span class="nc" id="L887">        digest.update((byte) ((val &gt;&gt; 8) &amp; 0xFF));</span>
<span class="nc" id="L888">        digest.update((byte) (val &amp; 0xFF));</span>
<span class="nc" id="L889">    }</span>

    public static void updateWithByte(MessageDigest digest, int val)
    {
<span class="fc" id="L893">        digest.update((byte) (val &amp; 0xFF));</span>
<span class="fc" id="L894">    }</span>

    public static void updateWithInt(MessageDigest digest, int val)
    {
<span class="fc" id="L898">        digest.update((byte) ((val &gt;&gt;&gt; 24) &amp; 0xFF));</span>
<span class="fc" id="L899">        digest.update((byte) ((val &gt;&gt;&gt; 16) &amp; 0xFF));</span>
<span class="fc" id="L900">        digest.update((byte) ((val &gt;&gt;&gt;  8) &amp; 0xFF));</span>
<span class="fc" id="L901">        digest.update((byte) ((val &gt;&gt;&gt; 0) &amp; 0xFF));</span>
<span class="fc" id="L902">    }</span>

    public static void updateWithLong(MessageDigest digest, long val)
    {
<span class="fc" id="L906">        digest.update((byte) ((val &gt;&gt;&gt; 56) &amp; 0xFF));</span>
<span class="fc" id="L907">        digest.update((byte) ((val &gt;&gt;&gt; 48) &amp; 0xFF));</span>
<span class="fc" id="L908">        digest.update((byte) ((val &gt;&gt;&gt; 40) &amp; 0xFF));</span>
<span class="fc" id="L909">        digest.update((byte) ((val &gt;&gt;&gt; 32) &amp; 0xFF));</span>
<span class="fc" id="L910">        digest.update((byte) ((val &gt;&gt;&gt; 24) &amp; 0xFF));</span>
<span class="fc" id="L911">        digest.update((byte) ((val &gt;&gt;&gt; 16) &amp; 0xFF));</span>
<span class="fc" id="L912">        digest.update((byte) ((val &gt;&gt;&gt;  8) &amp; 0xFF));</span>
<span class="fc" id="L913">        digest.update((byte)  ((val &gt;&gt;&gt; 0) &amp; 0xFF));</span>
<span class="fc" id="L914">    }</span>

    public static void updateWithBoolean(MessageDigest digest, boolean val)
    {
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">        updateWithByte(digest, val ? 0 : 1);</span>
<span class="fc" id="L919">    }</span>

    public static void closeAll(Collection&lt;? extends AutoCloseable&gt; l) throws Exception
    {
<span class="nc" id="L923">        Exception toThrow = null;</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">        for (AutoCloseable c : l)</span>
        {
            try
            {
<span class="nc" id="L928">                c.close();</span>
            }
<span class="nc" id="L930">            catch (Exception e)</span>
            {
<span class="nc bnc" id="L932" title="All 2 branches missed.">                if (toThrow == null)</span>
<span class="nc" id="L933">                    toThrow = e;</span>
                else
<span class="nc" id="L935">                    toThrow.addSuppressed(e);</span>
<span class="nc" id="L936">            }</span>
<span class="nc" id="L937">        }</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (toThrow != null)</span>
<span class="nc" id="L939">            throw toThrow;</span>
<span class="nc" id="L940">    }</span>

    public static byte[] toWriteUTFBytes(String s)
    {
        try
        {
<span class="fc" id="L946">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L947">            DataOutputStream dos = new DataOutputStream(baos);</span>
<span class="fc" id="L948">            dos.writeUTF(s);</span>
<span class="fc" id="L949">            dos.flush();</span>
<span class="fc" id="L950">            return baos.toByteArray();</span>
        }
<span class="nc" id="L952">        catch (IOException e)</span>
        {
<span class="nc" id="L954">            throw new RuntimeException(e);</span>
        }
    }

	public static void sleepQuietly(long millis)
    {
        try
        {
<span class="nc" id="L962">            Thread.sleep(millis);</span>
        }
<span class="nc" id="L964">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L966">            throw new RuntimeException(e);</span>
<span class="nc" id="L967">        }</span>
<span class="nc" id="L968">    }</span>

    public static long align(long val, int boundary)
    {
<span class="nc" id="L972">        return (val + boundary) &amp; ~(boundary - 1);</span>
    }

    @VisibleForTesting
    protected static void reset()
    {
<span class="nc" id="L978">        localInetAddress = null;</span>
<span class="nc" id="L979">        broadcastInetAddress = null;</span>
<span class="nc" id="L980">        broadcastRpcAddress = null;</span>
<span class="nc" id="L981">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>