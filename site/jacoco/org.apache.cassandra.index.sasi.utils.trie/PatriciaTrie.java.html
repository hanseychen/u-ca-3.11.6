<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PatriciaTrie.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sasi.utils.trie</a> &gt; <span class="el_source">PatriciaTrie.java</span></div><h1>PatriciaTrie.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2005-2010 Roger Kapsi, Sam Berlin
 *
 *   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package org.apache.cassandra.index.sasi.utils.trie;

import java.io.Serializable;
import java.util.*;

/**
 * This class is taken from https://github.com/rkapsi/patricia-trie (v0.6), and slightly modified
 * to correspond to Cassandra code style, as the only Patricia Trie implementation,
 * which supports pluggable key comparators (e.g. commons-collections PatriciaTrie (which is based
 * on rkapsi/patricia-trie project) only supports String keys)
 * but unfortunately is not deployed to the maven central as a downloadable artifact.
 */

/**
 * &lt;h3&gt;PATRICIA {@link Trie}&lt;/h3&gt;
 *
 * &lt;i&gt;Practical Algorithm to Retrieve Information Coded in Alphanumeric&lt;/i&gt;
 *
 * &lt;p&gt;A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing
 * all data at the edges of the {@link Trie} (and having empty internal nodes),
 * PATRICIA stores data in every node. This allows for very efficient traversal,
 * insert, delete, predecessor, successor, prefix, range, and {@link #select(Object)}
 * operations. All operations are performed at worst in O(K) time, where K
 * is the number of bits in the largest item in the tree. In practice,
 * operations actually take O(A(K)) time, where A(K) is the average number of
 * bits of all items in the tree.
 *
 * &lt;p&gt;Most importantly, PATRICIA requires very few comparisons to keys while
 * doing any operation. While performing a lookup, each comparison (at most
 * K of them, described above) will perform a single bit comparison against
 * the given key, instead of comparing the entire key to another key.
 *
 * &lt;p&gt;The {@link Trie} can return operations in lexicographical order using the
 * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The
 * {@link Trie} can also scan for items that are 'bitwise' (using an XOR
 * metric) by the 'select' method. Bitwise closeness is determined by the
 * {@link KeyAnalyzer} returning true or false for a bit being set or not in
 * a given key.
 *
 * &lt;p&gt;Any methods here that take an {@link Object} argument may throw a
 * {@link ClassCastException} if the method is expecting an instance of K
 * and it isn't K.
 *
 * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_tree&quot;&gt;Radix Tree&lt;/a&gt;
 * @see &lt;a href=&quot;http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA&quot;&gt;PATRICIA&lt;/a&gt;
 * @see &lt;a href=&quot;http://www.imperialviolet.org/binary/critbit.pdf&quot;&gt;Crit-Bit Tree&lt;/a&gt;
 *
 * @author Roger Kapsi
 * @author Sam Berlin
 */
public class PatriciaTrie&lt;K, V&gt; extends AbstractPatriciaTrie&lt;K, V&gt; implements Serializable
{
    private static final long serialVersionUID = -2246014692353432660L;

    public PatriciaTrie(KeyAnalyzer&lt;? super K&gt; keyAnalyzer)
    {
<span class="nc" id="L73">        super(keyAnalyzer);</span>
<span class="nc" id="L74">    }</span>

    public PatriciaTrie(KeyAnalyzer&lt;? super K&gt; keyAnalyzer, Map&lt;? extends K, ? extends V&gt; m)
    {
<span class="nc" id="L78">        super(keyAnalyzer, m);</span>
<span class="nc" id="L79">    }</span>

    @Override
    public Comparator&lt;? super K&gt; comparator()
    {
<span class="nc" id="L84">        return keyAnalyzer;</span>
    }

    @Override
    public SortedMap&lt;K, V&gt; prefixMap(K prefix)
    {
<span class="nc bnc" id="L90" title="All 2 branches missed.">        return lengthInBits(prefix) == 0 ? this : new PrefixRangeMap(prefix);</span>
    }

    @Override
    public K firstKey()
    {
<span class="nc" id="L96">        return firstEntry().getKey();</span>
    }

    @Override
    public K lastKey()
    {
<span class="nc" id="L102">        TrieEntry&lt;K, V&gt; entry = lastEntry();</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        return entry != null ? entry.getKey() : null;</span>
    }

    @Override
    public SortedMap&lt;K, V&gt; headMap(K toKey)
    {
<span class="nc" id="L109">        return new RangeEntryMap(null, toKey);</span>
    }

    @Override
    public SortedMap&lt;K, V&gt; subMap(K fromKey, K toKey)
    {
<span class="nc" id="L115">        return new RangeEntryMap(fromKey, toKey);</span>
    }

    @Override
    public SortedMap&lt;K, V&gt; tailMap(K fromKey)
    {
<span class="nc" id="L121">        return new RangeEntryMap(fromKey, null);</span>
    }

    /**
     * Returns an entry strictly higher than the given key,
     * or null if no such entry exists.
     */
    private TrieEntry&lt;K,V&gt; higherEntry(K key)
    {
        // TODO: Cleanup so that we don't actually have to add/remove from the
        //       tree.  (We do it here because there are other well-defined
        //       functions to perform the search.)
<span class="nc" id="L133">        int lengthInBits = lengthInBits(key);</span>

<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (lengthInBits == 0)</span>
        {
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (!root.isEmpty())</span>
            {
                // If data in root, and more after -- return it.
<span class="nc bnc" id="L140" title="All 2 branches missed.">                return size() &gt; 1 ? nextEntry(root) : null;</span>
            }
            else
            {
                // Root is empty &amp; we want something after empty, return first.
<span class="nc" id="L145">                return firstEntry();</span>
            }
        }

<span class="nc" id="L149">        TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (compareKeys(key, found.key))</span>
<span class="nc" id="L151">            return nextEntry(found);</span>

<span class="nc" id="L153">        int bitIndex = bitIndex(key, found.key);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (Tries.isValidBitIndex(bitIndex))</span>
        {
<span class="nc" id="L156">            return replaceCeil(key, bitIndex);</span>
        }
<span class="nc bnc" id="L158" title="All 2 branches missed.">        else if (Tries.isNullBitKey(bitIndex))</span>
        {
<span class="nc bnc" id="L160" title="All 2 branches missed.">            if (!root.isEmpty())</span>
            {
<span class="nc" id="L162">                return firstEntry();</span>
            }
<span class="nc bnc" id="L164" title="All 2 branches missed.">            else if (size() &gt; 1)</span>
            {
<span class="nc" id="L166">                return nextEntry(firstEntry());</span>
            }
            else
            {
<span class="nc" id="L170">                return null;</span>
            }
        }
<span class="nc bnc" id="L173" title="All 2 branches missed.">        else if (Tries.isEqualBitKey(bitIndex))</span>
        {
<span class="nc" id="L175">            return nextEntry(found);</span>
        }

        // we should have exited above.
<span class="nc" id="L179">        throw new IllegalStateException(&quot;invalid lookup: &quot; + key);</span>
    }

    /**
     * Returns a key-value mapping associated with the least key greater
     * than or equal to the given key, or null if there is no such key.
     */
    TrieEntry&lt;K,V&gt; ceilingEntry(K key)
    {
        // Basically:
        // Follow the steps of adding an entry, but instead...
        //
        // - If we ever encounter a situation where we found an equal
        //   key, we return it immediately.
        //
        // - If we hit an empty root, return the first iterable item.
        //
        // - If we have to add a new item, we temporarily add it,
        //   find the successor to it, then remove the added item.
        //
        // These steps ensure that the returned value is either the
        // entry for the key itself, or the first entry directly after
        // the key.

        // TODO: Cleanup so that we don't actually have to add/remove from the
        //       tree.  (We do it here because there are other well-defined
        //       functions to perform the search.)
<span class="nc" id="L206">        int lengthInBits = lengthInBits(key);</span>

<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (lengthInBits == 0)</span>
        {
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (!root.isEmpty())</span>
            {
<span class="nc" id="L212">                return root;</span>
            }
            else
            {
<span class="nc" id="L216">                return firstEntry();</span>
            }
        }

<span class="nc" id="L220">        TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (compareKeys(key, found.key))</span>
<span class="nc" id="L222">            return found;</span>

<span class="nc" id="L224">        int bitIndex = bitIndex(key, found.key);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (Tries.isValidBitIndex(bitIndex))</span>
        {
<span class="nc" id="L227">            return replaceCeil(key, bitIndex);</span>
        }
<span class="nc bnc" id="L229" title="All 2 branches missed.">        else if (Tries.isNullBitKey(bitIndex))</span>
        {
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (!root.isEmpty())</span>
            {
<span class="nc" id="L233">                return root;</span>
            }
            else
            {
<span class="nc" id="L237">                return firstEntry();</span>
            }
        }
<span class="nc bnc" id="L240" title="All 2 branches missed.">        else if (Tries.isEqualBitKey(bitIndex))</span>
        {
<span class="nc" id="L242">            return found;</span>
        }

        // we should have exited above.
<span class="nc" id="L246">        throw new IllegalStateException(&quot;invalid lookup: &quot; + key);</span>
    }

    private TrieEntry&lt;K, V&gt; replaceCeil(K key, int bitIndex)
    {
<span class="nc" id="L251">        TrieEntry&lt;K, V&gt; added = new TrieEntry&lt;&gt;(key, null, bitIndex);</span>
<span class="nc" id="L252">        addEntry(added);</span>
<span class="nc" id="L253">        incrementSize(); // must increment because remove will decrement</span>
<span class="nc" id="L254">        TrieEntry&lt;K, V&gt; ceil = nextEntry(added);</span>
<span class="nc" id="L255">        removeEntry(added);</span>
<span class="nc" id="L256">        modCount -= 2; // we didn't really modify it.</span>
<span class="nc" id="L257">        return ceil;</span>
    }

    private TrieEntry&lt;K, V&gt; replaceLower(K key, int bitIndex)
    {
<span class="nc" id="L262">        TrieEntry&lt;K, V&gt; added = new TrieEntry&lt;&gt;(key, null, bitIndex);</span>
<span class="nc" id="L263">        addEntry(added);</span>
<span class="nc" id="L264">        incrementSize(); // must increment because remove will decrement</span>
<span class="nc" id="L265">        TrieEntry&lt;K, V&gt; prior = previousEntry(added);</span>
<span class="nc" id="L266">        removeEntry(added);</span>
<span class="nc" id="L267">        modCount -= 2; // we didn't really modify it.</span>
<span class="nc" id="L268">        return prior;</span>
    }

    /**
     * Returns a key-value mapping associated with the greatest key
     * strictly less than the given key, or null if there is no such key.
     */
    TrieEntry&lt;K,V&gt; lowerEntry(K key)
    {
        // Basically:
        // Follow the steps of adding an entry, but instead...
        //
        // - If we ever encounter a situation where we found an equal
        //   key, we return it's previousEntry immediately.
        //
        // - If we hit root (empty or not), return null.
        //
        // - If we have to add a new item, we temporarily add it,
        //   find the previousEntry to it, then remove the added item.
        //
        // These steps ensure that the returned value is always just before
        // the key or null (if there was nothing before it).

        // TODO: Cleanup so that we don't actually have to add/remove from the
        //       tree.  (We do it here because there are other well-defined
        //       functions to perform the search.)
<span class="nc" id="L294">        int lengthInBits = lengthInBits(key);</span>

<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (lengthInBits == 0)</span>
<span class="nc" id="L297">            return null; // there can never be anything before root.</span>

<span class="nc" id="L299">        TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (compareKeys(key, found.key))</span>
<span class="nc" id="L301">            return previousEntry(found);</span>

<span class="nc" id="L303">        int bitIndex = bitIndex(key, found.key);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (Tries.isValidBitIndex(bitIndex))</span>
        {
<span class="nc" id="L306">            return replaceLower(key, bitIndex);</span>
        }
<span class="nc bnc" id="L308" title="All 2 branches missed.">        else if (Tries.isNullBitKey(bitIndex))</span>
        {
<span class="nc" id="L310">            return null;</span>
        }
<span class="nc bnc" id="L312" title="All 2 branches missed.">        else if (Tries.isEqualBitKey(bitIndex))</span>
        {
<span class="nc" id="L314">            return previousEntry(found);</span>
        }

        // we should have exited above.
<span class="nc" id="L318">        throw new IllegalStateException(&quot;invalid lookup: &quot; + key);</span>
    }

    /**
     * Returns a key-value mapping associated with the greatest key
     * less than or equal to the given key, or null if there is no such key.
     */
    TrieEntry&lt;K,V&gt; floorEntry(K key) {
        // TODO: Cleanup so that we don't actually have to add/remove from the
        //       tree.  (We do it here because there are other well-defined
        //       functions to perform the search.)
<span class="nc" id="L329">        int lengthInBits = lengthInBits(key);</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (lengthInBits == 0)</span>
        {
<span class="nc bnc" id="L333" title="All 2 branches missed.">            return !root.isEmpty() ? root : null;</span>
        }

<span class="nc" id="L336">        TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (compareKeys(key, found.key))</span>
<span class="nc" id="L338">            return found;</span>

<span class="nc" id="L340">        int bitIndex = bitIndex(key, found.key);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (Tries.isValidBitIndex(bitIndex))</span>
        {
<span class="nc" id="L343">            return replaceLower(key, bitIndex);</span>
        }
<span class="nc bnc" id="L345" title="All 2 branches missed.">        else if (Tries.isNullBitKey(bitIndex))</span>
        {
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (!root.isEmpty())</span>
            {
<span class="nc" id="L349">                return root;</span>
            }
            else
            {
<span class="nc" id="L353">                return null;</span>
            }
        }
<span class="nc bnc" id="L356" title="All 2 branches missed.">        else if (Tries.isEqualBitKey(bitIndex))</span>
        {
<span class="nc" id="L358">            return found;</span>
        }

        // we should have exited above.
<span class="nc" id="L362">        throw new IllegalStateException(&quot;invalid lookup: &quot; + key);</span>
    }

    /**
     * Finds the subtree that contains the prefix.
     *
     * This is very similar to getR but with the difference that
     * we stop the lookup if h.bitIndex &gt; lengthInBits.
     */
    private TrieEntry&lt;K, V&gt; subtree(K prefix)
    {
<span class="nc" id="L373">        int lengthInBits = lengthInBits(prefix);</span>

<span class="nc" id="L375">        TrieEntry&lt;K, V&gt; current = root.left;</span>
<span class="nc" id="L376">        TrieEntry&lt;K, V&gt; path = root;</span>
        while(true)
        {
<span class="nc bnc" id="L379" title="All 4 branches missed.">            if (current.bitIndex &lt;= path.bitIndex || lengthInBits &lt; current.bitIndex)</span>
<span class="nc" id="L380">                break;</span>

<span class="nc" id="L382">            path = current;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            current = !isBitSet(prefix, current.bitIndex)</span>
                    ? current.left : current.right;
        }

        // Make sure the entry is valid for a subtree.
<span class="nc bnc" id="L388" title="All 2 branches missed.">        TrieEntry&lt;K, V&gt; entry = current.isEmpty() ? path : current;</span>

        // If entry is root, it can't be empty.
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (entry.isEmpty())</span>
<span class="nc" id="L392">            return null;</span>

        // if root &amp;&amp; length of root is less than length of lookup,
        // there's nothing.
        // (this prevents returning the whole subtree if root has an empty
        //  string and we want to lookup things with &quot;\0&quot;)
<span class="nc bnc" id="L398" title="All 4 branches missed.">        if (entry == root &amp;&amp; lengthInBits(entry.getKey()) &lt; lengthInBits)</span>
<span class="nc" id="L399">            return null;</span>

        // Found key's length-th bit differs from our key
        // which means it cannot be the prefix...
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (isBitSet(prefix, lengthInBits) != isBitSet(entry.key, lengthInBits))</span>
<span class="nc" id="L404">            return null;</span>

        // ... or there are less than 'length' equal bits
<span class="nc" id="L407">        int bitIndex = bitIndex(prefix, entry.key);</span>
<span class="nc bnc" id="L408" title="All 4 branches missed.">        return (bitIndex &gt;= 0 &amp;&amp; bitIndex &lt; lengthInBits) ? null : entry;</span>
    }

    /**
     * Returns the last entry the {@link Trie} is storing.
     *
     * &lt;p&gt;This is implemented by going always to the right until
     * we encounter a valid uplink. That uplink is the last key.
     */
    private TrieEntry&lt;K, V&gt; lastEntry()
    {
<span class="nc" id="L419">        return followRight(root.left);</span>
    }

    /**
     * Traverses down the right path until it finds an uplink.
     */
    private TrieEntry&lt;K, V&gt; followRight(TrieEntry&lt;K, V&gt; node)
    {
        // if Trie is empty, no last entry.
<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (node.right == null)</span>
<span class="nc" id="L429">            return null;</span>

        // Go as far right as possible, until we encounter an uplink.
<span class="nc bnc" id="L432" title="All 2 branches missed.">        while (node.right.bitIndex &gt; node.bitIndex)</span>
        {
<span class="nc" id="L434">            node = node.right;</span>
        }

<span class="nc" id="L437">        return node.right;</span>
    }

    /**
     * Returns the node lexicographically before the given node (or null if none).
     *
     * This follows four simple branches:
     *  - If the uplink that returned us was a right uplink:
     *      - If predecessor's left is a valid uplink from predecessor, return it.
     *      - Else, follow the right path from the predecessor's left.
     *  - If the uplink that returned us was a left uplink:
     *      - Loop back through parents until we encounter a node where
     *        node != node.parent.left.
     *          - If node.parent.left is uplink from node.parent:
     *              - If node.parent.left is not root, return it.
     *              - If it is root &amp; root isEmpty, return null.
     *              - If it is root &amp; root !isEmpty, return root.
     *          - If node.parent.left is not uplink from node.parent:
     *              - Follow right path for first right child from node.parent.left
     *
     * @param start the start entry
     */
    private TrieEntry&lt;K, V&gt; previousEntry(TrieEntry&lt;K, V&gt; start)
    {
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (start.predecessor == null)</span>
<span class="nc" id="L462">            throw new IllegalArgumentException(&quot;must have come from somewhere!&quot;);</span>

<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (start.predecessor.right == start)</span>
        {
<span class="nc bnc" id="L466" title="All 2 branches missed.">            return isValidUplink(start.predecessor.left, start.predecessor)</span>
                    ? start.predecessor.left
<span class="nc" id="L468">                    : followRight(start.predecessor.left);</span>
        }

<span class="nc" id="L471">        TrieEntry&lt;K, V&gt; node = start.predecessor;</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">        while (node.parent != null &amp;&amp; node == node.parent.left)</span>
        {
<span class="nc" id="L474">            node = node.parent;</span>
        }

<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (node.parent == null) // can be null if we're looking up root.</span>
<span class="nc" id="L478">            return null;</span>

<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (isValidUplink(node.parent.left, node.parent))</span>
        {
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (node.parent.left == root)</span>
            {
<span class="nc bnc" id="L484" title="All 2 branches missed.">                return root.isEmpty() ? null : root;</span>
            }
            else
            {
<span class="nc" id="L488">                return node.parent.left;</span>
            }
        }
        else
        {
<span class="nc" id="L493">            return followRight(node.parent.left);</span>
        }
    }

    /**
     * Returns the entry lexicographically after the given entry.
     * If the given entry is null, returns the first node.
     *
     * This will traverse only within the subtree.  If the given node
     * is not within the subtree, this will have undefined results.
     */
    private TrieEntry&lt;K, V&gt; nextEntryInSubtree(TrieEntry&lt;K, V&gt; node, TrieEntry&lt;K, V&gt; parentOfSubtree)
    {
<span class="nc bnc" id="L506" title="All 2 branches missed.">        return (node == null) ? firstEntry() : nextEntryImpl(node.predecessor, node, parentOfSubtree);</span>
    }

    private boolean isPrefix(K key, K prefix)
    {
<span class="nc" id="L511">        return keyAnalyzer.isPrefix(key, prefix);</span>
    }

    /**
     * A range view of the {@link Trie}
     */
<span class="nc" id="L517">    private abstract class RangeMap extends AbstractMap&lt;K, V&gt; implements SortedMap&lt;K, V&gt;</span>
    {
        /**
         * The {@link #entrySet()} view
         */
        private transient volatile Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;

        /**
         * Creates and returns an {@link #entrySet()}
         * view of the {@link RangeMap}
         */
        protected abstract Set&lt;Map.Entry&lt;K, V&gt;&gt; createEntrySet();

        /**
         * Returns the FROM Key
         */
        protected abstract K getFromKey();

        /**
         * Whether or not the {@link #getFromKey()} is in the range
         */
        protected abstract boolean isFromInclusive();

        /**
         * Returns the TO Key
         */
        protected abstract K getToKey();

        /**
         * Whether or not the {@link #getToKey()} is in the range
         */
        protected abstract boolean isToInclusive();


        @Override
        public Comparator&lt;? super K&gt; comparator()
        {
<span class="nc" id="L554">            return PatriciaTrie.this.comparator();</span>
        }

        @Override
        public boolean containsKey(Object key)
        {
<span class="nc bnc" id="L560" title="All 4 branches missed.">            return inRange(Tries.&lt;K&gt;cast(key)) &amp;&amp; PatriciaTrie.this.containsKey(key);</span>
        }

        @Override
        public V remove(Object key)
        {
<span class="nc bnc" id="L566" title="All 2 branches missed.">            return (!inRange(Tries.&lt;K&gt;cast(key))) ? null : PatriciaTrie.this.remove(key);</span>
        }

        @Override
        public V get(Object key)
        {
<span class="nc bnc" id="L572" title="All 2 branches missed.">            return (!inRange(Tries.&lt;K&gt;cast(key))) ? null : PatriciaTrie.this.get(key);</span>
        }

        @Override
        public V put(K key, V value)
        {
<span class="nc bnc" id="L578" title="All 2 branches missed.">            if (!inRange(key))</span>
<span class="nc" id="L579">                throw new IllegalArgumentException(&quot;Key is out of range: &quot; + key);</span>

<span class="nc" id="L581">            return PatriciaTrie.this.put(key, value);</span>
        }

        @Override
        public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()
        {
<span class="nc bnc" id="L587" title="All 2 branches missed.">            if (entrySet == null)</span>
<span class="nc" id="L588">                entrySet = createEntrySet();</span>
<span class="nc" id="L589">            return entrySet;</span>
        }

        @Override
        public SortedMap&lt;K, V&gt; subMap(K fromKey, K toKey)
        {
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (!inRange2(fromKey))</span>
<span class="nc" id="L596">                throw new IllegalArgumentException(&quot;FromKey is out of range: &quot; + fromKey);</span>

<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (!inRange2(toKey))</span>
<span class="nc" id="L599">                throw new IllegalArgumentException(&quot;ToKey is out of range: &quot; + toKey);</span>

<span class="nc" id="L601">            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());</span>
        }

        @Override
        public SortedMap&lt;K, V&gt; headMap(K toKey)
        {
<span class="nc bnc" id="L607" title="All 2 branches missed.">            if (!inRange2(toKey))</span>
<span class="nc" id="L608">                throw new IllegalArgumentException(&quot;ToKey is out of range: &quot; + toKey);</span>

<span class="nc" id="L610">            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());</span>
        }

        @Override
        public SortedMap&lt;K, V&gt; tailMap(K fromKey)
        {
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (!inRange2(fromKey))</span>
<span class="nc" id="L617">                throw new IllegalArgumentException(&quot;FromKey is out of range: &quot; + fromKey);</span>

<span class="nc" id="L619">            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());</span>
        }

        /**
         * Returns true if the provided key is greater than TO and
         * less than FROM
         */
        protected boolean inRange(K key)
        {
<span class="nc" id="L628">            K fromKey = getFromKey();</span>
<span class="nc" id="L629">            K toKey = getToKey();</span>

<span class="nc bnc" id="L631" title="All 6 branches missed.">            return (fromKey == null || inFromRange(key, false))</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">                    &amp;&amp; (toKey == null || inToRange(key, false));</span>
        }

        /**
         * This form allows the high endpoint (as well as all legit keys)
         */
        protected boolean inRange2(K key)
        {
<span class="nc" id="L640">            K fromKey = getFromKey();</span>
<span class="nc" id="L641">            K toKey = getToKey();</span>

<span class="nc bnc" id="L643" title="All 6 branches missed.">            return (fromKey == null || inFromRange(key, false))</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                    &amp;&amp; (toKey == null || inToRange(key, true));</span>
        }

        /**
         * Returns true if the provided key is in the FROM range
         * of the {@link RangeMap}
         */
        protected boolean inFromRange(K key, boolean forceInclusive)
        {
<span class="nc" id="L653">            K fromKey = getFromKey();</span>
<span class="nc" id="L654">            boolean fromInclusive = isFromInclusive();</span>

<span class="nc" id="L656">            int ret = keyAnalyzer.compare(key, fromKey);</span>
<span class="nc bnc" id="L657" title="All 8 branches missed.">            return (fromInclusive || forceInclusive) ? ret &gt;= 0 : ret &gt; 0;</span>
        }

        /**
         * Returns true if the provided key is in the TO range
         * of the {@link RangeMap}
         */
        protected boolean inToRange(K key, boolean forceInclusive)
        {
<span class="nc" id="L666">            K toKey = getToKey();</span>
<span class="nc" id="L667">            boolean toInclusive = isToInclusive();</span>

<span class="nc" id="L669">            int ret = keyAnalyzer.compare(key, toKey);</span>
<span class="nc bnc" id="L670" title="All 8 branches missed.">            return (toInclusive || forceInclusive) ? ret &lt;= 0 : ret &lt; 0;</span>
        }

        /**
         * Creates and returns a sub-range view of the current {@link RangeMap}
         */
        protected abstract SortedMap&lt;K, V&gt; createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive);
    }

   /**
    * A {@link RangeMap} that deals with {@link Entry}s
    */
   private class RangeEntryMap extends RangeMap
   {
       /**
        * The key to start from, null if the beginning.
        */
       protected final K fromKey;

       /**
        * The key to end at, null if till the end.
        */
       protected final K toKey;

       /**
        * Whether or not the 'from' is inclusive.
        */
       protected final boolean fromInclusive;

       /**
        * Whether or not the 'to' is inclusive.
        */
       protected final boolean toInclusive;

       /**
        * Creates a {@link RangeEntryMap} with the fromKey included and
        * the toKey excluded from the range
        */
       protected RangeEntryMap(K fromKey, K toKey)
       {
<span class="nc" id="L710">           this(fromKey, true, toKey, false);</span>
<span class="nc" id="L711">       }</span>

       /**
        * Creates a {@link RangeEntryMap}
        */
       protected RangeEntryMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
<span class="nc" id="L717">       {</span>
<span class="nc bnc" id="L718" title="All 4 branches missed.">           if (fromKey == null &amp;&amp; toKey == null)</span>
<span class="nc" id="L719">               throw new IllegalArgumentException(&quot;must have a from or to!&quot;);</span>

<span class="nc bnc" id="L721" title="All 6 branches missed.">           if (fromKey != null &amp;&amp; toKey != null &amp;&amp; keyAnalyzer.compare(fromKey, toKey) &gt; 0)</span>
<span class="nc" id="L722">               throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;);</span>

<span class="nc" id="L724">           this.fromKey = fromKey;</span>
<span class="nc" id="L725">           this.fromInclusive = fromInclusive;</span>
<span class="nc" id="L726">           this.toKey = toKey;</span>
<span class="nc" id="L727">           this.toInclusive = toInclusive;</span>
<span class="nc" id="L728">       }</span>


       @Override
       public K firstKey()
       {
<span class="nc bnc" id="L734" title="All 2 branches missed.">           Map.Entry&lt;K,V&gt; e  = fromKey == null</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">                ? firstEntry()</span>
<span class="nc" id="L736">                : fromInclusive ? ceilingEntry(fromKey) : higherEntry(fromKey);</span>

<span class="nc bnc" id="L738" title="All 2 branches missed.">           K first = e != null ? e.getKey() : null;</span>
<span class="nc bnc" id="L739" title="All 6 branches missed.">           if (e == null || toKey != null &amp;&amp; !inToRange(first, false))</span>
<span class="nc" id="L740">               throw new NoSuchElementException();</span>

<span class="nc" id="L742">           return first;</span>
       }


       @Override
       public K lastKey()
       {
<span class="nc bnc" id="L749" title="All 2 branches missed.">           Map.Entry&lt;K,V&gt; e = toKey == null</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">                ? lastEntry()</span>
<span class="nc" id="L751">                : toInclusive ? floorEntry(toKey) : lowerEntry(toKey);</span>

<span class="nc bnc" id="L753" title="All 2 branches missed.">           K last = e != null ? e.getKey() : null;</span>
<span class="nc bnc" id="L754" title="All 6 branches missed.">           if (e == null || fromKey != null &amp;&amp; !inFromRange(last, false))</span>
<span class="nc" id="L755">               throw new NoSuchElementException();</span>

<span class="nc" id="L757">           return last;</span>
       }

       @Override
       protected Set&lt;Entry&lt;K, V&gt;&gt; createEntrySet()
       {
<span class="nc" id="L763">           return new RangeEntrySet(this);</span>
       }

       @Override
       public K getFromKey()
       {
<span class="nc" id="L769">           return fromKey;</span>
       }

       @Override
       public K getToKey()
       {
<span class="nc" id="L775">           return toKey;</span>
       }

       @Override
       public boolean isFromInclusive()
       {
<span class="nc" id="L781">           return fromInclusive;</span>
       }

       @Override
       public boolean isToInclusive()
       {
<span class="nc" id="L787">           return toInclusive;</span>
       }

       @Override
       protected SortedMap&lt;K, V&gt; createRangeMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
       {
<span class="nc" id="L793">           return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);</span>
       }
   }

    /**
     * A {@link Set} view of a {@link RangeMap}
     */
    private class RangeEntrySet extends AbstractSet&lt;Map.Entry&lt;K, V&gt;&gt;
    {

        private final RangeMap delegate;

<span class="nc" id="L805">        private int size = -1;</span>

<span class="nc" id="L807">        private int expectedModCount = -1;</span>

        /**
         * Creates a {@link RangeEntrySet}
         */
        public RangeEntrySet(RangeMap delegate)
<span class="nc" id="L813">        {</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if (delegate == null)</span>
<span class="nc" id="L815">                throw new NullPointerException(&quot;delegate&quot;);</span>

<span class="nc" id="L817">            this.delegate = delegate;</span>
<span class="nc" id="L818">        }</span>

        @Override
        public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator()
        {
<span class="nc" id="L823">            K fromKey = delegate.getFromKey();</span>
<span class="nc" id="L824">            K toKey = delegate.getToKey();</span>

<span class="nc bnc" id="L826" title="All 2 branches missed.">            TrieEntry&lt;K, V&gt; first = fromKey == null ? firstEntry() : ceilingEntry(fromKey);</span>
<span class="nc" id="L827">            TrieEntry&lt;K, V&gt; last = null;</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">            if (toKey != null)</span>
<span class="nc" id="L829">                last = ceilingEntry(toKey);</span>

<span class="nc" id="L831">            return new EntryIterator(first, last);</span>
        }

        @Override
        public int size()
        {
<span class="nc bnc" id="L837" title="All 4 branches missed.">            if (size == -1 || expectedModCount != PatriciaTrie.this.modCount)</span>
            {
<span class="nc" id="L839">                size = 0;</span>

<span class="nc bnc" id="L841" title="All 2 branches missed.">                for (Iterator&lt;?&gt; it = iterator(); it.hasNext(); it.next())</span>
                {
<span class="nc" id="L843">                    ++size;</span>
                }

<span class="nc" id="L846">                expectedModCount = PatriciaTrie.this.modCount;</span>
            }

<span class="nc" id="L849">            return size;</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc bnc" id="L855" title="All 2 branches missed.">            return !iterator().hasNext();</span>
        }

        @Override
        public boolean contains(Object o)
        {
<span class="nc bnc" id="L861" title="All 2 branches missed.">            if (!(o instanceof Map.Entry&lt;?, ?&gt;))</span>
<span class="nc" id="L862">                return false;</span>

            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L865">            Map.Entry&lt;K, V&gt; entry = (Map.Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L866">            K key = entry.getKey();</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">            if (!delegate.inRange(key))</span>
<span class="nc" id="L868">                return false;</span>

<span class="nc" id="L870">            TrieEntry&lt;K, V&gt; node = getEntry(key);</span>
<span class="nc bnc" id="L871" title="All 4 branches missed.">            return node != null &amp;&amp; Tries.areEqual(node.getValue(), entry.getValue());</span>
        }

        @Override
        public boolean remove(Object o)
        {
<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (!(o instanceof Map.Entry&lt;?, ?&gt;))</span>
<span class="nc" id="L878">                return false;</span>

            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L881">            Map.Entry&lt;K, V&gt; entry = (Map.Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L882">            K key = entry.getKey();</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">            if (!delegate.inRange(key))</span>
<span class="nc" id="L884">                return false;</span>

<span class="nc" id="L886">            TrieEntry&lt;K, V&gt; node = getEntry(key);</span>
<span class="nc bnc" id="L887" title="All 4 branches missed.">            if (node != null &amp;&amp; Tries.areEqual(node.getValue(), entry.getValue()))</span>
            {
<span class="nc" id="L889">                removeEntry(node);</span>
<span class="nc" id="L890">                return true;</span>
            }

<span class="nc" id="L893">            return false;</span>
        }

        /**
         * An {@link Iterator} for {@link RangeEntrySet}s.
         */
        private final class EntryIterator extends TrieIterator&lt;Map.Entry&lt;K,V&gt;&gt;
        {
            private final K excludedKey;

            /**
             * Creates a {@link EntryIterator}
             */
            private EntryIterator(TrieEntry&lt;K,V&gt; first, TrieEntry&lt;K,V&gt; last)
<span class="nc" id="L907">            {</span>
<span class="nc" id="L908">                super(first);</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">                this.excludedKey = (last != null ? last.getKey() : null);</span>
<span class="nc" id="L910">            }</span>

            @Override
            public boolean hasNext()
            {
<span class="nc bnc" id="L915" title="All 4 branches missed.">                return next != null &amp;&amp; !Tries.areEqual(next.key, excludedKey);</span>
            }

            @Override
            public Map.Entry&lt;K,V&gt; next()
            {
<span class="nc bnc" id="L921" title="All 4 branches missed.">                if (next == null || Tries.areEqual(next.key, excludedKey))</span>
<span class="nc" id="L922">                    throw new NoSuchElementException();</span>

<span class="nc" id="L924">                return nextEntry();</span>
            }
        }
    }

    /**
     * A submap used for prefix views over the {@link Trie}.
     */
    private class PrefixRangeMap extends RangeMap
    {

        private final K prefix;

<span class="nc" id="L937">        private K fromKey = null;</span>

<span class="nc" id="L939">        private K toKey = null;</span>

<span class="nc" id="L941">        private int expectedModCount = -1;</span>

<span class="nc" id="L943">        private int size = -1;</span>

        /**
         * Creates a {@link PrefixRangeMap}
         */
        private PrefixRangeMap(K prefix)
<span class="nc" id="L949">        {</span>
<span class="nc" id="L950">            this.prefix = prefix;</span>
<span class="nc" id="L951">        }</span>

        /**
         * This method does two things. It determinates the FROM
         * and TO range of the {@link PrefixRangeMap} and the number
         * of elements in the range. This method must be called every
         * time the {@link Trie} has changed.
         */
        private int fixup()
        {
            // The trie has changed since we last
            // found our toKey / fromKey
<span class="nc bnc" id="L963" title="All 4 branches missed.">            if (size == - 1 || PatriciaTrie.this.modCount != expectedModCount)</span>
            {
<span class="nc" id="L965">                Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = entrySet().iterator();</span>
<span class="nc" id="L966">                size = 0;</span>

<span class="nc" id="L968">                Map.Entry&lt;K, V&gt; entry = null;</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">                if (it.hasNext())</span>
                {
<span class="nc" id="L971">                    entry = it.next();</span>
<span class="nc" id="L972">                    size = 1;</span>
                }

<span class="nc bnc" id="L975" title="All 2 branches missed.">                fromKey = entry == null ? null : entry.getKey();</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                if (fromKey != null)</span>
                {
<span class="nc" id="L978">                    TrieEntry&lt;K, V&gt; prior = previousEntry((TrieEntry&lt;K, V&gt;)entry);</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">                    fromKey = prior == null ? null : prior.getKey();</span>
                }

<span class="nc" id="L982">                toKey = fromKey;</span>

<span class="nc bnc" id="L984" title="All 2 branches missed.">                while (it.hasNext())</span>
                {
<span class="nc" id="L986">                    ++size;</span>
<span class="nc" id="L987">                    entry = it.next();</span>
                }

<span class="nc bnc" id="L990" title="All 2 branches missed.">                toKey = entry == null ? null : entry.getKey();</span>

<span class="nc bnc" id="L992" title="All 2 branches missed.">                if (toKey != null)</span>
                {
<span class="nc" id="L994">                    entry = nextEntry((TrieEntry&lt;K, V&gt;)entry);</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">                    toKey = entry == null ? null : entry.getKey();</span>
                }

<span class="nc" id="L998">                expectedModCount = PatriciaTrie.this.modCount;</span>
            }

<span class="nc" id="L1001">            return size;</span>
        }

        @Override
        public K firstKey()
        {
<span class="nc" id="L1007">            fixup();</span>

<span class="nc bnc" id="L1009" title="All 2 branches missed.">            Map.Entry&lt;K,V&gt; e = fromKey == null ? firstEntry() : higherEntry(fromKey);</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">            K first = e != null ? e.getKey() : null;</span>
<span class="nc bnc" id="L1011" title="All 4 branches missed.">            if (e == null || !isPrefix(first, prefix))</span>
<span class="nc" id="L1012">                throw new NoSuchElementException();</span>

<span class="nc" id="L1014">            return first;</span>
        }

        @Override
        public K lastKey()
        {
<span class="nc" id="L1020">            fixup();</span>

<span class="nc bnc" id="L1022" title="All 2 branches missed.">            Map.Entry&lt;K,V&gt; e = toKey == null ? lastEntry() : lowerEntry(toKey);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">            K last = e != null ? e.getKey() : null;</span>
<span class="nc bnc" id="L1024" title="All 4 branches missed.">            if (e == null || !isPrefix(last, prefix))</span>
<span class="nc" id="L1025">                throw new NoSuchElementException();</span>

<span class="nc" id="L1027">            return last;</span>
        }

        /**
         * Returns true if this {@link PrefixRangeMap}'s key is a prefix
         * of the provided key.
         */
        @Override
        protected boolean inRange(K key)
        {
<span class="nc" id="L1037">            return isPrefix(key, prefix);</span>
        }

        /**
         * Same as {@link #inRange(Object)}
         */
        @Override
        protected boolean inRange2(K key)
        {
<span class="nc" id="L1046">            return inRange(key);</span>
        }

        /**
         * Returns true if the provided Key is in the FROM range
         * of the {@link PrefixRangeMap}
         */
        @Override
        protected boolean inFromRange(K key, boolean forceInclusive)
        {
<span class="nc" id="L1056">            return isPrefix(key, prefix);</span>
        }

        /**
         * Returns true if the provided Key is in the TO range
         * of the {@link PrefixRangeMap}
         */
        @Override
        protected boolean inToRange(K key, boolean forceInclusive)
        {
<span class="nc" id="L1066">            return isPrefix(key, prefix);</span>
        }

        @Override
        protected Set&lt;Map.Entry&lt;K, V&gt;&gt; createEntrySet()
        {
<span class="nc" id="L1072">            return new PrefixRangeEntrySet(this);</span>
        }

        @Override
        public K getFromKey()
        {
<span class="nc" id="L1078">            return fromKey;</span>
        }

        @Override
        public K getToKey()
        {
<span class="nc" id="L1084">            return toKey;</span>
        }

        @Override
        public boolean isFromInclusive()
        {
<span class="nc" id="L1090">            return false;</span>
        }

        @Override
        public boolean isToInclusive()
        {
<span class="nc" id="L1096">            return false;</span>
        }

        @Override
        protected SortedMap&lt;K, V&gt; createRangeMap(K fromKey, boolean fromInclusive,
                                                 K toKey, boolean toInclusive)
        {
<span class="nc" id="L1103">            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);</span>
        }
    }

    /**
     * A prefix {@link RangeEntrySet} view of the {@link Trie}
     */
    private final class PrefixRangeEntrySet extends RangeEntrySet
    {
        private final PrefixRangeMap delegate;

        private TrieEntry&lt;K, V&gt; prefixStart;

<span class="nc" id="L1116">        private int expectedModCount = -1;</span>

        /**
         * Creates a {@link PrefixRangeEntrySet}
         */
        public PrefixRangeEntrySet(PrefixRangeMap delegate)
<span class="nc" id="L1122">        {</span>
<span class="nc" id="L1123">            super(delegate);</span>
<span class="nc" id="L1124">            this.delegate = delegate;</span>
<span class="nc" id="L1125">        }</span>

        @Override
        public int size()
        {
<span class="nc" id="L1130">            return delegate.fixup();</span>
        }

        @Override
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator()
        {
<span class="nc bnc" id="L1136" title="All 2 branches missed.">            if (PatriciaTrie.this.modCount != expectedModCount)</span>
            {
<span class="nc" id="L1138">                prefixStart = subtree(delegate.prefix);</span>
<span class="nc" id="L1139">                expectedModCount = PatriciaTrie.this.modCount;</span>
            }

<span class="nc bnc" id="L1142" title="All 2 branches missed.">            if (prefixStart == null)</span>
            {
<span class="nc" id="L1144">                Set&lt;Map.Entry&lt;K,V&gt;&gt; empty = Collections.emptySet();</span>
<span class="nc" id="L1145">                return empty.iterator();</span>
            }
<span class="nc bnc" id="L1147" title="All 2 branches missed.">            else if (lengthInBits(delegate.prefix) &gt;= prefixStart.bitIndex)</span>
            {
<span class="nc" id="L1149">                return new SingletonIterator(prefixStart);</span>
            }
            else
            {
<span class="nc" id="L1153">                return new EntryIterator(prefixStart, delegate.prefix);</span>
            }
        }

        /**
         * An {@link Iterator} that holds a single {@link TrieEntry}.
         */
        private final class SingletonIterator implements Iterator&lt;Map.Entry&lt;K, V&gt;&gt;
        {
            private final TrieEntry&lt;K, V&gt; entry;

<span class="nc" id="L1164">            private int hit = 0;</span>

            public SingletonIterator(TrieEntry&lt;K, V&gt; entry)
<span class="nc" id="L1167">            {</span>
<span class="nc" id="L1168">                this.entry = entry;</span>
<span class="nc" id="L1169">            }</span>

            @Override
            public boolean hasNext()
            {
<span class="nc bnc" id="L1174" title="All 2 branches missed.">                return hit == 0;</span>
            }

            @Override
            public Map.Entry&lt;K, V&gt; next()
            {
<span class="nc bnc" id="L1180" title="All 2 branches missed.">                if (hit != 0)</span>
<span class="nc" id="L1181">                    throw new NoSuchElementException();</span>

<span class="nc" id="L1183">                ++hit;</span>
<span class="nc" id="L1184">                return entry;</span>
            }


            @Override
            public void remove()
            {
<span class="nc bnc" id="L1191" title="All 2 branches missed.">                if (hit != 1)</span>
<span class="nc" id="L1192">                    throw new IllegalStateException();</span>

<span class="nc" id="L1194">                ++hit;</span>
<span class="nc" id="L1195">                PatriciaTrie.this.removeEntry(entry);</span>
<span class="nc" id="L1196">            }</span>
        }

        /**
         * An {@link Iterator} for iterating over a prefix search.
         */
        private final class EntryIterator extends TrieIterator&lt;Map.Entry&lt;K, V&gt;&gt;
        {
            // values to reset the subtree if we remove it.
            protected final K prefix;
            protected boolean lastOne;

            protected TrieEntry&lt;K, V&gt; subtree; // the subtree to search within

            /**
             * Starts iteration at the given entry &amp; search only
             * within the given subtree.
             */
            EntryIterator(TrieEntry&lt;K, V&gt; startScan, K prefix)
<span class="nc" id="L1215">            {</span>
<span class="nc" id="L1216">                subtree = startScan;</span>
<span class="nc" id="L1217">                next = PatriciaTrie.this.followLeft(startScan);</span>
<span class="nc" id="L1218">                this.prefix = prefix;</span>
<span class="nc" id="L1219">            }</span>

            @Override
            public Map.Entry&lt;K,V&gt; next()
            {
<span class="nc" id="L1224">                Map.Entry&lt;K, V&gt; entry = nextEntry();</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">                if (lastOne)</span>
<span class="nc" id="L1226">                    next = null;</span>
<span class="nc" id="L1227">                return entry;</span>
            }

            @Override
            protected TrieEntry&lt;K, V&gt; findNext(TrieEntry&lt;K, V&gt; prior)
            {
<span class="nc" id="L1233">                return PatriciaTrie.this.nextEntryInSubtree(prior, subtree);</span>
            }

            @Override
            public void remove()
            {
                // If the current entry we're removing is the subtree
                // then we need to find a new subtree parent.
<span class="nc" id="L1241">                boolean needsFixing = false;</span>
<span class="nc" id="L1242">                int bitIdx = subtree.bitIndex;</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">                if (current == subtree)</span>
<span class="nc" id="L1244">                    needsFixing = true;</span>

<span class="nc" id="L1246">                super.remove();</span>

                // If the subtree changed its bitIndex or we
                // removed the old subtree, get a new one.
<span class="nc bnc" id="L1250" title="All 4 branches missed.">                if (bitIdx != subtree.bitIndex || needsFixing)</span>
<span class="nc" id="L1251">                    subtree = subtree(prefix);</span>

                // If the subtree's bitIndex is less than the
                // length of our prefix, it's the last item
                // in the prefix tree.
<span class="nc bnc" id="L1256" title="All 2 branches missed.">                if (lengthInBits(prefix) &gt;= subtree.bitIndex)</span>
<span class="nc" id="L1257">                    lastOne = true;</span>
<span class="nc" id="L1258">            }</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>