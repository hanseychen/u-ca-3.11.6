<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractPatriciaTrie.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sasi.utils.trie</a> &gt; <span class="el_source">AbstractPatriciaTrie.java</span></div><h1>AbstractPatriciaTrie.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2005-2010 Roger Kapsi, Sam Berlin
 *
 *   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

/**
 * This class is taken from https://github.com/rkapsi/patricia-trie (v0.6), and slightly modified
 * to correspond to Cassandra code style, as the only Patricia Trie implementation,
 * which supports pluggable key comparators (e.g. commons-collections PatriciaTrie (which is based
 * on rkapsi/patricia-trie project) only supports String keys)
 * but unfortunately is not deployed to the maven central as a downloadable artifact.
 */

package org.apache.cassandra.index.sasi.utils.trie;

import java.util.AbstractCollection;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.apache.cassandra.index.sasi.utils.trie.Cursor.Decision;

/**
 * This class implements the base PATRICIA algorithm and everything that
 * is related to the {@link Map} interface.
 */
abstract class AbstractPatriciaTrie&lt;K, V&gt; extends AbstractTrie&lt;K, V&gt;
{
    private static final long serialVersionUID = -2303909182832019043L;

    /**
     * The root node of the {@link Trie}.
     */
<span class="nc" id="L49">    final TrieEntry&lt;K, V&gt; root = new TrieEntry&lt;&gt;(null, null, -1);</span>

    /**
     * Each of these fields are initialized to contain an instance of the
     * appropriate view the first time this view is requested. The views are
     * stateless, so there's no reason to create more than one of each.
     */
    private transient volatile Set&lt;K&gt; keySet;
    private transient volatile Collection&lt;V&gt; values;
    private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

    /**
     * The current size of the {@link Trie}
     */
<span class="nc" id="L63">    private int size = 0;</span>

    /**
     * The number of times this {@link Trie} has been modified.
     * It's used to detect concurrent modifications and fail-fast
     * the {@link Iterator}s.
     */
<span class="nc" id="L70">    transient int modCount = 0;</span>

    public AbstractPatriciaTrie(KeyAnalyzer&lt;? super K&gt; keyAnalyzer)
    {
<span class="nc" id="L74">        super(keyAnalyzer);</span>
<span class="nc" id="L75">    }</span>

    public AbstractPatriciaTrie(KeyAnalyzer&lt;? super K&gt; keyAnalyzer, Map&lt;? extends K, ? extends V&gt; m)
    {
<span class="nc" id="L79">        super(keyAnalyzer);</span>
<span class="nc" id="L80">        putAll(m);</span>
<span class="nc" id="L81">    }</span>

    @Override
    public void clear()
    {
<span class="nc" id="L86">        root.key = null;</span>
<span class="nc" id="L87">        root.bitIndex = -1;</span>
<span class="nc" id="L88">        root.value = null;</span>

<span class="nc" id="L90">        root.parent = null;</span>
<span class="nc" id="L91">        root.left = root;</span>
<span class="nc" id="L92">        root.right = null;</span>
<span class="nc" id="L93">        root.predecessor = root;</span>

<span class="nc" id="L95">        size = 0;</span>
<span class="nc" id="L96">        incrementModCount();</span>
<span class="nc" id="L97">    }</span>

    @Override
    public int size()
    {
<span class="nc" id="L102">        return size;</span>
    }

    /**
     * A helper method to increment the {@link Trie} size
     * and the modification counter.
     */
    void incrementSize()
    {
<span class="nc" id="L111">        size++;</span>
<span class="nc" id="L112">        incrementModCount();</span>
<span class="nc" id="L113">    }</span>

    /**
     * A helper method to decrement the {@link Trie} size
     * and increment the modification counter.
     */
    void decrementSize()
    {
<span class="nc" id="L121">        size--;</span>
<span class="nc" id="L122">        incrementModCount();</span>
<span class="nc" id="L123">    }</span>

    /**
     * A helper method to increment the modification counter.
     */
    private void incrementModCount()
    {
<span class="nc" id="L130">        ++modCount;</span>
<span class="nc" id="L131">    }</span>

    @Override
    public V put(K key, V value)
    {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L137">            throw new NullPointerException(&quot;Key cannot be null&quot;);</span>

<span class="nc" id="L139">        int lengthInBits = lengthInBits(key);</span>

        // The only place to store a key with a length
        // of zero bits is the root node
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (lengthInBits == 0)</span>
        {
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (root.isEmpty())</span>
<span class="nc" id="L146">                incrementSize();</span>
            else
<span class="nc" id="L148">                incrementModCount();</span>

<span class="nc" id="L150">            return root.setKeyValue(key, value);</span>
        }

<span class="nc" id="L153">        TrieEntry&lt;K, V&gt; found = getNearestEntryForKey(key);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (compareKeys(key, found.key))</span>
        {
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (found.isEmpty()) // &lt;- must be the root</span>
<span class="nc" id="L157">                incrementSize();</span>
            else
<span class="nc" id="L159">                incrementModCount();</span>

<span class="nc" id="L161">            return found.setKeyValue(key, value);</span>
        }

<span class="nc" id="L164">        int bitIndex = bitIndex(key, found.key);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (!Tries.isOutOfBoundsIndex(bitIndex))</span>
        {
<span class="nc bnc" id="L167" title="All 2 branches missed.">            if (Tries.isValidBitIndex(bitIndex)) // in 99.999...9% the case</span>
            {
                /* NEW KEY+VALUE TUPLE */
<span class="nc" id="L170">                TrieEntry&lt;K, V&gt; t = new TrieEntry&lt;&gt;(key, value, bitIndex);</span>
<span class="nc" id="L171">                addEntry(t);</span>
<span class="nc" id="L172">                incrementSize();</span>
<span class="nc" id="L173">                return null;</span>
            }
<span class="nc bnc" id="L175" title="All 2 branches missed.">            else if (Tries.isNullBitKey(bitIndex))</span>
            {
                // A bits of the Key are zero. The only place to
                // store such a Key is the root Node!

                /* NULL BIT KEY */
<span class="nc bnc" id="L181" title="All 2 branches missed.">                if (root.isEmpty())</span>
<span class="nc" id="L182">                    incrementSize();</span>
                else
<span class="nc" id="L184">                    incrementModCount();</span>

<span class="nc" id="L186">                return root.setKeyValue(key, value);</span>

            }
<span class="nc bnc" id="L189" title="All 2 branches missed.">            else if (Tries.isEqualBitKey(bitIndex))</span>
            {
                // This is a very special and rare case.

                /* REPLACE OLD KEY+VALUE */
<span class="nc bnc" id="L194" title="All 2 branches missed.">                if (found != root)</span>
                {
<span class="nc" id="L196">                    incrementModCount();</span>
<span class="nc" id="L197">                    return found.setKeyValue(key, value);</span>
                }
            }
        }

<span class="nc" id="L202">        throw new IndexOutOfBoundsException(&quot;Failed to put: &quot;</span>
                + key + &quot; -&gt; &quot; + value + &quot;, &quot; + bitIndex);
    }

    /**
     * Adds the given {@link TrieEntry} to the {@link Trie}
     */
    TrieEntry&lt;K, V&gt; addEntry(TrieEntry&lt;K, V&gt; entry)
    {
<span class="nc" id="L211">        TrieEntry&lt;K, V&gt; current = root.left;</span>
<span class="nc" id="L212">        TrieEntry&lt;K, V&gt; path = root;</span>

        while(true)
        {
<span class="nc bnc" id="L216" title="All 4 branches missed.">            if (current.bitIndex &gt;= entry.bitIndex || current.bitIndex &lt;= path.bitIndex)</span>
            {
<span class="nc" id="L218">                entry.predecessor = entry;</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">                if (!isBitSet(entry.key, entry.bitIndex))</span>
                {
<span class="nc" id="L222">                    entry.left = entry;</span>
<span class="nc" id="L223">                    entry.right = current;</span>
                }
                else
                {
<span class="nc" id="L227">                    entry.left = current;</span>
<span class="nc" id="L228">                    entry.right = entry;</span>
                }

<span class="nc" id="L231">                entry.parent = path;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                if (current.bitIndex &gt;= entry.bitIndex)</span>
<span class="nc" id="L233">                    current.parent = entry;</span>

                // if we inserted an uplink, set the predecessor on it
<span class="nc bnc" id="L236" title="All 2 branches missed.">                if (current.bitIndex &lt;= path.bitIndex)</span>
<span class="nc" id="L237">                    current.predecessor = entry;</span>

<span class="nc bnc" id="L239" title="All 4 branches missed.">                if (path == root || !isBitSet(entry.key, path.bitIndex))</span>
<span class="nc" id="L240">                    path.left = entry;</span>
                else
<span class="nc" id="L242">                    path.right = entry;</span>

<span class="nc" id="L244">                return entry;</span>
            }

<span class="nc" id="L247">            path = current;</span>

<span class="nc bnc" id="L249" title="All 2 branches missed.">            current = !isBitSet(entry.key, current.bitIndex)</span>
                       ? current.left : current.right;
        }
    }

    @Override
    public V get(Object k)
    {
<span class="nc" id="L257">        TrieEntry&lt;K, V&gt; entry = getEntry(k);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        return entry != null ? entry.getValue() : null;</span>
    }

    /**
     * Returns the entry associated with the specified key in the
     * AbstractPatriciaTrie.  Returns null if the map contains no mapping
     * for this key.
     *
     * This may throw ClassCastException if the object is not of type K.
     */
    TrieEntry&lt;K,V&gt; getEntry(Object k)
    {
<span class="nc" id="L270">        K key = Tries.cast(k);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L272">            return null;</span>

<span class="nc" id="L274">        TrieEntry&lt;K,V&gt; entry = getNearestEntryForKey(key);</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">        return !entry.isEmpty() &amp;&amp; compareKeys(key, entry.key) ? entry : null;</span>
    }

    @Override
    public Map.Entry&lt;K, V&gt; select(K key)
    {
<span class="nc" id="L281">        Reference&lt;Map.Entry&lt;K, V&gt;&gt; reference = new Reference&lt;&gt;();</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        return !selectR(root.left, -1, key, reference) ? reference.get() : null;</span>
    }

    @Override
    public Map.Entry&lt;K,V&gt; select(K key, Cursor&lt;? super K, ? super V&gt; cursor)
    {
<span class="nc" id="L288">        Reference&lt;Map.Entry&lt;K, V&gt;&gt; reference = new Reference&lt;&gt;();</span>
<span class="nc" id="L289">        selectR(root.left, -1, key, cursor, reference);</span>
<span class="nc" id="L290">        return reference.get();</span>
    }

    /**
     * This is equivalent to the other {@link #selectR(TrieEntry, int,
     * K, Cursor, Reference)} method but without its overhead
     * because we're selecting only one best matching Entry from the
     * {@link Trie}.
     */
    private boolean selectR(TrieEntry&lt;K, V&gt; h, int bitIndex, final K key, final Reference&lt;Map.Entry&lt;K, V&gt;&gt; reference)
    {
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (h.bitIndex &lt;= bitIndex)</span>
        {
            // If we hit the root Node and it is empty
            // we have to look for an alternative best
            // matching node.
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (!h.isEmpty())</span>
            {
<span class="nc" id="L308">                reference.set(h);</span>
<span class="nc" id="L309">                return false;</span>
            }
<span class="nc" id="L311">            return true;</span>
        }

<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (!isBitSet(key, h.bitIndex))</span>
        {
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (selectR(h.left, h.bitIndex, key, reference))</span>
            {
<span class="nc" id="L318">                return selectR(h.right, h.bitIndex, key, reference);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (selectR(h.right, h.bitIndex, key, reference))</span>
            {
<span class="nc" id="L325">                return selectR(h.left, h.bitIndex, key, reference);</span>
            }
        }

<span class="nc" id="L329">        return false;</span>
    }

    /**
     *
     */
    private boolean selectR(TrieEntry&lt;K,V&gt; h, int bitIndex,
                            final K key, final Cursor&lt;? super K, ? super V&gt; cursor,
                            final Reference&lt;Map.Entry&lt;K, V&gt;&gt; reference)
    {
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (h.bitIndex &lt;= bitIndex)</span>
        {
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (!h.isEmpty())</span>
            {
<span class="nc" id="L343">                Decision decision = cursor.select(h);</span>
<span class="nc bnc" id="L344" title="All 4 branches missed.">                switch(decision)</span>
                {
                    case REMOVE:
<span class="nc" id="L347">                        throw new UnsupportedOperationException(&quot;Cannot remove during select&quot;);</span>

                    case EXIT:
<span class="nc" id="L350">                        reference.set(h);</span>
<span class="nc" id="L351">                        return false; // exit</span>

                    case REMOVE_AND_EXIT:
<span class="nc" id="L354">                        TrieEntry&lt;K, V&gt; entry = new TrieEntry&lt;&gt;(h.getKey(), h.getValue(), -1);</span>
<span class="nc" id="L355">                        reference.set(entry);</span>
<span class="nc" id="L356">                        removeEntry(h);</span>
<span class="nc" id="L357">                        return false;</span>

                    case CONTINUE:
                        // fall through.
                }
            }

<span class="nc" id="L364">            return true; // continue</span>
        }

<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (!isBitSet(key, h.bitIndex))</span>
        {
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (selectR(h.left, h.bitIndex, key, cursor, reference))</span>
            {
<span class="nc" id="L371">                return selectR(h.right, h.bitIndex, key, cursor, reference);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (selectR(h.right, h.bitIndex, key, cursor, reference))</span>
            {
<span class="nc" id="L378">                return selectR(h.left, h.bitIndex, key, cursor, reference);</span>
            }
        }

<span class="nc" id="L382">        return false;</span>
    }

    @Override
    public Map.Entry&lt;K, V&gt; traverse(Cursor&lt;? super K, ? super V&gt; cursor)
    {
<span class="nc" id="L388">        TrieEntry&lt;K, V&gt; entry = nextEntry(null);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        while (entry != null)</span>
        {
<span class="nc" id="L391">            TrieEntry&lt;K, V&gt; current = entry;</span>

<span class="nc" id="L393">            Decision decision = cursor.select(current);</span>
<span class="nc" id="L394">            entry = nextEntry(current);</span>

<span class="nc bnc" id="L396" title="All 4 branches missed.">            switch(decision)</span>
            {
                case EXIT:
<span class="nc" id="L399">                    return current;</span>

                case REMOVE:
<span class="nc" id="L402">                    removeEntry(current);</span>
<span class="nc" id="L403">                    break; // out of switch, stay in while loop</span>

                case REMOVE_AND_EXIT:
<span class="nc" id="L406">                    Map.Entry&lt;K, V&gt; value = new TrieEntry&lt;&gt;(current.getKey(), current.getValue(), -1);</span>
<span class="nc" id="L407">                    removeEntry(current);</span>
<span class="nc" id="L408">                    return value;</span>

                case CONTINUE: // do nothing.
            }
<span class="nc" id="L412">        }</span>

<span class="nc" id="L414">        return null;</span>
    }

    @Override
    public boolean containsKey(Object k)
    {
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (k == null)</span>
<span class="nc" id="L421">            return false;</span>

<span class="nc" id="L423">        K key = Tries.cast(k);</span>
<span class="nc" id="L424">        TrieEntry&lt;K, V&gt; entry = getNearestEntryForKey(key);</span>
<span class="nc bnc" id="L425" title="All 4 branches missed.">        return !entry.isEmpty() &amp;&amp; compareKeys(key, entry.key);</span>
    }

    @Override
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()
    {
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (entrySet == null)</span>
<span class="nc" id="L432">            entrySet = new EntrySet();</span>

<span class="nc" id="L434">        return entrySet;</span>
    }

    @Override
    public Set&lt;K&gt; keySet()
    {
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (keySet == null)</span>
<span class="nc" id="L441">            keySet = new KeySet();</span>
<span class="nc" id="L442">        return keySet;</span>
    }

    @Override
    public Collection&lt;V&gt; values()
    {
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (values == null)</span>
<span class="nc" id="L449">            values = new Values();</span>
<span class="nc" id="L450">        return values;</span>
    }

    /**
     * {@inheritDoc}
     *
     * @throws ClassCastException if provided key is of an incompatible type
     */
    @Override
    public V remove(Object k)
    {
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (k == null)</span>
<span class="nc" id="L462">            return null;</span>

<span class="nc" id="L464">        K key = Tries.cast(k);</span>
<span class="nc" id="L465">        TrieEntry&lt;K, V&gt; current = root.left;</span>
<span class="nc" id="L466">        TrieEntry&lt;K, V&gt; path = root;</span>
        while (true)
        {
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (current.bitIndex &lt;= path.bitIndex)</span>
            {
<span class="nc bnc" id="L471" title="All 4 branches missed.">                if (!current.isEmpty() &amp;&amp; compareKeys(key, current.key))</span>
                {
<span class="nc" id="L473">                    return removeEntry(current);</span>
                }
                else
                {
<span class="nc" id="L477">                    return null;</span>
                }
            }

<span class="nc" id="L481">            path = current;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            current = !isBitSet(key, current.bitIndex) ? current.left : current.right;</span>
        }
    }

    /**
     * Returns the nearest entry for a given key.  This is useful
     * for finding knowing if a given key exists (and finding the value
     * for it), or for inserting the key.
     *
     * The actual get implementation. This is very similar to
     * selectR but with the exception that it might return the
     * root Entry even if it's empty.
     */
    TrieEntry&lt;K, V&gt; getNearestEntryForKey(K key)
    {
<span class="nc" id="L497">        TrieEntry&lt;K, V&gt; current = root.left;</span>
<span class="nc" id="L498">        TrieEntry&lt;K, V&gt; path = root;</span>

        while(true)
        {
<span class="nc bnc" id="L502" title="All 2 branches missed.">            if (current.bitIndex &lt;= path.bitIndex)</span>
<span class="nc" id="L503">                return current;</span>

<span class="nc" id="L505">            path = current;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">            current = !isBitSet(key, current.bitIndex) ? current.left : current.right;</span>
        }
    }

    /**
     * Removes a single entry from the {@link Trie}.
     *
     * If we found a Key (Entry h) then figure out if it's
     * an internal (hard to remove) or external Entry (easy
     * to remove)
     */
    V removeEntry(TrieEntry&lt;K, V&gt; h)
    {
<span class="nc bnc" id="L519" title="All 2 branches missed.">        if (h != root)</span>
        {
<span class="nc bnc" id="L521" title="All 2 branches missed.">            if (h.isInternalNode())</span>
            {
<span class="nc" id="L523">                removeInternalEntry(h);</span>
            }
            else
            {
<span class="nc" id="L527">                removeExternalEntry(h);</span>
            }
        }

<span class="nc" id="L531">        decrementSize();</span>
<span class="nc" id="L532">        return h.setKeyValue(null, null);</span>
    }

    /**
     * Removes an external entry from the {@link Trie}.
     *
     * If it's an external Entry then just remove it.
     * This is very easy and straight forward.
     */
    private void removeExternalEntry(TrieEntry&lt;K, V&gt; h)
    {
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (h == root)</span>
        {
<span class="nc" id="L545">            throw new IllegalArgumentException(&quot;Cannot delete root Entry!&quot;);</span>
        }
<span class="nc bnc" id="L547" title="All 2 branches missed.">        else if (!h.isExternalNode())</span>
        {
<span class="nc" id="L549">            throw new IllegalArgumentException(h + &quot; is not an external Entry!&quot;);</span>
        }

<span class="nc" id="L552">        TrieEntry&lt;K, V&gt; parent = h.parent;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        TrieEntry&lt;K, V&gt; child = (h.left == h) ? h.right : h.left;</span>

<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (parent.left == h)</span>
        {
<span class="nc" id="L557">            parent.left = child;</span>
        }
        else
        {
<span class="nc" id="L561">            parent.right = child;</span>
        }

        // either the parent is changing, or the predecessor is changing.
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (child.bitIndex &gt; parent.bitIndex)</span>
        {
<span class="nc" id="L567">            child.parent = parent;</span>
        }
        else
        {
<span class="nc" id="L571">            child.predecessor = parent;</span>
        }

<span class="nc" id="L574">    }</span>

    /**
     * Removes an internal entry from the {@link Trie}.
     *
     * If it's an internal Entry then &quot;good luck&quot; with understanding
     * this code. The Idea is essentially that Entry p takes Entry h's
     * place in the trie which requires some re-wiring.
     */
    private void removeInternalEntry(TrieEntry&lt;K, V&gt; h)
    {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (h == root)</span>
        {
<span class="nc" id="L587">            throw new IllegalArgumentException(&quot;Cannot delete root Entry!&quot;);</span>
        }
<span class="nc bnc" id="L589" title="All 2 branches missed.">        else if (!h.isInternalNode())</span>
        {
<span class="nc" id="L591">            throw new IllegalArgumentException(h + &quot; is not an internal Entry!&quot;);</span>
        }

<span class="nc" id="L594">        TrieEntry&lt;K, V&gt; p = h.predecessor;</span>

        // Set P's bitIndex
<span class="nc" id="L597">        p.bitIndex = h.bitIndex;</span>

        // Fix P's parent, predecessor and child Nodes
        {
<span class="nc" id="L601">            TrieEntry&lt;K, V&gt; parent = p.parent;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            TrieEntry&lt;K, V&gt; child = (p.left == h) ? p.right : p.left;</span>

            // if it was looping to itself previously,
            // it will now be pointed from it's parent
            // (if we aren't removing it's parent --
            //  in that case, it remains looping to itself).
            // otherwise, it will continue to have the same
            // predecessor.
<span class="nc bnc" id="L610" title="All 4 branches missed.">            if (p.predecessor == p &amp;&amp; p.parent != h)</span>
<span class="nc" id="L611">                p.predecessor = p.parent;</span>

<span class="nc bnc" id="L613" title="All 2 branches missed.">            if (parent.left == p)</span>
            {
<span class="nc" id="L615">                parent.left = child;</span>
            }
            else
            {
<span class="nc" id="L619">                parent.right = child;</span>
            }

<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (child.bitIndex &gt; parent.bitIndex)</span>
            {
<span class="nc" id="L624">                child.parent = parent;</span>
            }
        }

        // Fix H's parent and child Nodes
        {
            // If H is a parent of its left and right child
            // then change them to P
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (h.left.parent == h)</span>
<span class="nc" id="L633">                h.left.parent = p;</span>

<span class="nc bnc" id="L635" title="All 2 branches missed.">            if (h.right.parent == h)</span>
<span class="nc" id="L636">                h.right.parent = p;</span>

            // Change H's parent
<span class="nc bnc" id="L639" title="All 2 branches missed.">            if (h.parent.left == h)</span>
            {
<span class="nc" id="L641">                h.parent.left = p;</span>
            }
            else
            {
<span class="nc" id="L645">                h.parent.right = p;</span>
            }
        }

        // Copy the remaining fields from H to P
        //p.bitIndex = h.bitIndex;
<span class="nc" id="L651">        p.parent = h.parent;</span>
<span class="nc" id="L652">        p.left = h.left;</span>
<span class="nc" id="L653">        p.right = h.right;</span>

        // Make sure that if h was pointing to any uplinks,
        // p now points to them.
<span class="nc bnc" id="L657" title="All 2 branches missed.">        if (isValidUplink(p.left, p))</span>
<span class="nc" id="L658">            p.left.predecessor = p;</span>

<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (isValidUplink(p.right, p))</span>
<span class="nc" id="L661">            p.right.predecessor = p;</span>
<span class="nc" id="L662">    }</span>

    /**
     * Returns the entry lexicographically after the given entry.
     * If the given entry is null, returns the first node.
     */
    TrieEntry&lt;K, V&gt; nextEntry(TrieEntry&lt;K, V&gt; node)
    {
<span class="nc bnc" id="L670" title="All 2 branches missed.">        return (node == null) ? firstEntry() : nextEntryImpl(node.predecessor, node, null);</span>
    }

    /**
     * Scans for the next node, starting at the specified point, and using 'previous'
     * as a hint that the last node we returned was 'previous' (so we know not to return
     * it again).  If 'tree' is non-null, this will limit the search to the given tree.
     *
     * The basic premise is that each iteration can follow the following steps:
     *
     * 1) Scan all the way to the left.
     *   a) If we already started from this node last time, proceed to Step 2.
     *   b) If a valid uplink is found, use it.
     *   c) If the result is an empty node (root not set), break the scan.
     *   d) If we already returned the left node, break the scan.
     *
     * 2) Check the right.
     *   a) If we already returned the right node, proceed to Step 3.
     *   b) If it is a valid uplink, use it.
     *   c) Do Step 1 from the right node.
     *
     * 3) Back up through the parents until we encounter find a parent
     *    that we're not the right child of.
     *
     * 4) If there's no right child of that parent, the iteration is finished.
     *    Otherwise continue to Step 5.
     *
     * 5) Check to see if the right child is a valid uplink.
     *    a) If we already returned that child, proceed to Step 6.
     *       Otherwise, use it.
     *
     * 6) If the right child of the parent is the parent itself, we've
     *    already found &amp; returned the end of the Trie, so exit.
     *
     * 7) Do Step 1 on the parent's right child.
     */
    TrieEntry&lt;K, V&gt; nextEntryImpl(TrieEntry&lt;K, V&gt; start, TrieEntry&lt;K, V&gt; previous, TrieEntry&lt;K, V&gt; tree)
    {
<span class="nc" id="L708">        TrieEntry&lt;K, V&gt; current = start;</span>

        // Only look at the left if this was a recursive or
        // the first check, otherwise we know we've already looked
        // at the left.
<span class="nc bnc" id="L713" title="All 4 branches missed.">        if (previous == null || start != previous.predecessor)</span>
        {
<span class="nc bnc" id="L715" title="All 2 branches missed.">            while (!current.left.isEmpty())</span>
            {
                // stop traversing if we've already
                // returned the left of this node.
<span class="nc bnc" id="L719" title="All 2 branches missed.">                if (previous == current.left)</span>
<span class="nc" id="L720">                    break;</span>

<span class="nc bnc" id="L722" title="All 2 branches missed.">                if (isValidUplink(current.left, current))</span>
<span class="nc" id="L723">                    return current.left;</span>

<span class="nc" id="L725">                current = current.left;</span>
            }
        }

        // If there's no data at all, exit.
<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (current.isEmpty())</span>
<span class="nc" id="L731">            return null;</span>

        // If we've already returned the left,
        // and the immediate right is null,
        // there's only one entry in the Trie
        // which is stored at the root.
        //
        //  / (&quot;&quot;)   &lt;-- root
        //  \_/  \
        //       null &lt;-- 'current'
        //
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (current.right == null)</span>
<span class="nc" id="L743">            return null;</span>

        // If nothing valid on the left, try the right.
<span class="nc bnc" id="L746" title="All 2 branches missed.">        if (previous != current.right)</span>
        {
            // See if it immediately is valid.
<span class="nc bnc" id="L749" title="All 2 branches missed.">            if (isValidUplink(current.right, current))</span>
<span class="nc" id="L750">                return current.right;</span>

            // Must search on the right's side if it wasn't initially valid.
<span class="nc" id="L753">            return nextEntryImpl(current.right, previous, tree);</span>
        }

        // Neither left nor right are valid, find the first parent
        // whose child did not come from the right &amp; traverse it.
<span class="nc bnc" id="L758" title="All 2 branches missed.">        while (current == current.parent.right)</span>
        {
            // If we're going to traverse to above the subtree, stop.
<span class="nc bnc" id="L761" title="All 2 branches missed.">            if (current == tree)</span>
<span class="nc" id="L762">                return null;</span>

<span class="nc" id="L764">            current = current.parent;</span>
        }

        // If we're on the top of the subtree, we can't go any higher.
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (current == tree)</span>
<span class="nc" id="L769">            return null;</span>

        // If there's no right, the parent must be root, so we're done.
<span class="nc bnc" id="L772" title="All 2 branches missed.">        if (current.parent.right == null)</span>
<span class="nc" id="L773">            return null;</span>

        // If the parent's right points to itself, we've found one.
<span class="nc bnc" id="L776" title="All 4 branches missed.">        if (previous != current.parent.right &amp;&amp; isValidUplink(current.parent.right, current.parent))</span>
<span class="nc" id="L777">            return current.parent.right;</span>

        // If the parent's right is itself, there can't be any more nodes.
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if (current.parent.right == current.parent)</span>
<span class="nc" id="L781">            return null;</span>

        // We need to traverse down the parent's right's path.
<span class="nc" id="L784">        return nextEntryImpl(current.parent.right, previous, tree);</span>
    }

    /**
     * Returns the first entry the {@link Trie} is storing.
     *
     * This is implemented by going always to the left until
     * we encounter a valid uplink. That uplink is the first key.
     */
    TrieEntry&lt;K, V&gt; firstEntry()
    {
        // if Trie is empty, no first node.
<span class="nc bnc" id="L796" title="All 2 branches missed.">        return isEmpty() ? null : followLeft(root);</span>
    }

    /**
     * Goes left through the tree until it finds a valid node.
     */
    TrieEntry&lt;K, V&gt; followLeft(TrieEntry&lt;K, V&gt; node)
    {
        while(true)
        {
<span class="nc" id="L806">            TrieEntry&lt;K, V&gt; child = node.left;</span>
            // if we hit root and it didn't have a node, go right instead.
<span class="nc bnc" id="L808" title="All 2 branches missed.">            if (child.isEmpty())</span>
<span class="nc" id="L809">                child = node.right;</span>

<span class="nc bnc" id="L811" title="All 2 branches missed.">            if (child.bitIndex &lt;= node.bitIndex)</span>
<span class="nc" id="L812">                return child;</span>

<span class="nc" id="L814">            node = child;</span>
<span class="nc" id="L815">        }</span>
    }

    /**
     * Returns true if 'next' is a valid uplink coming from 'from'.
     */
    static boolean isValidUplink(TrieEntry&lt;?, ?&gt; next, TrieEntry&lt;?, ?&gt; from)
    {
<span class="nc bnc" id="L823" title="All 6 branches missed.">        return next != null &amp;&amp; next.bitIndex &lt;= from.bitIndex &amp;&amp; !next.isEmpty();</span>
    }

    /**
     * A {@link Reference} allows us to return something through a Method's
     * argument list. An alternative would be to an Array with a length of
     * one (1) but that leads to compiler warnings. Computationally and memory
     * wise there's no difference (except for the need to load the
     * {@link Reference} Class but that happens only once).
     */
    private static class Reference&lt;E&gt;
    {

        private E item;

        public void set(E item)
        {
<span class="nc" id="L840">            this.item = item;</span>
<span class="nc" id="L841">        }</span>

        public E get()
        {
<span class="nc" id="L845">            return item;</span>
        }
    }

    /**
     *  A {@link Trie} is a set of {@link TrieEntry} nodes
     */
    static class TrieEntry&lt;K,V&gt; extends BasicEntry&lt;K, V&gt;
    {

        private static final long serialVersionUID = 4596023148184140013L;

        /** The index this entry is comparing. */
        protected int bitIndex;

        /** The parent of this entry. */
        protected TrieEntry&lt;K,V&gt; parent;

        /** The left child of this entry. */
        protected TrieEntry&lt;K,V&gt; left;

        /** The right child of this entry. */
        protected TrieEntry&lt;K,V&gt; right;

        /** The entry who uplinks to this entry. */
        protected TrieEntry&lt;K,V&gt; predecessor;

        public TrieEntry(K key, V value, int bitIndex)
        {
<span class="nc" id="L874">            super(key, value);</span>

<span class="nc" id="L876">            this.bitIndex = bitIndex;</span>

<span class="nc" id="L878">            this.parent = null;</span>
<span class="nc" id="L879">            this.left = this;</span>
<span class="nc" id="L880">            this.right = null;</span>
<span class="nc" id="L881">            this.predecessor = this;</span>
<span class="nc" id="L882">        }</span>

        /**
         * Whether or not the entry is storing a key.
         * Only the root can potentially be empty, all other
         * nodes must have a key.
         */
        public boolean isEmpty()
        {
<span class="nc bnc" id="L891" title="All 2 branches missed.">            return key == null;</span>
        }

        /**
         * Neither the left nor right child is a loopback
         */
        public boolean isInternalNode()
        {
<span class="nc bnc" id="L899" title="All 4 branches missed.">            return left != this &amp;&amp; right != this;</span>
        }

        /**
         * Either the left or right child is a loopback
         */
        public boolean isExternalNode()
        {
<span class="nc bnc" id="L907" title="All 2 branches missed.">            return !isInternalNode();</span>
        }
    }


    /**
     * This is a entry set view of the {@link Trie} as returned
     * by {@link Map#entrySet()}
     */
<span class="nc" id="L916">    private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt;</span>
    {
        @Override
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator()
        {
<span class="nc" id="L921">            return new EntryIterator();</span>
        }

        @Override
        public boolean contains(Object o)
        {
<span class="nc bnc" id="L927" title="All 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L928">                return false;</span>

<span class="nc" id="L930">            TrieEntry&lt;K,V&gt; candidate = getEntry(((Map.Entry&lt;?, ?&gt;)o).getKey());</span>
<span class="nc bnc" id="L931" title="All 4 branches missed.">            return candidate != null &amp;&amp; candidate.equals(o);</span>
        }

        @Override
        public boolean remove(Object o)
        {
<span class="nc" id="L937">            int size = size();</span>
<span class="nc" id="L938">            AbstractPatriciaTrie.this.remove(o);</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">            return size != size();</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L945">            return AbstractPatriciaTrie.this.size();</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L951">            AbstractPatriciaTrie.this.clear();</span>
<span class="nc" id="L952">        }</span>

        /**
         * An {@link Iterator} that returns {@link Entry} Objects
         */
<span class="nc" id="L957">        private class EntryIterator extends TrieIterator&lt;Map.Entry&lt;K,V&gt;&gt;</span>
        {
            @Override
            public Map.Entry&lt;K,V&gt; next()
            {
<span class="nc" id="L962">                return nextEntry();</span>
            }
        }
    }

    /**
     * This is a key set view of the {@link Trie} as returned
     * by {@link Map#keySet()}
     */
<span class="nc" id="L971">    private class KeySet extends AbstractSet&lt;K&gt;</span>
    {
        @Override
        public Iterator&lt;K&gt; iterator()
        {
<span class="nc" id="L976">            return new KeyIterator();</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L982">            return AbstractPatriciaTrie.this.size();</span>
        }

        @Override
        public boolean contains(Object o)
        {
<span class="nc" id="L988">            return containsKey(o);</span>
        }

        @Override
        public boolean remove(Object o)
        {
<span class="nc" id="L994">            int size = size();</span>
<span class="nc" id="L995">            AbstractPatriciaTrie.this.remove(o);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">            return size != size();</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L1002">            AbstractPatriciaTrie.this.clear();</span>
<span class="nc" id="L1003">        }</span>

        /**
         * An {@link Iterator} that returns Key Objects
         */
<span class="nc" id="L1008">        private class KeyIterator extends TrieIterator&lt;K&gt;</span>
        {
            @Override
            public K next()
            {
<span class="nc" id="L1013">                return nextEntry().getKey();</span>
            }
        }
    }

    /**
     * This is a value view of the {@link Trie} as returned
     * by {@link Map#values()}
     */
<span class="nc" id="L1022">    private class Values extends AbstractCollection&lt;V&gt;</span>
    {
        @Override
        public Iterator&lt;V&gt; iterator()
        {
<span class="nc" id="L1027">            return new ValueIterator();</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L1033">            return AbstractPatriciaTrie.this.size();</span>
        }

        @Override
        public boolean contains(Object o)
        {
<span class="nc" id="L1039">            return containsValue(o);</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L1045">            AbstractPatriciaTrie.this.clear();</span>
<span class="nc" id="L1046">        }</span>

        @Override
        public boolean remove(Object o)
        {
<span class="nc bnc" id="L1051" title="All 2 branches missed.">            for (Iterator&lt;V&gt; it = iterator(); it.hasNext(); )</span>
            {
<span class="nc" id="L1053">                V value = it.next();</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                if (Tries.areEqual(value, o))</span>
                {
<span class="nc" id="L1056">                    it.remove();</span>
<span class="nc" id="L1057">                    return true;</span>
                }
<span class="nc" id="L1059">            }</span>
<span class="nc" id="L1060">            return false;</span>
        }

        /**
         * An {@link Iterator} that returns Value Objects
         */
<span class="nc" id="L1066">        private class ValueIterator extends TrieIterator&lt;V&gt;</span>
        {
            @Override
            public V next()
            {
<span class="nc" id="L1071">                return nextEntry().getValue();</span>
            }
        }
    }

    /**
     * An iterator for the entries.
     */
    abstract class TrieIterator&lt;E&gt; implements Iterator&lt;E&gt;
    {
        /**
         * For fast-fail
         */
<span class="nc" id="L1084">        protected int expectedModCount = AbstractPatriciaTrie.this.modCount;</span>

        protected TrieEntry&lt;K, V&gt; next; // the next node to return
        protected TrieEntry&lt;K, V&gt; current; // the current entry we're on

        /**
         * Starts iteration from the root
         */
        protected TrieIterator()
<span class="nc" id="L1093">        {</span>
<span class="nc" id="L1094">            next = AbstractPatriciaTrie.this.nextEntry(null);</span>
<span class="nc" id="L1095">        }</span>

        /**
         * Starts iteration at the given entry
         */
        protected TrieIterator(TrieEntry&lt;K, V&gt; firstEntry)
<span class="nc" id="L1101">        {</span>
<span class="nc" id="L1102">            next = firstEntry;</span>
<span class="nc" id="L1103">        }</span>

        /**
         * Returns the next {@link TrieEntry}
         */
        protected TrieEntry&lt;K,V&gt; nextEntry()
        {
<span class="nc bnc" id="L1110" title="All 2 branches missed.">            if (expectedModCount != AbstractPatriciaTrie.this.modCount)</span>
<span class="nc" id="L1111">                throw new ConcurrentModificationException();</span>

<span class="nc" id="L1113">            TrieEntry&lt;K,V&gt; e = next;</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">            if (e == null)</span>
<span class="nc" id="L1115">                throw new NoSuchElementException();</span>

<span class="nc" id="L1117">            next = findNext(e);</span>
<span class="nc" id="L1118">            current = e;</span>
<span class="nc" id="L1119">            return e;</span>
        }

        /**
         * @see PatriciaTrie#nextEntry(TrieEntry)
         */
        protected TrieEntry&lt;K, V&gt; findNext(TrieEntry&lt;K, V&gt; prior)
        {
<span class="nc" id="L1127">            return AbstractPatriciaTrie.this.nextEntry(prior);</span>
        }

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L1133" title="All 2 branches missed.">            return next != null;</span>
        }

        @Override
        public void remove()
        {
<span class="nc bnc" id="L1139" title="All 2 branches missed.">            if (current == null)</span>
<span class="nc" id="L1140">                throw new IllegalStateException();</span>

<span class="nc bnc" id="L1142" title="All 2 branches missed.">            if (expectedModCount != AbstractPatriciaTrie.this.modCount)</span>
<span class="nc" id="L1143">                throw new ConcurrentModificationException();</span>

<span class="nc" id="L1145">            TrieEntry&lt;K, V&gt; node = current;</span>
<span class="nc" id="L1146">            current = null;</span>
<span class="nc" id="L1147">            AbstractPatriciaTrie.this.removeEntry(node);</span>

<span class="nc" id="L1149">            expectedModCount = AbstractPatriciaTrie.this.modCount;</span>
<span class="nc" id="L1150">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>