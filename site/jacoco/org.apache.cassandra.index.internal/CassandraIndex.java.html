<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CassandraIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.internal</a> &gt; <span class="el_source">CassandraIndex.java</span></div><h1>CassandraIndex.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.cassandra.index.internal;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.function.BiFunction;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import com.google.common.collect.ImmutableSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.ColumnDefinition;
import org.apache.cassandra.cql3.Operator;
import org.apache.cassandra.cql3.statements.IndexTarget;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.compaction.CompactionManager;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.db.lifecycle.SSTableSet;
import org.apache.cassandra.db.lifecycle.View;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.CollectionType;
import org.apache.cassandra.db.marshal.EmptyType;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.dht.LocalPartitioner;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.index.*;
import org.apache.cassandra.index.internal.composites.CompositesSearcher;
import org.apache.cassandra.index.internal.keys.KeysSearcher;
import org.apache.cassandra.index.transactions.IndexTransaction;
import org.apache.cassandra.index.transactions.UpdateTransaction;
import org.apache.cassandra.io.sstable.ReducingKeyIterator;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.schema.IndexMetadata;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.concurrent.OpOrder;
import org.apache.cassandra.utils.concurrent.Refs;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;

/**
 * Index implementation which indexes the values for a single column in the base
 * table and which stores its index data in a local, hidden table.
 */
<span class="nc bnc" id="L72" title="All 2 branches missed.">public abstract class CassandraIndex implements Index</span>
{
<span class="nc" id="L74">    private static final Logger logger = LoggerFactory.getLogger(CassandraIndex.class);</span>

    public final ColumnFamilyStore baseCfs;
    protected IndexMetadata metadata;
    protected ColumnFamilyStore indexCfs;
    protected ColumnDefinition indexedColumn;
    protected CassandraIndexFunctions functions;

    protected CassandraIndex(ColumnFamilyStore baseCfs, IndexMetadata indexDef)
<span class="nc" id="L83">    {</span>
<span class="nc" id="L84">        this.baseCfs = baseCfs;</span>
<span class="nc" id="L85">        setMetadata(indexDef);</span>
<span class="nc" id="L86">    }</span>

    /**
     * Returns true if an index of this type can support search predicates of the form [column] OPERATOR [value]
     * @param indexedColumn
     * @param operator
     * @return
     */
    protected boolean supportsOperator(ColumnDefinition indexedColumn, Operator operator)
    {
<span class="nc bnc" id="L96" title="All 2 branches missed.">        return operator == Operator.EQ;</span>
    }

    /**
     * Used to construct an the clustering for an entry in the index table based on values from the base data.
     * The clustering columns in the index table encode the values required to retrieve the correct data from the base
     * table and varies depending on the kind of the indexed column. See indexCfsMetadata for more details
     * Used whenever a row in the index table is written or deleted.
     * @param partitionKey from the base data being indexed
     * @param prefix from the base data being indexed
     * @param path from the base data being indexed
     * @return a clustering prefix to be used to insert into the index table
     */
    protected abstract CBuilder buildIndexClusteringPrefix(ByteBuffer partitionKey,
                                                           ClusteringPrefix prefix,
                                                           CellPath path);

    /**
     * Used at search time to convert a row in the index table into a simple struct containing the values required
     * to retrieve the corresponding row from the base table.
     * @param indexedValue the partition key of the indexed table (i.e. the value that was indexed)
     * @param indexEntry a row from the index table
     * @return
     */
    public abstract IndexEntry decodeEntry(DecoratedKey indexedValue,
                                           Row indexEntry);

    /**
     * Check whether a value retrieved from an index is still valid by comparing it to current row from the base table.
     * Used at read time to identify out of date index entries so that they can be excluded from search results and
     * repaired
     * @param row the current row from the primary data table
     * @param indexValue the value we retrieved from the index
     * @param nowInSec
     * @return true if the index is out of date and the entry should be dropped
     */
    public abstract boolean isStale(Row row, ByteBuffer indexValue, int nowInSec);

    /**
     * Extract the value to be inserted into the index from the components of the base data
     * @param partitionKey from the primary data
     * @param clustering from the primary data
     * @param path from the primary data
     * @param cellValue from the primary data
     * @return a ByteBuffer containing the value to be inserted in the index. This will be used to make the partition
     * key in the index table
     */
    protected abstract ByteBuffer getIndexedValue(ByteBuffer partitionKey,
                                                  Clustering clustering,
                                                  CellPath path,
                                                  ByteBuffer cellValue);

    public ColumnDefinition getIndexedColumn()
    {
<span class="nc" id="L150">        return indexedColumn;</span>
    }

    public ClusteringComparator getIndexComparator()
    {
<span class="nc" id="L155">        return indexCfs.metadata.comparator;</span>
    }

    public ColumnFamilyStore getIndexCfs()
    {
<span class="nc" id="L160">        return indexCfs;</span>
    }

    public void register(IndexRegistry registry)
    {
<span class="nc" id="L165">        registry.registerIndex(this);</span>
<span class="nc" id="L166">    }</span>

    public Callable&lt;?&gt; getInitializationTask()
    {
        // if we're just linking in the index on an already-built index post-restart or if the base
        // table is empty we've nothing to do. Otherwise, submit for building via SecondaryIndexBuilder
<span class="nc bnc" id="L172" title="All 4 branches missed.">        return isBuilt() || baseCfs.isEmpty() ? null : getBuildIndexTask();</span>
    }

    public IndexMetadata getIndexMetadata()
    {
<span class="nc" id="L177">        return metadata;</span>
    }

    public Optional&lt;ColumnFamilyStore&gt; getBackingTable()
    {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        return indexCfs == null ? Optional.empty() : Optional.of(indexCfs);</span>
    }

    public Callable&lt;Void&gt; getBlockingFlushTask()
    {
<span class="nc" id="L187">        return () -&gt; {</span>
<span class="nc" id="L188">            indexCfs.forceBlockingFlush();</span>
<span class="nc" id="L189">            return null;</span>
        };
    }

    public Callable&lt;?&gt; getInvalidateTask()
    {
<span class="nc" id="L195">        return () -&gt; {</span>
<span class="nc" id="L196">            invalidate();</span>
<span class="nc" id="L197">            return null;</span>
        };
    }

    public Callable&lt;?&gt; getMetadataReloadTask(IndexMetadata indexDef)
    {
<span class="nc" id="L203">        return () -&gt; {</span>
<span class="nc" id="L204">            indexCfs.metadata.reloadIndexMetadataProperties(baseCfs.metadata);</span>
<span class="nc" id="L205">            indexCfs.reload();</span>
<span class="nc" id="L206">            return null;</span>
        };
    }

    @Override
    public void validate(ReadCommand command) throws InvalidRequestException
    {
<span class="nc" id="L213">        Optional&lt;RowFilter.Expression&gt; target = getTargetExpression(command.rowFilter().getExpressions());</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (target.isPresent())</span>
        {
<span class="nc" id="L217">            ByteBuffer indexValue = target.get().getIndexValue();</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            checkFalse(indexValue.remaining() &gt; FBUtilities.MAX_UNSIGNED_SHORT,</span>
                       &quot;Index expression values may not be larger than 64K&quot;);
        }
<span class="nc" id="L221">    }</span>

    private void setMetadata(IndexMetadata indexDef)
    {
<span class="nc" id="L225">        metadata = indexDef;</span>
<span class="nc" id="L226">        Pair&lt;ColumnDefinition, IndexTarget.Type&gt; target = TargetParser.parse(baseCfs.metadata, indexDef);</span>
<span class="nc" id="L227">        functions = getFunctions(indexDef, target);</span>
<span class="nc" id="L228">        CFMetaData cfm = indexCfsMetadata(baseCfs.metadata, indexDef);</span>
<span class="nc" id="L229">        indexCfs = ColumnFamilyStore.createColumnFamilyStore(baseCfs.keyspace,</span>
                                                             cfm.cfName,
                                                             cfm,
<span class="nc" id="L232">                                                             baseCfs.getTracker().loadsstables);</span>
<span class="nc" id="L233">        indexedColumn = target.left;</span>
<span class="nc" id="L234">    }</span>

    public Callable&lt;?&gt; getTruncateTask(final long truncatedAt)
    {
<span class="nc" id="L238">        return () -&gt; {</span>
<span class="nc" id="L239">            indexCfs.discardSSTables(truncatedAt);</span>
<span class="nc" id="L240">            return null;</span>
        };
    }

    public boolean shouldBuildBlocking()
    {
        // built-in indexes are always included in builds initiated from SecondaryIndexManager
<span class="nc" id="L247">        return true;</span>
    }

    public boolean dependsOn(ColumnDefinition column)
    {
<span class="nc" id="L252">        return indexedColumn.name.equals(column.name);</span>
    }

    public boolean supportsExpression(ColumnDefinition column, Operator operator)
    {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        return indexedColumn.name.equals(column.name)</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">               &amp;&amp; supportsOperator(indexedColumn, operator);</span>
    }

    private boolean supportsExpression(RowFilter.Expression expression)
    {
<span class="nc" id="L263">        return supportsExpression(expression.column(), expression.operator());</span>
    }

    public AbstractType&lt;?&gt; customExpressionValueType()
    {
<span class="nc" id="L268">        return null;</span>
    }

    public long getEstimatedResultRows()
    {
<span class="nc" id="L273">        long totalRows = 0;</span>
<span class="nc" id="L274">        long totalPartitions = 0;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        for (SSTableReader sstable : indexCfs.getSSTables(SSTableSet.CANONICAL))</span>
        {
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (sstable.descriptor.version.storeRows())</span>
            {
<span class="nc" id="L279">                totalPartitions += sstable.getEstimatedPartitionSize().count();</span>
<span class="nc" id="L280">                totalRows += sstable.getTotalRows();</span>
            } else
            {
                // for legacy sstables we don't have a total row count so we approximate it
                // using estimated column count (which is the same logic as pre-3.0
                // see CASSANDRA-15259
<span class="nc" id="L286">                long colCount = sstable.getEstimatedColumnCount().count();</span>
<span class="nc" id="L287">                totalPartitions += colCount;</span>
<span class="nc" id="L288">                totalRows += sstable.getEstimatedColumnCount().mean() * colCount;</span>
            }
<span class="nc" id="L290">        }</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">        return totalPartitions &gt; 0 ? (int) (totalRows / totalPartitions) : 0;</span>
    }

    /**
     * No post processing of query results, just return them unchanged
     */
    public BiFunction&lt;PartitionIterator, ReadCommand, PartitionIterator&gt; postProcessorFor(ReadCommand command)
    {
<span class="nc" id="L300">        return (partitionIterator, readCommand) -&gt; partitionIterator;</span>
    }

    public RowFilter getPostIndexQueryFilter(RowFilter filter)
    {
<span class="nc" id="L305">        return getTargetExpression(filter.getExpressions()).map(filter::without)</span>
<span class="nc" id="L306">                                                           .orElse(filter);</span>
    }

    private Optional&lt;RowFilter.Expression&gt; getTargetExpression(List&lt;RowFilter.Expression&gt; expressions)
    {
<span class="nc" id="L311">        return expressions.stream().filter(this::supportsExpression).findFirst();</span>
    }

    public Index.Searcher searcherFor(ReadCommand command)
    {
<span class="nc" id="L316">        Optional&lt;RowFilter.Expression&gt; target = getTargetExpression(command.rowFilter().getExpressions());</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (target.isPresent())</span>
        {
<span class="nc bnc" id="L320" title="All 3 branches missed.">            switch (getIndexMetadata().kind)</span>
            {
                case COMPOSITES:
<span class="nc" id="L323">                    return new CompositesSearcher(command, target.get(), this);</span>
                case KEYS:
<span class="nc" id="L325">                    return new KeysSearcher(command, target.get(), this);</span>
                default:
<span class="nc" id="L327">                    throw new IllegalStateException(String.format(&quot;Unsupported index type %s for index %s on %s&quot;,</span>
                                                                  metadata.kind,
                                                                  metadata.name,
<span class="nc" id="L330">                                                                  indexedColumn.name.toString()));</span>
            }
        }

<span class="nc" id="L334">        return null;</span>

    }

    public void validate(PartitionUpdate update) throws InvalidRequestException
    {
<span class="nc bnc" id="L340" title="All 5 branches missed.">        switch (indexedColumn.kind)</span>
        {
            case PARTITION_KEY:
<span class="nc" id="L343">                validatePartitionKey(update.partitionKey());</span>
<span class="nc" id="L344">                break;</span>
            case CLUSTERING:
<span class="nc" id="L346">                validateClusterings(update);</span>
<span class="nc" id="L347">                break;</span>
            case REGULAR:
<span class="nc bnc" id="L349" title="All 2 branches missed.">                if (update.columns().regulars.contains(indexedColumn))</span>
<span class="nc" id="L350">                    validateRows(update);</span>
                break;
            case STATIC:
<span class="nc bnc" id="L353" title="All 2 branches missed.">                if (update.columns().statics.contains(indexedColumn))</span>
<span class="nc" id="L354">                    validateRows(Collections.singleton(update.staticRow()));</span>
                break;
        }
<span class="nc" id="L357">    }</span>

    public Indexer indexerFor(final DecoratedKey key,
                              final PartitionColumns columns,
                              final int nowInSec,
                              final OpOrder.Group opGroup,
                              final IndexTransaction.Type transactionType)
    {
        /**
         * Indexes on regular and static columns (the non primary-key ones) only care about updates with live
         * data for the column they index. In particular, they don't care about having just row or range deletions
         * as they don't know how to update the index table unless they know exactly the value that is deleted.
         *
         * Note that in practice this means that those indexes are only purged of stale entries on compaction,
         * when we resolve both the deletion and the prior data it deletes. Of course, such stale entries are also
         * filtered on read.
         */
<span class="nc bnc" id="L374" title="All 4 branches missed.">        if (!isPrimaryKeyIndex() &amp;&amp; !columns.contains(indexedColumn))</span>
<span class="nc" id="L375">            return null;</span>

<span class="nc" id="L377">        return new Indexer()</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        {</span>
            public void begin()
            {
<span class="nc" id="L381">            }</span>

            public void partitionDelete(DeletionTime deletionTime)
            {
<span class="nc" id="L385">            }</span>

            public void rangeTombstone(RangeTombstone tombstone)
            {
<span class="nc" id="L389">            }</span>

            public void insertRow(Row row)
            {
<span class="nc bnc" id="L393" title="All 6 branches missed.">                if (row.isStatic() &amp;&amp; !indexedColumn.isStatic() &amp;&amp; !indexedColumn.isPartitionKey())</span>
<span class="nc" id="L394">                    return;</span>

<span class="nc bnc" id="L396" title="All 2 branches missed.">                if (isPrimaryKeyIndex())</span>
                {
<span class="nc" id="L398">                    indexPrimaryKey(row.clustering(),</span>
<span class="nc" id="L399">                                    getPrimaryKeyIndexLiveness(row),</span>
<span class="nc" id="L400">                                    row.deletion());</span>
                }
                else
                {
<span class="nc bnc" id="L404" title="All 2 branches missed.">                    if (indexedColumn.isComplex())</span>
<span class="nc" id="L405">                        indexCells(row.clustering(), row.getComplexColumnData(indexedColumn));</span>
                    else
<span class="nc" id="L407">                        indexCell(row.clustering(), row.getCell(indexedColumn));</span>
                }
<span class="nc" id="L409">            }</span>

            public void removeRow(Row row)
            {
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if (isPrimaryKeyIndex())</span>
<span class="nc" id="L414">                    return;</span>

<span class="nc bnc" id="L416" title="All 2 branches missed.">                if (indexedColumn.isComplex())</span>
<span class="nc" id="L417">                    removeCells(row.clustering(), row.getComplexColumnData(indexedColumn));</span>
                else
<span class="nc" id="L419">                    removeCell(row.clustering(), row.getCell(indexedColumn));</span>
<span class="nc" id="L420">            }</span>

            public void updateRow(Row oldRow, Row newRow)
            {
<span class="nc bnc" id="L424" title="All 4 branches missed.">                assert oldRow.isStatic() == newRow.isStatic();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                if (newRow.isStatic() != indexedColumn.isStatic())</span>
<span class="nc" id="L426">                    return;</span>

<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (isPrimaryKeyIndex())</span>
<span class="nc" id="L429">                    indexPrimaryKey(newRow.clustering(),</span>
<span class="nc" id="L430">                                    newRow.primaryKeyLivenessInfo(),</span>
<span class="nc" id="L431">                                    newRow.deletion());</span>

<span class="nc bnc" id="L433" title="All 2 branches missed.">                if (indexedColumn.isComplex())</span>
                {
<span class="nc" id="L435">                    indexCells(newRow.clustering(), newRow.getComplexColumnData(indexedColumn));</span>
<span class="nc" id="L436">                    removeCells(oldRow.clustering(), oldRow.getComplexColumnData(indexedColumn));</span>
                }
                else
                {
<span class="nc" id="L440">                    indexCell(newRow.clustering(), newRow.getCell(indexedColumn));</span>
<span class="nc" id="L441">                    removeCell(oldRow.clustering(), oldRow.getCell(indexedColumn));</span>
                }
<span class="nc" id="L443">            }</span>

            public void finish()
            {
<span class="nc" id="L447">            }</span>

            private void indexCells(Clustering clustering, Iterable&lt;Cell&gt; cells)
            {
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if (cells == null)</span>
<span class="nc" id="L452">                    return;</span>

<span class="nc bnc" id="L454" title="All 2 branches missed.">                for (Cell cell : cells)</span>
<span class="nc" id="L455">                    indexCell(clustering, cell);</span>
<span class="nc" id="L456">            }</span>

            private void indexCell(Clustering clustering, Cell cell)
            {
<span class="nc bnc" id="L460" title="All 4 branches missed.">                if (cell == null || !cell.isLive(nowInSec))</span>
<span class="nc" id="L461">                    return;</span>

<span class="nc" id="L463">                insert(key.getKey(),</span>
                       clustering,
                       cell,
<span class="nc" id="L466">                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),</span>
                       opGroup);
<span class="nc" id="L468">            }</span>

            private void removeCells(Clustering clustering, Iterable&lt;Cell&gt; cells)
            {
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (cells == null)</span>
<span class="nc" id="L473">                    return;</span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">                for (Cell cell : cells)</span>
<span class="nc" id="L476">                    removeCell(clustering, cell);</span>
<span class="nc" id="L477">            }</span>

            private void removeCell(Clustering clustering, Cell cell)
            {
<span class="nc bnc" id="L481" title="All 4 branches missed.">                if (cell == null || !cell.isLive(nowInSec))</span>
<span class="nc" id="L482">                    return;</span>

<span class="nc" id="L484">                delete(key.getKey(), clustering, cell, opGroup, nowInSec);</span>
<span class="nc" id="L485">            }</span>

            private void indexPrimaryKey(final Clustering clustering,
                                         final LivenessInfo liveness,
                                         final Row.Deletion deletion)
            {
<span class="nc bnc" id="L491" title="All 2 branches missed.">                if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)</span>
<span class="nc" id="L492">                    insert(key.getKey(), clustering, null, liveness, opGroup);</span>

<span class="nc bnc" id="L494" title="All 2 branches missed.">                if (!deletion.isLive())</span>
<span class="nc" id="L495">                    delete(key.getKey(), clustering, deletion.time(), opGroup);</span>
<span class="nc" id="L496">            }</span>

            private LivenessInfo getPrimaryKeyIndexLiveness(Row row)
            {
<span class="nc" id="L500">                long timestamp = row.primaryKeyLivenessInfo().timestamp();</span>
<span class="nc" id="L501">                int ttl = row.primaryKeyLivenessInfo().ttl();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                for (Cell cell : row.cells())</span>
                {
<span class="nc" id="L504">                    long cellTimestamp = cell.timestamp();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                    if (cell.isLive(nowInSec))</span>
                    {
<span class="nc bnc" id="L507" title="All 2 branches missed.">                        if (cellTimestamp &gt; timestamp)</span>
                        {
<span class="nc" id="L509">                            timestamp = cellTimestamp;</span>
<span class="nc" id="L510">                            ttl = cell.ttl();</span>
                        }
                    }
<span class="nc" id="L513">                }</span>
<span class="nc" id="L514">                return LivenessInfo.create(timestamp, ttl, nowInSec);</span>
            }
        };
    }

    /**
     * Specific to internal indexes, this is called by a
     * searcher when it encounters a stale entry in the index
     * @param indexKey the partition key in the index table
     * @param indexClustering the clustering in the index table
     * @param deletion deletion timestamp etc
     * @param opGroup the operation under which to perform the deletion
     */
    public void deleteStaleEntry(DecoratedKey indexKey,
                                 Clustering indexClustering,
                                 DeletionTime deletion,
                                 OpOrder.Group opGroup)
    {
<span class="nc" id="L532">        doDelete(indexKey, indexClustering, deletion, opGroup);</span>
<span class="nc" id="L533">        logger.trace(&quot;Removed index entry for stale value {}&quot;, indexKey);</span>
<span class="nc" id="L534">    }</span>

    /**
     * Called when adding a new entry to the index
     */
    private void insert(ByteBuffer rowKey,
                        Clustering clustering,
                        Cell cell,
                        LivenessInfo info,
                        OpOrder.Group opGroup)
    {
<span class="nc" id="L545">        DecoratedKey valueKey = getIndexKeyFor(getIndexedValue(rowKey,</span>
                                                               clustering,
                                                               cell));
<span class="nc" id="L548">        Row row = BTreeRow.noCellLiveRow(buildIndexClustering(rowKey, clustering, cell), info);</span>
<span class="nc" id="L549">        PartitionUpdate upd = partitionUpdate(valueKey, row);</span>
<span class="nc" id="L550">        indexCfs.apply(upd, UpdateTransaction.NO_OP, opGroup, null);</span>
<span class="nc" id="L551">        logger.trace(&quot;Inserted entry into index for value {}&quot;, valueKey);</span>
<span class="nc" id="L552">    }</span>

    /**
     * Called when deleting entries on non-primary key columns
     */
    private void delete(ByteBuffer rowKey,
                        Clustering clustering,
                        Cell cell,
                        OpOrder.Group opGroup,
                        int nowInSec)
    {
<span class="nc" id="L563">        DecoratedKey valueKey = getIndexKeyFor(getIndexedValue(rowKey,</span>
                                                               clustering,
                                                               cell));
<span class="nc" id="L566">        doDelete(valueKey,</span>
<span class="nc" id="L567">                 buildIndexClustering(rowKey, clustering, cell),</span>
<span class="nc" id="L568">                 new DeletionTime(cell.timestamp(), nowInSec),</span>
                 opGroup);
<span class="nc" id="L570">    }</span>

    /**
     * Called when deleting entries from indexes on primary key columns
     */
    private void delete(ByteBuffer rowKey,
                        Clustering clustering,
                        DeletionTime deletion,
                        OpOrder.Group opGroup)
    {
<span class="nc" id="L580">        DecoratedKey valueKey = getIndexKeyFor(getIndexedValue(rowKey,</span>
                                                               clustering,
                                                               null));
<span class="nc" id="L583">        doDelete(valueKey,</span>
<span class="nc" id="L584">                 buildIndexClustering(rowKey, clustering, null),</span>
                 deletion,
                 opGroup);
<span class="nc" id="L587">    }</span>

    private void doDelete(DecoratedKey indexKey,
                          Clustering indexClustering,
                          DeletionTime deletion,
                          OpOrder.Group opGroup)
    {
<span class="nc" id="L594">        Row row = BTreeRow.emptyDeletedRow(indexClustering, Row.Deletion.regular(deletion));</span>
<span class="nc" id="L595">        PartitionUpdate upd = partitionUpdate(indexKey, row);</span>
<span class="nc" id="L596">        indexCfs.apply(upd, UpdateTransaction.NO_OP, opGroup, null);</span>
<span class="nc" id="L597">        logger.trace(&quot;Removed index entry for value {}&quot;, indexKey);</span>
<span class="nc" id="L598">    }</span>

    private void validatePartitionKey(DecoratedKey partitionKey) throws InvalidRequestException
    {
<span class="nc bnc" id="L602" title="All 4 branches missed.">        assert indexedColumn.isPartitionKey();</span>
<span class="nc" id="L603">        validateIndexedValue(getIndexedValue(partitionKey.getKey(), null, null));</span>
<span class="nc" id="L604">    }</span>

    private void validateClusterings(PartitionUpdate update) throws InvalidRequestException
    {
<span class="nc bnc" id="L608" title="All 4 branches missed.">        assert indexedColumn.isClusteringColumn();</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">        for (Row row : update)</span>
<span class="nc" id="L610">            validateIndexedValue(getIndexedValue(null, row.clustering(), null));</span>
<span class="nc" id="L611">    }</span>

    private void validateRows(Iterable&lt;Row&gt; rows)
    {
<span class="nc bnc" id="L615" title="All 4 branches missed.">        assert !indexedColumn.isPrimaryKeyColumn();</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        for (Row row : rows)</span>
        {
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (indexedColumn.isComplex())</span>
            {
<span class="nc" id="L620">                ComplexColumnData data = row.getComplexColumnData(indexedColumn);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                if (data != null)</span>
                {
<span class="nc bnc" id="L623" title="All 2 branches missed.">                    for (Cell cell : data)</span>
                    {
<span class="nc" id="L625">                        validateIndexedValue(getIndexedValue(null, null, cell.path(), cell.value()));</span>
<span class="nc" id="L626">                    }</span>
                }
<span class="nc" id="L628">            }</span>
            else
            {
<span class="nc" id="L631">                validateIndexedValue(getIndexedValue(null, null, row.getCell(indexedColumn)));</span>
            }
<span class="nc" id="L633">        }</span>
<span class="nc" id="L634">    }</span>

    private void validateIndexedValue(ByteBuffer value)
    {
<span class="nc bnc" id="L638" title="All 4 branches missed.">        if (value != null &amp;&amp; value.remaining() &gt;= FBUtilities.MAX_UNSIGNED_SHORT)</span>
<span class="nc" id="L639">            throw new InvalidRequestException(String.format(</span>
                                                           &quot;Cannot index value of size %d for index %s on %s.%s(%s) (maximum allowed size=%d)&quot;,
<span class="nc" id="L641">                                                           value.remaining(),</span>
                                                           metadata.name,
                                                           baseCfs.metadata.ksName,
                                                           baseCfs.metadata.cfName,
<span class="nc" id="L645">                                                           indexedColumn.name.toString(),</span>
<span class="nc" id="L646">                                                           FBUtilities.MAX_UNSIGNED_SHORT));</span>
<span class="nc" id="L647">    }</span>

    private ByteBuffer getIndexedValue(ByteBuffer rowKey,
                                       Clustering clustering,
                                       Cell cell)
    {
<span class="nc bnc" id="L653" title="All 2 branches missed.">        return getIndexedValue(rowKey,</span>
                               clustering,
<span class="nc bnc" id="L655" title="All 2 branches missed.">                               cell == null ? null : cell.path(),</span>
<span class="nc" id="L656">                               cell == null ? null : cell.value()</span>
        );
    }

    private Clustering buildIndexClustering(ByteBuffer rowKey,
                                            Clustering clustering,
                                            Cell cell)
    {
<span class="nc bnc" id="L664" title="All 2 branches missed.">        return buildIndexClusteringPrefix(rowKey,</span>
                                          clustering,
<span class="nc" id="L666">                                          cell == null ? null : cell.path()).build();</span>
    }

    private DecoratedKey getIndexKeyFor(ByteBuffer value)
    {
<span class="nc" id="L671">        return indexCfs.decorateKey(value);</span>
    }

    private PartitionUpdate partitionUpdate(DecoratedKey valueKey, Row row)
    {
<span class="nc" id="L676">        return PartitionUpdate.singleRowUpdate(indexCfs.metadata, valueKey, row);</span>
    }

    private void invalidate()
    {
        // interrupt in-progress compactions
<span class="nc" id="L682">        Collection&lt;ColumnFamilyStore&gt; cfss = Collections.singleton(indexCfs);</span>
<span class="nc" id="L683">        CompactionManager.instance.interruptCompactionForCFs(cfss, true);</span>
<span class="nc" id="L684">        CompactionManager.instance.waitForCessation(cfss);</span>
<span class="nc" id="L685">        Keyspace.writeOrder.awaitNewBarrier();</span>
<span class="nc" id="L686">        indexCfs.forceBlockingFlush();</span>
<span class="nc" id="L687">        indexCfs.readOrdering.awaitNewBarrier();</span>
<span class="nc" id="L688">        indexCfs.invalidate();</span>
<span class="nc" id="L689">    }</span>

    private boolean isBuilt()
    {
<span class="nc" id="L693">        return SystemKeyspace.isIndexBuilt(baseCfs.keyspace.getName(), metadata.name);</span>
    }

    private boolean isPrimaryKeyIndex()
    {
<span class="nc" id="L698">        return indexedColumn.isPrimaryKeyColumn();</span>
    }

    private Callable&lt;?&gt; getBuildIndexTask()
    {
<span class="nc" id="L703">        return () -&gt; {</span>
<span class="nc" id="L704">            buildBlocking();</span>
<span class="nc" id="L705">            return null;</span>
        };
    }

    private void buildBlocking()
    {
<span class="nc" id="L711">        baseCfs.forceBlockingFlush();</span>

<span class="nc" id="L713">        try (ColumnFamilyStore.RefViewFragment viewFragment = baseCfs.selectAndReference(View.selectFunction(SSTableSet.CANONICAL));</span>
<span class="nc" id="L714">             Refs&lt;SSTableReader&gt; sstables = viewFragment.refs)</span>
        {
<span class="nc bnc" id="L716" title="All 2 branches missed.">            if (sstables.isEmpty())</span>
            {
<span class="nc" id="L718">                logger.info(&quot;No SSTable data for {}.{} to build index {} from, marking empty index as built&quot;,</span>
                            baseCfs.metadata.ksName,
                            baseCfs.metadata.cfName,
                            metadata.name);
<span class="nc" id="L722">                baseCfs.indexManager.markIndexBuilt(metadata.name);</span>
<span class="nc" id="L723">                return;</span>
            }

<span class="nc" id="L726">            logger.info(&quot;Submitting index build of {} for data in {}&quot;,</span>
                        metadata.name,
<span class="nc" id="L728">                        getSSTableNames(sstables));</span>

<span class="nc" id="L730">            SecondaryIndexBuilder builder = new CollatedViewIndexBuilder(baseCfs,</span>
<span class="nc" id="L731">                                                                         Collections.singleton(this),</span>
                                                                         new ReducingKeyIterator(sstables));
<span class="nc" id="L733">            Future&lt;?&gt; future = CompactionManager.instance.submitIndexBuild(builder);</span>
<span class="nc" id="L734">            FBUtilities.waitOnFuture(future);</span>
<span class="nc" id="L735">            indexCfs.forceBlockingFlush();</span>
<span class="nc" id="L736">            baseCfs.indexManager.markIndexBuilt(metadata.name);</span>
        }
<span class="nc" id="L738">        logger.info(&quot;Index build of {} complete&quot;, metadata.name);</span>
<span class="nc" id="L739">    }</span>

    private static String getSSTableNames(Collection&lt;SSTableReader&gt; sstables)
    {
<span class="nc" id="L743">        return StreamSupport.stream(sstables.spliterator(), false)</span>
<span class="nc" id="L744">                            .map(SSTableReader::toString)</span>
<span class="nc" id="L745">                            .collect(Collectors.joining(&quot;, &quot;));</span>
    }

    /**
     * Construct the CFMetadata for an index table, the clustering columns in the index table
     * vary dependent on the kind of the indexed value.
     * @param baseCfsMetadata
     * @param indexMetadata
     * @return
     */
    public static final CFMetaData indexCfsMetadata(CFMetaData baseCfsMetadata, IndexMetadata indexMetadata)
    {
<span class="nc" id="L757">        Pair&lt;ColumnDefinition, IndexTarget.Type&gt; target = TargetParser.parse(baseCfsMetadata, indexMetadata);</span>
<span class="nc" id="L758">        CassandraIndexFunctions utils = getFunctions(indexMetadata, target);</span>
<span class="nc" id="L759">        ColumnDefinition indexedColumn = target.left;</span>
<span class="nc" id="L760">        AbstractType&lt;?&gt; indexedValueType = utils.getIndexedValueType(indexedColumn);</span>

        // Tables for legacy KEYS indexes are non-compound and dense
<span class="nc bnc" id="L763" title="All 2 branches missed.">        CFMetaData.Builder builder = indexMetadata.isKeys()</span>
<span class="nc" id="L764">                                     ? CFMetaData.Builder.create(baseCfsMetadata.ksName,</span>
<span class="nc" id="L765">                                                                 baseCfsMetadata.indexColumnFamilyName(indexMetadata),</span>
                                                                 true, false, false)
<span class="nc" id="L767">                                     : CFMetaData.Builder.create(baseCfsMetadata.ksName,</span>
<span class="nc" id="L768">                                                                 baseCfsMetadata.indexColumnFamilyName(indexMetadata));</span>

<span class="nc" id="L770">        builder =  builder.withId(baseCfsMetadata.cfId)</span>
<span class="nc" id="L771">                          .withPartitioner(new LocalPartitioner(indexedValueType))</span>
<span class="nc" id="L772">                          .addPartitionKey(indexedColumn.name, indexedColumn.type)</span>
<span class="nc" id="L773">                          .addClusteringColumn(&quot;partition_key&quot;, baseCfsMetadata.partitioner.partitionOrdering());</span>

<span class="nc bnc" id="L775" title="All 2 branches missed.">        if (indexMetadata.isKeys())</span>
        {
            // A dense, compact table for KEYS indexes must have a compact
            // value column defined, even though it is never used
<span class="nc" id="L779">            CompactTables.DefaultNames names =</span>
<span class="nc" id="L780">                CompactTables.defaultNameGenerator(ImmutableSet.of(indexedColumn.name.toString(), &quot;partition_key&quot;));</span>
<span class="nc" id="L781">            builder = builder.addRegularColumn(names.defaultCompactValueName(), EmptyType.instance);</span>
<span class="nc" id="L782">        }</span>
        else
        {
            // The clustering columns for a table backing a COMPOSITES index are dependent
            // on the specific type of index (there are specializations for indexes on collections)
<span class="nc" id="L787">            builder = utils.addIndexClusteringColumns(builder, baseCfsMetadata, indexedColumn);</span>
        }

<span class="nc" id="L790">        return builder.build().reloadIndexMetadataProperties(baseCfsMetadata);</span>
    }

    /**
     * Factory method for new CassandraIndex instances
     * @param baseCfs
     * @param indexMetadata
     * @return
     */
    public static CassandraIndex newIndex(ColumnFamilyStore baseCfs, IndexMetadata indexMetadata)
    {
<span class="nc" id="L801">        return getFunctions(indexMetadata, TargetParser.parse(baseCfs.metadata, indexMetadata)).newIndexInstance(baseCfs, indexMetadata);</span>
    }

    static CassandraIndexFunctions getFunctions(IndexMetadata indexDef,
                                                Pair&lt;ColumnDefinition, IndexTarget.Type&gt; target)
    {
<span class="nc bnc" id="L807" title="All 2 branches missed.">        if (indexDef.isKeys())</span>
<span class="nc" id="L808">            return CassandraIndexFunctions.KEYS_INDEX_FUNCTIONS;</span>

<span class="nc" id="L810">        ColumnDefinition indexedColumn = target.left;</span>
<span class="nc bnc" id="L811" title="All 4 branches missed.">        if (indexedColumn.type.isCollection() &amp;&amp; indexedColumn.type.isMultiCell())</span>
        {
<span class="nc bnc" id="L813" title="All 4 branches missed.">            switch (((CollectionType)indexedColumn.type).kind)</span>
            {
                case LIST:
<span class="nc" id="L816">                    return CassandraIndexFunctions.COLLECTION_VALUE_INDEX_FUNCTIONS;</span>
                case SET:
<span class="nc" id="L818">                    return CassandraIndexFunctions.COLLECTION_KEY_INDEX_FUNCTIONS;</span>
                case MAP:
<span class="nc bnc" id="L820" title="All 4 branches missed.">                    switch (target.right)</span>
                    {
                        case KEYS:
<span class="nc" id="L823">                            return CassandraIndexFunctions.COLLECTION_KEY_INDEX_FUNCTIONS;</span>
                        case KEYS_AND_VALUES:
<span class="nc" id="L825">                            return CassandraIndexFunctions.COLLECTION_ENTRY_INDEX_FUNCTIONS;</span>
                        case VALUES:
<span class="nc" id="L827">                            return CassandraIndexFunctions.COLLECTION_VALUE_INDEX_FUNCTIONS;</span>
                    }
<span class="nc" id="L829">                    throw new AssertionError();</span>
            }
        }

<span class="nc bnc" id="L833" title="All 4 branches missed.">        switch (indexedColumn.kind)</span>
        {
            case CLUSTERING:
<span class="nc" id="L836">                return CassandraIndexFunctions.CLUSTERING_COLUMN_INDEX_FUNCTIONS;</span>
            case REGULAR:
            case STATIC:
<span class="nc" id="L839">                return CassandraIndexFunctions.REGULAR_COLUMN_INDEX_FUNCTIONS;</span>
            case PARTITION_KEY:
<span class="nc" id="L841">                return CassandraIndexFunctions.PARTITION_KEY_INDEX_FUNCTIONS;</span>
            //case COMPACT_VALUE:
            //    return new CompositesIndexOnCompactValue();
        }
<span class="nc" id="L845">        throw new AssertionError();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>