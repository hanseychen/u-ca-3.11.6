<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableMetrics.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.metrics</a> &gt; <span class="el_source">TableMetrics.java</span></div><h1>TableMetrics.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.metrics;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

import com.google.common.collect.Maps;

import com.codahale.metrics.*;
import com.codahale.metrics.Timer;
import org.apache.cassandra.config.Schema;
import org.apache.cassandra.config.SchemaConstants;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.Memtable;
import org.apache.cassandra.db.lifecycle.SSTableSet;
import org.apache.cassandra.index.SecondaryIndexManager;
import org.apache.cassandra.io.compress.CompressionMetadata;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
import org.apache.cassandra.utils.EstimatedHistogram;
import org.apache.cassandra.utils.TopKSampler;

import static org.apache.cassandra.metrics.CassandraMetricsRegistry.Metrics;

/**
 * Metrics for {@link ColumnFamilyStore}.
 */
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">public class TableMetrics</span>
{

<span class="fc" id="L51">    public static final long[] EMPTY = new long[0];</span>

    /** Total amount of data stored in the memtable that resides on-heap, including column related overhead and partitions overwritten. */
    public final Gauge&lt;Long&gt; memtableOnHeapSize;
    /** Total amount of data stored in the memtable that resides off-heap, including column related overhead and partitions overwritten. */
    public final Gauge&lt;Long&gt; memtableOffHeapSize;
    /** Total amount of live data stored in the memtable, excluding any data structure overhead */
    public final Gauge&lt;Long&gt; memtableLiveDataSize;
    /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides on-heap. */
    public final Gauge&lt;Long&gt; allMemtablesOnHeapSize;
    /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides off-heap. */
    public final Gauge&lt;Long&gt; allMemtablesOffHeapSize;
    /** Total amount of live data stored in the memtables (2i and pending flush memtables included) that resides off-heap, excluding any data structure overhead */
    public final Gauge&lt;Long&gt; allMemtablesLiveDataSize;
    /** Total number of columns present in the memtable. */
    public final Gauge&lt;Long&gt; memtableColumnsCount;
    /** Number of times flush has resulted in the memtable being switched out. */
    public final Counter memtableSwitchCount;
    /** Current compression ratio for all SSTables */
    public final Gauge&lt;Double&gt; compressionRatio;
    /** Histogram of estimated partition size (in bytes). */
    public final Gauge&lt;long[]&gt; estimatedPartitionSizeHistogram;
    /** Approximate number of keys in table. */
    public final Gauge&lt;Long&gt; estimatedPartitionCount;
    /** Histogram of estimated number of columns. */
    public final Gauge&lt;long[]&gt; estimatedColumnCountHistogram;
    /** Histogram of the number of sstable data files accessed per read */
    public final TableHistogram sstablesPerReadHistogram;
    /** (Local) read metrics */
    public final LatencyMetrics readLatency;
    /** (Local) range slice metrics */
    public final LatencyMetrics rangeLatency;
    /** (Local) write metrics */
    public final LatencyMetrics writeLatency;
    /** Estimated number of tasks pending for this table */
    public final Counter pendingFlushes;
    /** Total number of bytes flushed since server [re]start */
    public final Counter bytesFlushed;
    /** Total number of bytes written by compaction since server [re]start */
    public final Counter compactionBytesWritten;
    /** Estimate of number of pending compactios for this table */
    public final Gauge&lt;Integer&gt; pendingCompactions;
    /** Number of SSTables on disk for this CF */
    public final Gauge&lt;Integer&gt; liveSSTableCount;
    /** Disk space used by SSTables belonging to this table */
    public final Counter liveDiskSpaceUsed;
    /** Total disk space used by SSTables belonging to this table, including obsolete ones waiting to be GC'd */
    public final Counter totalDiskSpaceUsed;
    /** Size of the smallest compacted partition */
    public final Gauge&lt;Long&gt; minPartitionSize;
    /** Size of the largest compacted partition */
    public final Gauge&lt;Long&gt; maxPartitionSize;
    /** Size of the smallest compacted partition */
    public final Gauge&lt;Long&gt; meanPartitionSize;
    /** Number of false positives in bloom filter */
    public final Gauge&lt;Long&gt; bloomFilterFalsePositives;
    /** Number of false positives in bloom filter from last read */
    public final Gauge&lt;Long&gt; recentBloomFilterFalsePositives;
    /** False positive ratio of bloom filter */
    public final Gauge&lt;Double&gt; bloomFilterFalseRatio;
    /** False positive ratio of bloom filter from last read */
    public final Gauge&lt;Double&gt; recentBloomFilterFalseRatio;
    /** Disk space used by bloom filter */
    public final Gauge&lt;Long&gt; bloomFilterDiskSpaceUsed;
    /** Off heap memory used by bloom filter */
    public final Gauge&lt;Long&gt; bloomFilterOffHeapMemoryUsed;
    /** Off heap memory used by index summary */
    public final Gauge&lt;Long&gt; indexSummaryOffHeapMemoryUsed;
    /** Off heap memory used by compression meta data*/
    public final Gauge&lt;Long&gt; compressionMetadataOffHeapMemoryUsed;
    /** Key cache hit rate  for this CF */
    public final Gauge&lt;Double&gt; keyCacheHitRate;
    /** Tombstones scanned in queries on this CF */
    public final TableHistogram tombstoneScannedHistogram;
    /** Live rows scanned in queries on this CF */
    public final TableHistogram liveScannedHistogram;
    /** Column update time delta on this CF */
    public final TableHistogram colUpdateTimeDeltaHistogram;
    /** time taken acquiring the partition lock for materialized view updates for this table */
    public final TableTimer viewLockAcquireTime;
    /** time taken during the local read of a materialized view update */
    public final TableTimer viewReadTime;
    /** Disk space used by snapshot files which */
    public final Gauge&lt;Long&gt; trueSnapshotsSize;
    /** Row cache hits, but result out of range */
    public final Counter rowCacheHitOutOfRange;
    /** Number of row cache hits */
    public final Counter rowCacheHit;
    /** Number of row cache misses */
    public final Counter rowCacheMiss;
    /** CAS Prepare metrics */
    public final LatencyMetrics casPrepare;
    /** CAS Propose metrics */
    public final LatencyMetrics casPropose;
    /** CAS Commit metrics */
    public final LatencyMetrics casCommit;
    /** percent of the data that is repaired */
    public final Gauge&lt;Double&gt; percentRepaired;

    public final Timer coordinatorReadLatency;
    public final Timer coordinatorScanLatency;

    /** Time spent waiting for free memtable space, either on- or off-heap */
    public final Histogram waitingOnFreeMemtableSpace;

    /** Dropped Mutations Count */
    public final Counter droppedMutations;

    private final MetricNameFactory factory;
    private final MetricNameFactory aliasFactory;
<span class="fc" id="L161">    private static final MetricNameFactory globalFactory = new AllTableMetricNameFactory(&quot;Table&quot;);</span>
<span class="fc" id="L162">    private static final MetricNameFactory globalAliasFactory = new AllTableMetricNameFactory(&quot;ColumnFamily&quot;);</span>

    public final Counter speculativeRetries;

<span class="fc" id="L166">    public final static LatencyMetrics globalReadLatency = new LatencyMetrics(globalFactory, globalAliasFactory, &quot;Read&quot;);</span>
<span class="fc" id="L167">    public final static LatencyMetrics globalWriteLatency = new LatencyMetrics(globalFactory, globalAliasFactory, &quot;Write&quot;);</span>
<span class="fc" id="L168">    public final static LatencyMetrics globalRangeLatency = new LatencyMetrics(globalFactory, globalAliasFactory, &quot;Range&quot;);</span>

<span class="fc" id="L170">    public final static Gauge&lt;Double&gt; globalPercentRepaired = Metrics.register(globalFactory.createMetricName(&quot;PercentRepaired&quot;),</span>
            new Gauge&lt;Double&gt;()
<span class="fc" id="L172">    {</span>
        public Double getValue()
        {
<span class="nc" id="L175">            double repaired = 0;</span>
<span class="nc" id="L176">            double total = 0;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            for (String keyspace : Schema.instance.getNonSystemKeyspaces())</span>
            {
<span class="nc" id="L179">                Keyspace k = Schema.instance.getKeyspaceInstance(keyspace);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (SchemaConstants.DISTRIBUTED_KEYSPACE_NAME.equals(k.getName()))</span>
<span class="nc" id="L181">                    continue;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                if (k.getReplicationStrategy().getReplicationFactor() &lt; 2)</span>
<span class="nc" id="L183">                    continue;</span>

<span class="nc bnc" id="L185" title="All 2 branches missed.">                for (ColumnFamilyStore cf : k.getColumnFamilyStores())</span>
                {
<span class="nc bnc" id="L187" title="All 2 branches missed.">                    if (!SecondaryIndexManager.isIndexColumnFamily(cf.name))</span>
                    {
<span class="nc bnc" id="L189" title="All 2 branches missed.">                        for (SSTableReader sstable : cf.getSSTables(SSTableSet.CANONICAL))</span>
                        {
<span class="nc bnc" id="L191" title="All 2 branches missed.">                            if (sstable.isRepaired())</span>
                            {
<span class="nc" id="L193">                                repaired += sstable.uncompressedLength();</span>
                            }
<span class="nc" id="L195">                            total += sstable.uncompressedLength();</span>
<span class="nc" id="L196">                        }</span>
                    }
<span class="nc" id="L198">                }</span>
<span class="nc" id="L199">            }</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            return total &gt; 0 ? (repaired / total) * 100 : 100.0;</span>
        }
    });

    public final Meter readRepairRequests;
    public final Meter shortReadProtectionRequests;

    public final Map&lt;Sampler, TopKSampler&lt;ByteBuffer&gt;&gt; samplers;
    /**
     * stores metrics that will be rolled into a single global metric
     */
<span class="fc" id="L211">    public final static ConcurrentMap&lt;String, Set&lt;Metric&gt;&gt; allTableMetrics = Maps.newConcurrentMap();</span>

    /**
     * Stores all metric names created that can be used when unregistering, optionally mapped to an alias name.
     */
<span class="fc" id="L216">    public final static Map&lt;String, String&gt; all = Maps.newHashMap();</span>

    private interface GetHistogram
    {
        EstimatedHistogram getHistogram(SSTableReader reader);
    }

    private static long[] combineHistograms(Iterable&lt;SSTableReader&gt; sstables, GetHistogram getHistogram)
    {
<span class="nc" id="L225">        Iterator&lt;SSTableReader&gt; iterator = sstables.iterator();</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (!iterator.hasNext())</span>
        {
<span class="nc" id="L228">            return EMPTY;</span>
        }
<span class="nc" id="L230">        long[] firstBucket = getHistogram.getHistogram(iterator.next()).getBuckets(false);</span>
<span class="nc" id="L231">        long[] values = new long[firstBucket.length];</span>
<span class="nc" id="L232">        System.arraycopy(firstBucket, 0, values, 0, values.length);</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc" id="L236">            long[] nextBucket = getHistogram.getHistogram(iterator.next()).getBuckets(false);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (nextBucket.length &gt; values.length)</span>
            {
<span class="nc" id="L239">                long[] newValues = new long[nextBucket.length];</span>
<span class="nc" id="L240">                System.arraycopy(firstBucket, 0, newValues, 0, firstBucket.length);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                for (int i = 0; i &lt; newValues.length; i++)</span>
                {
<span class="nc" id="L243">                    newValues[i] += nextBucket[i];</span>
                }
<span class="nc" id="L245">                values = newValues;</span>
<span class="nc" id="L246">            }</span>
            else
            {
<span class="nc bnc" id="L249" title="All 2 branches missed.">                for (int i = 0; i &lt; values.length; i++)</span>
                {
<span class="nc" id="L251">                    values[i] += nextBucket[i];</span>
                }
            }
<span class="nc" id="L254">        }</span>
<span class="nc" id="L255">        return values;</span>
    }

    /**
     * Creates metrics for given {@link ColumnFamilyStore}.
     *
     * @param cfs ColumnFamilyStore to measure metrics
     */
    public TableMetrics(final ColumnFamilyStore cfs)
<span class="fc" id="L264">    {</span>
<span class="fc" id="L265">        factory = new TableMetricNameFactory(cfs, &quot;Table&quot;);</span>
<span class="fc" id="L266">        aliasFactory = new TableMetricNameFactory(cfs, &quot;ColumnFamily&quot;);</span>

<span class="fc" id="L268">        samplers = Maps.newHashMap();</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        for (Sampler sampler : Sampler.values())</span>
        {
<span class="fc" id="L271">            samplers.put(sampler, new TopKSampler&lt;&gt;());</span>
        }

<span class="fc" id="L274">        memtableColumnsCount = createTableGauge(&quot;MemtableColumnsCount&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L275">        {</span>
            public Long getValue()
            {
<span class="nc" id="L278">                return cfs.getTracker().getView().getCurrentMemtable().getOperations();</span>
            }
        });
<span class="fc" id="L281">        memtableOnHeapSize = createTableGauge(&quot;MemtableOnHeapSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L282">        {</span>
            public Long getValue()
            {
<span class="nc" id="L285">                return cfs.getTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns();</span>
            }
        });
<span class="fc" id="L288">        memtableOffHeapSize = createTableGauge(&quot;MemtableOffHeapSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L289">        {</span>
            public Long getValue()
            {
<span class="nc" id="L292">                return cfs.getTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns();</span>
            }
        });
<span class="fc" id="L295">        memtableLiveDataSize = createTableGauge(&quot;MemtableLiveDataSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L296">        {</span>
            public Long getValue()
            {
<span class="nc" id="L299">                return cfs.getTracker().getView().getCurrentMemtable().getLiveDataSize();</span>
            }
        });
<span class="fc" id="L302">        allMemtablesOnHeapSize = createTableGauge(&quot;AllMemtablesHeapSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L303">        {</span>
            public Long getValue()
            {
<span class="nc" id="L306">                long size = 0;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())</span>
<span class="nc" id="L308">                    size += cfs2.getTracker().getView().getCurrentMemtable().getAllocator().onHeap().owns();</span>
<span class="nc" id="L309">                return size;</span>
            }
        });
<span class="fc" id="L312">        allMemtablesOffHeapSize = createTableGauge(&quot;AllMemtablesOffHeapSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L313">        {</span>
            public Long getValue()
            {
<span class="nc" id="L316">                long size = 0;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())</span>
<span class="nc" id="L318">                    size += cfs2.getTracker().getView().getCurrentMemtable().getAllocator().offHeap().owns();</span>
<span class="nc" id="L319">                return size;</span>
            }
        });
<span class="fc" id="L322">        allMemtablesLiveDataSize = createTableGauge(&quot;AllMemtablesLiveDataSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L323">        {</span>
            public Long getValue()
            {
<span class="nc" id="L326">                long size = 0;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())</span>
<span class="nc" id="L328">                    size += cfs2.getTracker().getView().getCurrentMemtable().getLiveDataSize();</span>
<span class="nc" id="L329">                return size;</span>
            }
        });
<span class="fc" id="L332">        memtableSwitchCount = createTableCounter(&quot;MemtableSwitchCount&quot;);</span>
<span class="fc" id="L333">        estimatedPartitionSizeHistogram = Metrics.register(factory.createMetricName(&quot;EstimatedPartitionSizeHistogram&quot;),</span>
<span class="fc" id="L334">                                                           aliasFactory.createMetricName(&quot;EstimatedRowSizeHistogram&quot;),</span>
                                                           new Gauge&lt;long[]&gt;()
<span class="fc" id="L336">                                                           {</span>
                                                               public long[] getValue()
                                                               {
<span class="nc" id="L339">                                                                   return combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL), new GetHistogram()</span>
<span class="nc" id="L340">                                                                   {</span>
                                                                       public EstimatedHistogram getHistogram(SSTableReader reader)
                                                                       {
<span class="nc" id="L343">                                                                           return reader.getEstimatedPartitionSize();</span>
                                                                       }
                                                                   });
                                                               }
                                                           });
<span class="fc" id="L348">        estimatedPartitionCount = Metrics.register(factory.createMetricName(&quot;EstimatedPartitionCount&quot;),</span>
<span class="fc" id="L349">                                                   aliasFactory.createMetricName(&quot;EstimatedRowCount&quot;),</span>
                                                   new Gauge&lt;Long&gt;()
<span class="fc" id="L351">                                                   {</span>
                                                       public Long getValue()
                                                       {
<span class="nc" id="L354">                                                           long memtablePartitions = 0;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                                                           for (Memtable memtable : cfs.getTracker().getView().getAllMemtables())</span>
<span class="nc" id="L356">                                                               memtablePartitions += memtable.partitionCount();</span>
<span class="nc" id="L357">                                                           return SSTableReader.getApproximateKeyCount(cfs.getSSTables(SSTableSet.CANONICAL)) + memtablePartitions;</span>
                                                       }
                                                   });
<span class="fc" id="L360">        estimatedColumnCountHistogram = Metrics.register(factory.createMetricName(&quot;EstimatedColumnCountHistogram&quot;),</span>
<span class="fc" id="L361">                                                         aliasFactory.createMetricName(&quot;EstimatedColumnCountHistogram&quot;),</span>
                                                         new Gauge&lt;long[]&gt;()
<span class="fc" id="L363">                                                         {</span>
                                                             public long[] getValue()
                                                             {
<span class="nc" id="L366">                                                                 return combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL), new GetHistogram()</span>
<span class="nc" id="L367">                                                                 {</span>
                                                                     public EstimatedHistogram getHistogram(SSTableReader reader)
                                                                     {
<span class="nc" id="L370">                                                                         return reader.getEstimatedColumnCount();</span>
                                                                     }
                                                                 });
            }
        });
<span class="fc" id="L375">        sstablesPerReadHistogram = createTableHistogram(&quot;SSTablesPerReadHistogram&quot;, cfs.keyspace.metric.sstablesPerReadHistogram, true);</span>
<span class="fc" id="L376">        compressionRatio = createTableGauge(&quot;CompressionRatio&quot;, new Gauge&lt;Double&gt;()</span>
<span class="fc" id="L377">        {</span>
            public Double getValue()
            {
<span class="nc" id="L380">                return computeCompressionRatio(cfs.getSSTables(SSTableSet.CANONICAL));</span>
            }
        }, new Gauge&lt;Double&gt;() // global gauge
<span class="fc" id="L383">        {</span>
            public Double getValue()
            {
<span class="nc" id="L386">                List&lt;SSTableReader&gt; sstables = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L387">                Keyspace.all().forEach(ks -&gt; sstables.addAll(ks.getAllSSTables(SSTableSet.CANONICAL)));</span>
<span class="nc" id="L388">                return computeCompressionRatio(sstables);</span>
            }
        });
<span class="fc" id="L391">        percentRepaired = createTableGauge(&quot;PercentRepaired&quot;, new Gauge&lt;Double&gt;()</span>
<span class="fc" id="L392">        {</span>
            public Double getValue()
            {
<span class="nc" id="L395">                double repaired = 0;</span>
<span class="nc" id="L396">                double total = 0;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
                {
<span class="nc bnc" id="L399" title="All 2 branches missed.">                    if (sstable.isRepaired())</span>
                    {
<span class="nc" id="L401">                        repaired += sstable.uncompressedLength();</span>
                    }
<span class="nc" id="L403">                    total += sstable.uncompressedLength();</span>
<span class="nc" id="L404">                }</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                return total &gt; 0 ? (repaired / total) * 100 : 100.0;</span>
            }
        });
<span class="fc" id="L408">        readLatency = new LatencyMetrics(factory, &quot;Read&quot;, cfs.keyspace.metric.readLatency, globalReadLatency);</span>
<span class="fc" id="L409">        writeLatency = new LatencyMetrics(factory, &quot;Write&quot;, cfs.keyspace.metric.writeLatency, globalWriteLatency);</span>
<span class="fc" id="L410">        rangeLatency = new LatencyMetrics(factory, &quot;Range&quot;, cfs.keyspace.metric.rangeLatency, globalRangeLatency);</span>
<span class="fc" id="L411">        pendingFlushes = createTableCounter(&quot;PendingFlushes&quot;);</span>
<span class="fc" id="L412">        bytesFlushed = createTableCounter(&quot;BytesFlushed&quot;);</span>
<span class="fc" id="L413">        compactionBytesWritten = createTableCounter(&quot;CompactionBytesWritten&quot;);</span>
<span class="fc" id="L414">        pendingCompactions = createTableGauge(&quot;PendingCompactions&quot;, new Gauge&lt;Integer&gt;()</span>
<span class="fc" id="L415">        {</span>
            public Integer getValue()
            {
<span class="nc" id="L418">                return cfs.getCompactionStrategyManager().getEstimatedRemainingTasks();</span>
            }
        });
<span class="fc" id="L421">        liveSSTableCount = createTableGauge(&quot;LiveSSTableCount&quot;, new Gauge&lt;Integer&gt;()</span>
<span class="fc" id="L422">        {</span>
            public Integer getValue()
            {
<span class="nc" id="L425">                return cfs.getTracker().getView().liveSSTables().size();</span>
            }
        });
<span class="fc" id="L428">        liveDiskSpaceUsed = createTableCounter(&quot;LiveDiskSpaceUsed&quot;);</span>
<span class="fc" id="L429">        totalDiskSpaceUsed = createTableCounter(&quot;TotalDiskSpaceUsed&quot;);</span>
<span class="fc" id="L430">        minPartitionSize = createTableGauge(&quot;MinPartitionSize&quot;, &quot;MinRowSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L431">        {</span>
            public Long getValue()
            {
<span class="nc" id="L434">                long min = 0;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
                {
<span class="nc bnc" id="L437" title="All 4 branches missed.">                    if (min == 0 || sstable.getEstimatedPartitionSize().min() &lt; min)</span>
<span class="nc" id="L438">                        min = sstable.getEstimatedPartitionSize().min();</span>
<span class="nc" id="L439">                }</span>
<span class="nc" id="L440">                return min;</span>
            }
        }, new Gauge&lt;Long&gt;() // global gauge
<span class="fc" id="L443">        {</span>
            public Long getValue()
            {
<span class="nc" id="L446">                long min = Long.MAX_VALUE;</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                for (Metric cfGauge : allTableMetrics.get(&quot;MinPartitionSize&quot;))</span>
                {
<span class="nc" id="L449">                    min = Math.min(min, ((Gauge&lt;? extends Number&gt;) cfGauge).getValue().longValue());</span>
<span class="nc" id="L450">                }</span>
<span class="nc" id="L451">                return min;</span>
            }
        });
<span class="fc" id="L454">        maxPartitionSize = createTableGauge(&quot;MaxPartitionSize&quot;, &quot;MaxRowSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L455">        {</span>
            public Long getValue()
            {
<span class="nc" id="L458">                long max = 0;</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
                {
<span class="nc bnc" id="L461" title="All 2 branches missed.">                    if (sstable.getEstimatedPartitionSize().max() &gt; max)</span>
<span class="nc" id="L462">                        max = sstable.getEstimatedPartitionSize().max();</span>
<span class="nc" id="L463">                }</span>
<span class="nc" id="L464">                return max;</span>
            }
        }, new Gauge&lt;Long&gt;() // global gauge
<span class="fc" id="L467">        {</span>
            public Long getValue()
            {
<span class="nc" id="L470">                long max = 0;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                for (Metric cfGauge : allTableMetrics.get(&quot;MaxPartitionSize&quot;))</span>
                {
<span class="nc" id="L473">                    max = Math.max(max, ((Gauge&lt;? extends Number&gt;) cfGauge).getValue().longValue());</span>
<span class="nc" id="L474">                }</span>
<span class="nc" id="L475">                return max;</span>
            }
        });
<span class="fc" id="L478">        meanPartitionSize = createTableGauge(&quot;MeanPartitionSize&quot;, &quot;MeanRowSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L479">        {</span>
            public Long getValue()
            {
<span class="nc" id="L482">                long sum = 0;</span>
<span class="nc" id="L483">                long count = 0;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
                {
<span class="nc" id="L486">                    long n = sstable.getEstimatedPartitionSize().count();</span>
<span class="nc" id="L487">                    sum += sstable.getEstimatedPartitionSize().mean() * n;</span>
<span class="nc" id="L488">                    count += n;</span>
<span class="nc" id="L489">                }</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                return count &gt; 0 ? sum / count : 0;</span>
            }
        }, new Gauge&lt;Long&gt;() // global gauge
<span class="fc" id="L493">        {</span>
            public Long getValue()
            {
<span class="nc" id="L496">                long sum = 0;</span>
<span class="nc" id="L497">                long count = 0;</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                for (Keyspace keyspace : Keyspace.all())</span>
                {
<span class="nc bnc" id="L500" title="All 2 branches missed.">                    for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.CANONICAL))</span>
                    {
<span class="nc" id="L502">                        long n = sstable.getEstimatedPartitionSize().count();</span>
<span class="nc" id="L503">                        sum += sstable.getEstimatedPartitionSize().mean() * n;</span>
<span class="nc" id="L504">                        count += n;</span>
<span class="nc" id="L505">                    }</span>
<span class="nc" id="L506">                }</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                return count &gt; 0 ? sum / count : 0;</span>
            }
        });
<span class="fc" id="L510">        bloomFilterFalsePositives = createTableGauge(&quot;BloomFilterFalsePositives&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L511">        {</span>
            public Long getValue()
            {
<span class="nc" id="L514">                long count = 0L;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                for (SSTableReader sstable: cfs.getSSTables(SSTableSet.LIVE))</span>
<span class="nc" id="L516">                    count += sstable.getBloomFilterFalsePositiveCount();</span>
<span class="nc" id="L517">                return count;</span>
            }
        });
<span class="fc" id="L520">        recentBloomFilterFalsePositives = createTableGauge(&quot;RecentBloomFilterFalsePositives&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L521">        {</span>
            public Long getValue()
            {
<span class="nc" id="L524">                long count = 0L;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))</span>
<span class="nc" id="L526">                    count += sstable.getRecentBloomFilterFalsePositiveCount();</span>
<span class="nc" id="L527">                return count;</span>
            }
        });
<span class="fc" id="L530">        bloomFilterFalseRatio = createTableGauge(&quot;BloomFilterFalseRatio&quot;, new Gauge&lt;Double&gt;()</span>
<span class="fc" id="L531">        {</span>
            public Double getValue()
            {
<span class="nc" id="L534">                long falseCount = 0L;</span>
<span class="nc" id="L535">                long trueCount = 0L;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))</span>
                {
<span class="nc" id="L538">                    falseCount += sstable.getBloomFilterFalsePositiveCount();</span>
<span class="nc" id="L539">                    trueCount += sstable.getBloomFilterTruePositiveCount();</span>
<span class="nc" id="L540">                }</span>
<span class="nc bnc" id="L541" title="All 4 branches missed.">                if (falseCount == 0L &amp;&amp; trueCount == 0L)</span>
<span class="nc" id="L542">                    return 0d;</span>
<span class="nc" id="L543">                return (double) falseCount / (trueCount + falseCount);</span>
            }
        }, new Gauge&lt;Double&gt;() // global gauge
<span class="fc" id="L546">        {</span>
            public Double getValue()
            {
<span class="nc" id="L549">                long falseCount = 0L;</span>
<span class="nc" id="L550">                long trueCount = 0L;</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">                for (Keyspace keyspace : Keyspace.all())</span>
                {
<span class="nc bnc" id="L553" title="All 2 branches missed.">                    for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.LIVE))</span>
                    {
<span class="nc" id="L555">                        falseCount += sstable.getBloomFilterFalsePositiveCount();</span>
<span class="nc" id="L556">                        trueCount += sstable.getBloomFilterTruePositiveCount();</span>
<span class="nc" id="L557">                    }</span>
<span class="nc" id="L558">                }</span>
<span class="nc bnc" id="L559" title="All 4 branches missed.">                if (falseCount == 0L &amp;&amp; trueCount == 0L)</span>
<span class="nc" id="L560">                    return 0d;</span>
<span class="nc" id="L561">                return (double) falseCount / (trueCount + falseCount);</span>
            }
        });
<span class="fc" id="L564">        recentBloomFilterFalseRatio = createTableGauge(&quot;RecentBloomFilterFalseRatio&quot;, new Gauge&lt;Double&gt;()</span>
<span class="fc" id="L565">        {</span>
            public Double getValue()
            {
<span class="nc" id="L568">                long falseCount = 0L;</span>
<span class="nc" id="L569">                long trueCount = 0L;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                for (SSTableReader sstable: cfs.getSSTables(SSTableSet.LIVE))</span>
                {
<span class="nc" id="L572">                    falseCount += sstable.getRecentBloomFilterFalsePositiveCount();</span>
<span class="nc" id="L573">                    trueCount += sstable.getRecentBloomFilterTruePositiveCount();</span>
<span class="nc" id="L574">                }</span>
<span class="nc bnc" id="L575" title="All 4 branches missed.">                if (falseCount == 0L &amp;&amp; trueCount == 0L)</span>
<span class="nc" id="L576">                    return 0d;</span>
<span class="nc" id="L577">                return (double) falseCount / (trueCount + falseCount);</span>
            }
        }, new Gauge&lt;Double&gt;() // global gauge
<span class="fc" id="L580">        {</span>
            public Double getValue()
            {
<span class="nc" id="L583">                long falseCount = 0L;</span>
<span class="nc" id="L584">                long trueCount = 0L;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                for (Keyspace keyspace : Keyspace.all())</span>
                {
<span class="nc bnc" id="L587" title="All 2 branches missed.">                    for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.LIVE))</span>
                    {
<span class="nc" id="L589">                        falseCount += sstable.getRecentBloomFilterFalsePositiveCount();</span>
<span class="nc" id="L590">                        trueCount += sstable.getRecentBloomFilterTruePositiveCount();</span>
<span class="nc" id="L591">                    }</span>
<span class="nc" id="L592">                }</span>
<span class="nc bnc" id="L593" title="All 4 branches missed.">                if (falseCount == 0L &amp;&amp; trueCount == 0L)</span>
<span class="nc" id="L594">                    return 0d;</span>
<span class="nc" id="L595">                return (double) falseCount / (trueCount + falseCount);</span>
            }
        });
<span class="fc" id="L598">        bloomFilterDiskSpaceUsed = createTableGauge(&quot;BloomFilterDiskSpaceUsed&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L599">        {</span>
            public Long getValue()
            {
<span class="nc" id="L602">                long total = 0;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                for (SSTableReader sst : cfs.getSSTables(SSTableSet.CANONICAL))</span>
<span class="nc" id="L604">                    total += sst.getBloomFilterSerializedSize();</span>
<span class="nc" id="L605">                return total;</span>
            }
        });
<span class="fc" id="L608">        bloomFilterOffHeapMemoryUsed = createTableGauge(&quot;BloomFilterOffHeapMemoryUsed&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L609">        {</span>
            public Long getValue()
            {
<span class="nc" id="L612">                long total = 0;</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))</span>
<span class="nc" id="L614">                    total += sst.getBloomFilterOffHeapSize();</span>
<span class="nc" id="L615">                return total;</span>
            }
        });
<span class="fc" id="L618">        indexSummaryOffHeapMemoryUsed = createTableGauge(&quot;IndexSummaryOffHeapMemoryUsed&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L619">        {</span>
            public Long getValue()
            {
<span class="nc" id="L622">                long total = 0;</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">                for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))</span>
<span class="nc" id="L624">                    total += sst.getIndexSummaryOffHeapSize();</span>
<span class="nc" id="L625">                return total;</span>
            }
        });
<span class="fc" id="L628">        compressionMetadataOffHeapMemoryUsed = createTableGauge(&quot;CompressionMetadataOffHeapMemoryUsed&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L629">        {</span>
            public Long getValue()
            {
<span class="nc" id="L632">                long total = 0;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))</span>
<span class="nc" id="L634">                    total += sst.getCompressionMetadataOffHeapSize();</span>
<span class="nc" id="L635">                return total;</span>
            }
        });
<span class="fc" id="L638">        speculativeRetries = createTableCounter(&quot;SpeculativeRetries&quot;);</span>
<span class="fc" id="L639">        keyCacheHitRate = Metrics.register(factory.createMetricName(&quot;KeyCacheHitRate&quot;),</span>
<span class="fc" id="L640">                                           aliasFactory.createMetricName(&quot;KeyCacheHitRate&quot;),</span>
                                           new RatioGauge()
<span class="fc" id="L642">        {</span>
            @Override
            public Ratio getRatio()
            {
<span class="nc" id="L646">                return Ratio.of(getNumerator(), getDenominator());</span>
            }

            protected double getNumerator()
            {
<span class="nc" id="L651">                long hits = 0L;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))</span>
<span class="nc" id="L653">                    hits += sstable.getKeyCacheHit();</span>
<span class="nc" id="L654">                return hits;</span>
            }

            protected double getDenominator()
            {
<span class="nc" id="L659">                long requests = 0L;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.LIVE))</span>
<span class="nc" id="L661">                    requests += sstable.getKeyCacheRequest();</span>
<span class="nc" id="L662">                return Math.max(requests, 1); // to avoid NaN.</span>
            }
        });
<span class="fc" id="L665">        tombstoneScannedHistogram = createTableHistogram(&quot;TombstoneScannedHistogram&quot;, cfs.keyspace.metric.tombstoneScannedHistogram, false);</span>
<span class="fc" id="L666">        liveScannedHistogram = createTableHistogram(&quot;LiveScannedHistogram&quot;, cfs.keyspace.metric.liveScannedHistogram, false);</span>
<span class="fc" id="L667">        colUpdateTimeDeltaHistogram = createTableHistogram(&quot;ColUpdateTimeDeltaHistogram&quot;, cfs.keyspace.metric.colUpdateTimeDeltaHistogram, false);</span>
<span class="fc" id="L668">        coordinatorReadLatency = Metrics.timer(factory.createMetricName(&quot;CoordinatorReadLatency&quot;));</span>
<span class="fc" id="L669">        coordinatorScanLatency = Metrics.timer(factory.createMetricName(&quot;CoordinatorScanLatency&quot;));</span>
<span class="fc" id="L670">        waitingOnFreeMemtableSpace = Metrics.histogram(factory.createMetricName(&quot;WaitingOnFreeMemtableSpace&quot;), false);</span>

        // We do not want to capture view mutation specific metrics for a view
        // They only makes sense to capture on the base table
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">        if (cfs.metadata.isView())</span>
        {
<span class="nc" id="L676">            viewLockAcquireTime = null;</span>
<span class="nc" id="L677">            viewReadTime = null;</span>
        }
        else
        {
<span class="fc" id="L681">            viewLockAcquireTime = createTableTimer(&quot;ViewLockAcquireTime&quot;, cfs.keyspace.metric.viewLockAcquireTime);</span>
<span class="fc" id="L682">            viewReadTime = createTableTimer(&quot;ViewReadTime&quot;, cfs.keyspace.metric.viewReadTime);</span>
        }

<span class="fc" id="L685">        trueSnapshotsSize = createTableGauge(&quot;SnapshotsSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L686">        {</span>
            public Long getValue()
            {
<span class="nc" id="L689">                return cfs.trueSnapshotsSize();</span>
            }
        });
<span class="fc" id="L692">        rowCacheHitOutOfRange = createTableCounter(&quot;RowCacheHitOutOfRange&quot;);</span>
<span class="fc" id="L693">        rowCacheHit = createTableCounter(&quot;RowCacheHit&quot;);</span>
<span class="fc" id="L694">        rowCacheMiss = createTableCounter(&quot;RowCacheMiss&quot;);</span>
<span class="fc" id="L695">        droppedMutations = createTableCounter(&quot;DroppedMutations&quot;);</span>

<span class="fc" id="L697">        casPrepare = new LatencyMetrics(factory, &quot;CasPrepare&quot;, cfs.keyspace.metric.casPrepare);</span>
<span class="fc" id="L698">        casPropose = new LatencyMetrics(factory, &quot;CasPropose&quot;, cfs.keyspace.metric.casPropose);</span>
<span class="fc" id="L699">        casCommit = new LatencyMetrics(factory, &quot;CasCommit&quot;, cfs.keyspace.metric.casCommit);</span>

<span class="fc" id="L701">        readRepairRequests = Metrics.meter(factory.createMetricName(&quot;ReadRepairRequests&quot;));</span>
<span class="fc" id="L702">        shortReadProtectionRequests = Metrics.meter(factory.createMetricName(&quot;ShortReadProtectionRequests&quot;));</span>
<span class="fc" id="L703">    }</span>

    public void updateSSTableIterated(int count)
    {
<span class="fc" id="L707">        sstablesPerReadHistogram.update(count);</span>
<span class="fc" id="L708">    }</span>

    /**
     * Release all associated metrics.
     */
    public void release()
    {
<span class="fc bfc" id="L715" title="All 2 branches covered.">        for(Map.Entry&lt;String, String&gt; entry : all.entrySet())</span>
        {
<span class="fc" id="L717">            CassandraMetricsRegistry.MetricName name = factory.createMetricName(entry.getKey());</span>
<span class="fc" id="L718">            CassandraMetricsRegistry.MetricName alias = aliasFactory.createMetricName(entry.getValue());</span>
<span class="fc" id="L719">            final Metric metric = Metrics.getMetrics().get(name.getMetricName());</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">            if (metric != null)</span>
            {   // Metric will be null if it's a view metric we are releasing. Views have null for ViewLockAcquireTime and ViewLockReadTime
<span class="fc" id="L722">                allTableMetrics.get(entry.getKey()).remove(metric);</span>
<span class="fc" id="L723">                Metrics.remove(name, alias);</span>
            }
<span class="fc" id="L725">        }</span>
<span class="fc" id="L726">        readLatency.release();</span>
<span class="fc" id="L727">        writeLatency.release();</span>
<span class="fc" id="L728">        rangeLatency.release();</span>
<span class="fc" id="L729">        Metrics.remove(factory.createMetricName(&quot;EstimatedPartitionSizeHistogram&quot;), aliasFactory.createMetricName(&quot;EstimatedRowSizeHistogram&quot;));</span>
<span class="fc" id="L730">        Metrics.remove(factory.createMetricName(&quot;EstimatedPartitionCount&quot;), aliasFactory.createMetricName(&quot;EstimatedRowCount&quot;));</span>
<span class="fc" id="L731">        Metrics.remove(factory.createMetricName(&quot;EstimatedColumnCountHistogram&quot;), aliasFactory.createMetricName(&quot;EstimatedColumnCountHistogram&quot;));</span>
<span class="fc" id="L732">        Metrics.remove(factory.createMetricName(&quot;KeyCacheHitRate&quot;), aliasFactory.createMetricName(&quot;KeyCacheHitRate&quot;));</span>
<span class="fc" id="L733">        Metrics.remove(factory.createMetricName(&quot;CoordinatorReadLatency&quot;), aliasFactory.createMetricName(&quot;CoordinatorReadLatency&quot;));</span>
<span class="fc" id="L734">        Metrics.remove(factory.createMetricName(&quot;CoordinatorScanLatency&quot;), aliasFactory.createMetricName(&quot;CoordinatorScanLatency&quot;));</span>
<span class="fc" id="L735">        Metrics.remove(factory.createMetricName(&quot;WaitingOnFreeMemtableSpace&quot;), aliasFactory.createMetricName(&quot;WaitingOnFreeMemtableSpace&quot;));</span>
<span class="fc" id="L736">    }</span>


    /**
     * Create a gauge that will be part of a merged version of all column families.  The global gauge
     * will merge each CF gauge by adding their values
     */
    protected &lt;T extends Number&gt; Gauge&lt;T&gt; createTableGauge(final String name, Gauge&lt;T&gt; gauge)
    {
<span class="fc" id="L745">        return createTableGauge(name, gauge, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L746">        {</span>
            public Long getValue()
            {
<span class="nc" id="L749">                long total = 0;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">                for (Metric cfGauge : allTableMetrics.get(name))</span>
                {
<span class="nc" id="L752">                    total = total + ((Gauge&lt;? extends Number&gt;) cfGauge).getValue().longValue();</span>
<span class="nc" id="L753">                }</span>
<span class="nc" id="L754">                return total;</span>
            }
        });
    }

    /**
     * Create a gauge that will be part of a merged version of all column families.  The global gauge
     * is defined as the globalGauge parameter
     */
    protected &lt;G,T&gt; Gauge&lt;T&gt; createTableGauge(String name, Gauge&lt;T&gt; gauge, Gauge&lt;G&gt; globalGauge)
    {
<span class="fc" id="L765">        return createTableGauge(name, name, gauge, globalGauge);</span>
    }

    protected &lt;G,T&gt; Gauge&lt;T&gt; createTableGauge(String name, String alias, Gauge&lt;T&gt; gauge, Gauge&lt;G&gt; globalGauge)
    {
<span class="fc" id="L770">        Gauge&lt;T&gt; cfGauge = Metrics.register(factory.createMetricName(name), aliasFactory.createMetricName(alias), gauge);</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">        if (register(name, alias, cfGauge))</span>
        {
<span class="fc" id="L773">            Metrics.register(globalFactory.createMetricName(name), globalAliasFactory.createMetricName(alias), globalGauge);</span>
        }
<span class="fc" id="L775">        return cfGauge;</span>
    }

    /**
     * Creates a counter that will also have a global counter thats the sum of all counters across
     * different column families
     */
    protected Counter createTableCounter(final String name)
    {
<span class="fc" id="L784">        return createTableCounter(name, name);</span>
    }

    protected Counter createTableCounter(final String name, final String alias)
    {
<span class="fc" id="L789">        Counter cfCounter = Metrics.counter(factory.createMetricName(name), aliasFactory.createMetricName(alias));</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">        if (register(name, alias, cfCounter))</span>
        {
<span class="fc" id="L792">            Metrics.register(globalFactory.createMetricName(name),</span>
<span class="fc" id="L793">                             globalAliasFactory.createMetricName(alias),</span>
                             new Gauge&lt;Long&gt;()
<span class="fc" id="L795">            {</span>
                public Long getValue()
                {
<span class="nc" id="L798">                    long total = 0;</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                    for (Metric cfGauge : allTableMetrics.get(name))</span>
                    {
<span class="nc" id="L801">                        total += ((Counter) cfGauge).getCount();</span>
<span class="nc" id="L802">                    }</span>
<span class="nc" id="L803">                    return total;</span>
                }
            });
        }
<span class="fc" id="L807">        return cfCounter;</span>
    }

    /**
     * Computes the compression ratio for the specified SSTables
     *
     * @param sstables the SSTables
     * @return the compression ratio for the specified SSTables
     */
    private static Double computeCompressionRatio(Iterable&lt;SSTableReader&gt; sstables)
    {
<span class="nc" id="L818">        double compressedLengthSum = 0;</span>
<span class="nc" id="L819">        double dataLengthSum = 0;</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">        for (SSTableReader sstable : sstables)</span>
        {
<span class="nc bnc" id="L822" title="All 2 branches missed.">            if (sstable.compression)</span>
            {
                // We should not have any sstable which are in an open early mode as the sstable were selected
                // using SSTableSet.CANONICAL.
<span class="nc bnc" id="L826" title="All 4 branches missed.">                assert sstable.openReason != SSTableReader.OpenReason.EARLY;</span>

<span class="nc" id="L828">                CompressionMetadata compressionMetadata = sstable.getCompressionMetadata();</span>
<span class="nc" id="L829">                compressedLengthSum += compressionMetadata.compressedFileLength;</span>
<span class="nc" id="L830">                dataLengthSum += compressionMetadata.dataLength;</span>
            }
<span class="nc" id="L832">        }</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        return dataLengthSum != 0 ? compressedLengthSum / dataLengthSum : MetadataCollector.NO_COMPRESSION_RATIO;</span>
    }

    /**
     * Create a histogram-like interface that will register both a CF, keyspace and global level
     * histogram and forward any updates to both
     */
    protected TableHistogram createTableHistogram(String name, Histogram keyspaceHistogram, boolean considerZeroes)
    {
<span class="fc" id="L842">        return createTableHistogram(name, name, keyspaceHistogram, considerZeroes);</span>
    }

    protected TableHistogram createTableHistogram(String name, String alias, Histogram keyspaceHistogram, boolean considerZeroes)
    {
<span class="fc" id="L847">        Histogram cfHistogram = Metrics.histogram(factory.createMetricName(name), aliasFactory.createMetricName(alias), considerZeroes);</span>
<span class="fc" id="L848">        register(name, alias, cfHistogram);</span>
<span class="fc" id="L849">        return new TableHistogram(cfHistogram,</span>
                                  keyspaceHistogram,
<span class="fc" id="L851">                                  Metrics.histogram(globalFactory.createMetricName(name),</span>
<span class="fc" id="L852">                                                    globalAliasFactory.createMetricName(alias),</span>
                                                    considerZeroes));
    }

    protected TableTimer createTableTimer(String name, Timer keyspaceTimer)
    {
<span class="fc" id="L858">        return createTableTimer(name, name, keyspaceTimer);</span>
    }

    protected TableTimer createTableTimer(String name, String alias, Timer keyspaceTimer)
    {
<span class="fc" id="L863">        Timer cfTimer = Metrics.timer(factory.createMetricName(name), aliasFactory.createMetricName(alias));</span>
<span class="fc" id="L864">        register(name, alias, cfTimer);</span>
<span class="fc" id="L865">        return new TableTimer(cfTimer,</span>
                              keyspaceTimer,
<span class="fc" id="L867">                              Metrics.timer(globalFactory.createMetricName(name),</span>
<span class="fc" id="L868">                                            globalAliasFactory.createMetricName(alias)));</span>
    }

    /**
     * Registers a metric to be removed when unloading CF.
     * @return true if first time metric with that name has been registered
     */
    private boolean register(String name, String alias, Metric metric)
    {
<span class="fc bfc" id="L877" title="All 2 branches covered.">        boolean ret = allTableMetrics.putIfAbsent(name, ConcurrentHashMap.newKeySet()) == null;</span>
<span class="fc" id="L878">        allTableMetrics.get(name).add(metric);</span>
<span class="fc" id="L879">        all.put(name, alias);</span>
<span class="fc" id="L880">        return ret;</span>
    }

    public static class TableHistogram
    {
        public final Histogram[] all;
        public final Histogram cf;
        private TableHistogram(Histogram cf, Histogram keyspace, Histogram global)
<span class="fc" id="L888">        {</span>
<span class="fc" id="L889">            this.cf = cf;</span>
<span class="fc" id="L890">            this.all = new Histogram[]{cf, keyspace, global};</span>
<span class="fc" id="L891">        }</span>

        public void update(long i)
        {
<span class="fc bfc" id="L895" title="All 2 branches covered.">            for(Histogram histo : all)</span>
            {
<span class="fc" id="L897">                histo.update(i);</span>
            }
<span class="fc" id="L899">        }</span>
    }

    public static class TableTimer
    {
        public final Timer[] all;
        public final Timer cf;
        private TableTimer(Timer cf, Timer keyspace, Timer global)
<span class="fc" id="L907">        {</span>
<span class="fc" id="L908">            this.cf = cf;</span>
<span class="fc" id="L909">            this.all = new Timer[]{cf, keyspace, global};</span>
<span class="fc" id="L910">        }</span>

        public void update(long i, TimeUnit unit)
        {
<span class="nc bnc" id="L914" title="All 2 branches missed.">            for(Timer timer : all)</span>
            {
<span class="nc" id="L916">                timer.update(i, unit);</span>
            }
<span class="nc" id="L918">        }</span>
    }

    static class TableMetricNameFactory implements MetricNameFactory
    {
        private final String keyspaceName;
        private final String tableName;
        private final boolean isIndex;
        private final String type;

        TableMetricNameFactory(ColumnFamilyStore cfs, String type)
<span class="fc" id="L929">        {</span>
<span class="fc" id="L930">            this.keyspaceName = cfs.keyspace.getName();</span>
<span class="fc" id="L931">            this.tableName = cfs.name;</span>
<span class="fc" id="L932">            this.isIndex = cfs.isIndex();</span>
<span class="fc" id="L933">            this.type = type;</span>
<span class="fc" id="L934">        }</span>

        public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
        {
<span class="fc" id="L938">            String groupName = TableMetrics.class.getPackage().getName();</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">            String type = isIndex ? &quot;Index&quot; + this.type : this.type;</span>

<span class="fc" id="L941">            StringBuilder mbeanName = new StringBuilder();</span>
<span class="fc" id="L942">            mbeanName.append(groupName).append(&quot;:&quot;);</span>
<span class="fc" id="L943">            mbeanName.append(&quot;type=&quot;).append(type);</span>
<span class="fc" id="L944">            mbeanName.append(&quot;,keyspace=&quot;).append(keyspaceName);</span>
<span class="fc" id="L945">            mbeanName.append(&quot;,scope=&quot;).append(tableName);</span>
<span class="fc" id="L946">            mbeanName.append(&quot;,name=&quot;).append(metricName);</span>

<span class="fc" id="L948">            return new CassandraMetricsRegistry.MetricName(groupName, type, metricName, keyspaceName + &quot;.&quot; + tableName, mbeanName.toString());</span>
        }
    }

    static class AllTableMetricNameFactory implements MetricNameFactory
    {
        private final String type;
        public AllTableMetricNameFactory(String type)
<span class="fc" id="L956">        {</span>
<span class="fc" id="L957">            this.type = type;</span>
<span class="fc" id="L958">        }</span>

        public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
        {
<span class="fc" id="L962">            String groupName = TableMetrics.class.getPackage().getName();</span>
<span class="fc" id="L963">            StringBuilder mbeanName = new StringBuilder();</span>
<span class="fc" id="L964">            mbeanName.append(groupName).append(&quot;:&quot;);</span>
<span class="fc" id="L965">            mbeanName.append(&quot;type=&quot;).append(type);</span>
<span class="fc" id="L966">            mbeanName.append(&quot;,name=&quot;).append(metricName);</span>
<span class="fc" id="L967">            return new CassandraMetricsRegistry.MetricName(groupName, type, metricName, &quot;all&quot;, mbeanName.toString());</span>
        }
    }

<span class="fc" id="L971">    public enum Sampler</span>
    {
<span class="fc" id="L973">        READS, WRITES</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>