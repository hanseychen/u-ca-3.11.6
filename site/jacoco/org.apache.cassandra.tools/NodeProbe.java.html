<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NodeProbe.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.tools</a> &gt; <span class="el_source">NodeProbe.java</span></div><h1>NodeProbe.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.tools;

import java.io.IOException;
import java.io.PrintStream;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;
import java.lang.management.RuntimeMXBean;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.rmi.ConnectException;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMISocketFactory;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.management.JMX;
import javax.management.MBeanServerConnection;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import javax.management.openmbean.CompositeData;
import javax.management.openmbean.OpenDataException;
import javax.management.openmbean.TabularData;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;
import javax.rmi.ssl.SslRMIClientSocketFactory;

import org.apache.cassandra.batchlog.BatchlogManager;
import org.apache.cassandra.batchlog.BatchlogManagerMBean;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStoreMBean;
import org.apache.cassandra.db.HintedHandOffManagerMBean;
import org.apache.cassandra.db.compaction.CompactionManager;
import org.apache.cassandra.db.compaction.CompactionManagerMBean;
import org.apache.cassandra.gms.FailureDetector;
import org.apache.cassandra.gms.FailureDetectorMBean;
import org.apache.cassandra.gms.Gossiper;
import org.apache.cassandra.gms.GossiperMBean;
import org.apache.cassandra.db.HintedHandOffManager;
import org.apache.cassandra.locator.DynamicEndpointSnitchMBean;
import org.apache.cassandra.locator.EndpointSnitchInfoMBean;
import org.apache.cassandra.metrics.CassandraMetricsRegistry;
import org.apache.cassandra.metrics.TableMetrics.Sampler;
import org.apache.cassandra.metrics.StorageMetrics;
import org.apache.cassandra.metrics.TableMetrics;
import org.apache.cassandra.metrics.ThreadPoolMetrics;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.net.MessagingServiceMBean;
import org.apache.cassandra.schema.CompactionParams.TombstoneOption;
import org.apache.cassandra.service.CacheService;
import org.apache.cassandra.service.CacheServiceMBean;
import org.apache.cassandra.service.GCInspector;
import org.apache.cassandra.service.GCInspectorMXBean;
import org.apache.cassandra.service.StorageProxy;
import org.apache.cassandra.service.StorageProxyMBean;
import org.apache.cassandra.service.StorageServiceMBean;
import org.apache.cassandra.streaming.StreamManagerMBean;
import org.apache.cassandra.streaming.StreamState;
import org.apache.cassandra.streaming.management.StreamStateCompositeData;

import com.google.common.base.Function;
import com.google.common.base.Strings;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.Uninterruptibles;
import org.apache.cassandra.tools.nodetool.GetTimeout;

/**
 * JMX client operations for Cassandra.
 */
<span class="nc bnc" id="L102" title="All 2 branches missed.">public class NodeProbe implements AutoCloseable</span>
{
    private static final String fmtUrl = &quot;service:jmx:rmi:///jndi/rmi://[%s]:%d/jmxrmi&quot;;
    private static final String ssObjName = &quot;org.apache.cassandra.db:type=StorageService&quot;;
    private static final int defaultPort = 7199;
    final String host;
    final int port;
    private String username;
    private String password;

    protected JMXConnector jmxc;
    protected MBeanServerConnection mbeanServerConn;
    protected CompactionManagerMBean compactionProxy;
    protected StorageServiceMBean ssProxy;
    protected GossiperMBean gossProxy;
    protected MemoryMXBean memProxy;
    protected GCInspectorMXBean gcProxy;
    protected RuntimeMXBean runtimeProxy;
    protected StreamManagerMBean streamProxy;
    protected MessagingServiceMBean msProxy;
    protected FailureDetectorMBean fdProxy;
    protected CacheServiceMBean cacheService;
    protected StorageProxyMBean spProxy;
    protected HintedHandOffManagerMBean hhProxy;
    protected BatchlogManagerMBean bmProxy;
    private boolean failed;

    /**
     * Creates a NodeProbe using the specified JMX host, port, username, and password.
     *
     * @param host hostname or IP address of the JMX agent
     * @param port TCP port of the remote JMX agent
     * @throws IOException on connection failures
     */
    public NodeProbe(String host, int port, String username, String password) throws IOException
<span class="nc" id="L137">    {</span>
<span class="nc bnc" id="L138" title="All 10 branches missed.">        assert username != null &amp;&amp; !username.isEmpty() &amp;&amp; password != null &amp;&amp; !password.isEmpty()</span>
               : &quot;neither username nor password can be blank&quot;;

<span class="nc" id="L141">        this.host = host;</span>
<span class="nc" id="L142">        this.port = port;</span>
<span class="nc" id="L143">        this.username = username;</span>
<span class="nc" id="L144">        this.password = password;</span>
<span class="nc" id="L145">        connect();</span>
<span class="nc" id="L146">    }</span>

    /**
     * Creates a NodeProbe using the specified JMX host and port.
     *
     * @param host hostname or IP address of the JMX agent
     * @param port TCP port of the remote JMX agent
     * @throws IOException on connection failures
     */
    public NodeProbe(String host, int port) throws IOException
<span class="nc" id="L156">    {</span>
<span class="nc" id="L157">        this.host = host;</span>
<span class="nc" id="L158">        this.port = port;</span>
<span class="nc" id="L159">        connect();</span>
<span class="nc" id="L160">    }</span>

    /**
     * Creates a NodeProbe using the specified JMX host and default port.
     *
     * @param host hostname or IP address of the JMX agent
     * @throws IOException on connection failures
     */
    public NodeProbe(String host) throws IOException
<span class="nc" id="L169">    {</span>
<span class="nc" id="L170">        this.host = host;</span>
<span class="nc" id="L171">        this.port = defaultPort;</span>
<span class="nc" id="L172">        connect();</span>
<span class="nc" id="L173">    }</span>

    /**
     * Create a connection to the JMX agent and setup the M[X]Bean proxies.
     *
     * @throws IOException on connection failures
     */
    protected void connect() throws IOException
    {
<span class="nc" id="L182">        JMXServiceURL jmxUrl = new JMXServiceURL(String.format(fmtUrl, host, port));</span>
<span class="nc" id="L183">        Map&lt;String,Object&gt; env = new HashMap&lt;String,Object&gt;();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (username != null)</span>
        {
<span class="nc" id="L186">            String[] creds = { username, password };</span>
<span class="nc" id="L187">            env.put(JMXConnector.CREDENTIALS, creds);</span>
        }

<span class="nc" id="L190">        env.put(&quot;com.sun.jndi.rmi.factory.socket&quot;, getRMIClientSocketFactory());</span>

<span class="nc" id="L192">        jmxc = JMXConnectorFactory.connect(jmxUrl, env);</span>
<span class="nc" id="L193">        mbeanServerConn = jmxc.getMBeanServerConnection();</span>

        try
        {
<span class="nc" id="L197">            ObjectName name = new ObjectName(ssObjName);</span>
<span class="nc" id="L198">            ssProxy = JMX.newMBeanProxy(mbeanServerConn, name, StorageServiceMBean.class);</span>
<span class="nc" id="L199">            name = new ObjectName(MessagingService.MBEAN_NAME);</span>
<span class="nc" id="L200">            msProxy = JMX.newMBeanProxy(mbeanServerConn, name, MessagingServiceMBean.class);</span>
<span class="nc" id="L201">            name = new ObjectName(StreamManagerMBean.OBJECT_NAME);</span>
<span class="nc" id="L202">            streamProxy = JMX.newMBeanProxy(mbeanServerConn, name, StreamManagerMBean.class);</span>
<span class="nc" id="L203">            name = new ObjectName(CompactionManager.MBEAN_OBJECT_NAME);</span>
<span class="nc" id="L204">            compactionProxy = JMX.newMBeanProxy(mbeanServerConn, name, CompactionManagerMBean.class);</span>
<span class="nc" id="L205">            name = new ObjectName(FailureDetector.MBEAN_NAME);</span>
<span class="nc" id="L206">            fdProxy = JMX.newMBeanProxy(mbeanServerConn, name, FailureDetectorMBean.class);</span>
<span class="nc" id="L207">            name = new ObjectName(CacheService.MBEAN_NAME);</span>
<span class="nc" id="L208">            cacheService = JMX.newMBeanProxy(mbeanServerConn, name, CacheServiceMBean.class);</span>
<span class="nc" id="L209">            name = new ObjectName(StorageProxy.MBEAN_NAME);</span>
<span class="nc" id="L210">            spProxy = JMX.newMBeanProxy(mbeanServerConn, name, StorageProxyMBean.class);</span>
<span class="nc" id="L211">            name = new ObjectName(HintedHandOffManager.MBEAN_NAME);</span>
<span class="nc" id="L212">            hhProxy = JMX.newMBeanProxy(mbeanServerConn, name, HintedHandOffManagerMBean.class);</span>
<span class="nc" id="L213">            name = new ObjectName(GCInspector.MBEAN_NAME);</span>
<span class="nc" id="L214">            gcProxy = JMX.newMBeanProxy(mbeanServerConn, name, GCInspectorMXBean.class);</span>
<span class="nc" id="L215">            name = new ObjectName(Gossiper.MBEAN_NAME);</span>
<span class="nc" id="L216">            gossProxy = JMX.newMBeanProxy(mbeanServerConn, name, GossiperMBean.class);</span>
<span class="nc" id="L217">            name = new ObjectName(BatchlogManager.MBEAN_NAME);</span>
<span class="nc" id="L218">            bmProxy = JMX.newMBeanProxy(mbeanServerConn, name, BatchlogManagerMBean.class);</span>
        }
<span class="nc" id="L220">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L222">            throw new RuntimeException(</span>
                    &quot;Invalid ObjectName? Please report this as a bug.&quot;, e);
<span class="nc" id="L224">        }</span>

<span class="nc" id="L226">        memProxy = ManagementFactory.newPlatformMXBeanProxy(mbeanServerConn,</span>
                ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);
<span class="nc" id="L228">        runtimeProxy = ManagementFactory.newPlatformMXBeanProxy(</span>
                mbeanServerConn, ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);
<span class="nc" id="L230">    }</span>

    private RMIClientSocketFactory getRMIClientSocketFactory()
    {
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (Boolean.parseBoolean(System.getProperty(&quot;ssl.enable&quot;)))</span>
<span class="nc" id="L235">            return new SslRMIClientSocketFactory();</span>
        else
<span class="nc" id="L237">            return RMISocketFactory.getDefaultSocketFactory();</span>
    }

    public void close() throws IOException
    {
        try
        {
<span class="nc" id="L244">            jmxc.close();</span>
        }
<span class="nc" id="L246">        catch (ConnectException e)</span>
        {
            // result of 'stopdaemon' command - i.e. if close() call fails, the daemon is shutdown
<span class="nc" id="L249">            System.out.println(&quot;Cassandra has shutdown.&quot;);</span>
<span class="nc" id="L250">        }</span>
<span class="nc" id="L251">    }</span>

    public int forceKeyspaceCleanup(int jobs, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L255">        return ssProxy.forceKeyspaceCleanup(jobs, keyspaceName, tables);</span>
    }

    public int scrub(boolean disableSnapshot, boolean skipCorrupted, boolean checkData, boolean reinsertOverflowedTTL, int jobs, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L260">        return ssProxy.scrub(disableSnapshot, skipCorrupted, checkData, reinsertOverflowedTTL, jobs, keyspaceName, tables);</span>
    }

    public int verify(boolean extendedVerify, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L265">        return ssProxy.verify(extendedVerify, keyspaceName, tableNames);</span>
    }

    public int upgradeSSTables(String keyspaceName, boolean excludeCurrentVersion, int jobs, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L270">        return ssProxy.upgradeSSTables(keyspaceName, excludeCurrentVersion, jobs, tableNames);</span>
    }

    public int garbageCollect(String tombstoneOption, int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L275">        return ssProxy.garbageCollect(tombstoneOption, jobs, keyspaceName, tableNames);</span>
    }

    private void checkJobs(PrintStream out, int jobs)
    {
        // TODO this should get the configured number of concurrent_compactors via JMX and not using DatabaseDescriptor
<span class="nc" id="L281">        DatabaseDescriptor.toolInitialization();</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (jobs &gt; DatabaseDescriptor.getConcurrentCompactors())</span>
<span class="nc" id="L283">            out.println(String.format(&quot;jobs (%d) is bigger than configured concurrent_compactors (%d) on this host, using at most %d threads&quot;, jobs, DatabaseDescriptor.getConcurrentCompactors(), DatabaseDescriptor.getConcurrentCompactors()));</span>
<span class="nc" id="L284">    }</span>

    public void forceKeyspaceCleanup(PrintStream out, int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L288">        checkJobs(out, jobs);</span>
<span class="nc bnc" id="L289" title="All 3 branches missed.">        switch (forceKeyspaceCleanup(jobs, keyspaceName, tableNames))</span>
        {
            case 1:
<span class="nc" id="L292">                failed = true;</span>
<span class="nc" id="L293">                out.println(&quot;Aborted cleaning up at least one table in keyspace &quot;+keyspaceName+&quot;, check server logs for more information.&quot;);</span>
<span class="nc" id="L294">                break;</span>
            case 2:
<span class="nc" id="L296">                failed = true;</span>
<span class="nc" id="L297">                out.println(&quot;Failed marking some sstables compacting in keyspace &quot;+keyspaceName+&quot;, check server logs for more information&quot;);</span>
                break;
        }
<span class="nc" id="L300">    }</span>

    public void scrub(PrintStream out, boolean disableSnapshot, boolean skipCorrupted, boolean checkData, boolean reinsertOverflowedTTL, int jobs, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L304">        checkJobs(out, jobs);</span>
<span class="nc bnc" id="L305" title="All 3 branches missed.">        switch (ssProxy.scrub(disableSnapshot, skipCorrupted, checkData, reinsertOverflowedTTL, jobs, keyspaceName, tables))</span>
        {
            case 1:
<span class="nc" id="L308">                failed = true;</span>
<span class="nc" id="L309">                out.println(&quot;Aborted scrubbing at least one table in keyspace &quot;+keyspaceName+&quot;, check server logs for more information.&quot;);</span>
<span class="nc" id="L310">                break;</span>
            case 2:
<span class="nc" id="L312">                failed = true;</span>
<span class="nc" id="L313">                out.println(&quot;Failed marking some sstables compacting in keyspace &quot;+keyspaceName+&quot;, check server logs for more information&quot;);</span>
                break;
        }
<span class="nc" id="L316">    }</span>

    public void verify(PrintStream out, boolean extendedVerify, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc bnc" id="L320" title="All 3 branches missed.">        switch (verify(extendedVerify, keyspaceName, tableNames))</span>
        {
            case 1:
<span class="nc" id="L323">                failed = true;</span>
<span class="nc" id="L324">                out.println(&quot;Aborted verifying at least one table in keyspace &quot;+keyspaceName+&quot;, check server logs for more information.&quot;);</span>
<span class="nc" id="L325">                break;</span>
            case 2:
<span class="nc" id="L327">                failed = true;</span>
<span class="nc" id="L328">                out.println(&quot;Failed marking some sstables compacting in keyspace &quot;+keyspaceName+&quot;, check server logs for more information&quot;);</span>
                break;
        }
<span class="nc" id="L331">    }</span>


    public void upgradeSSTables(PrintStream out, String keyspaceName, boolean excludeCurrentVersion, int jobs, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L336">        checkJobs(out, jobs);</span>
<span class="nc bnc" id="L337" title="All 3 branches missed.">        switch (upgradeSSTables(keyspaceName, excludeCurrentVersion, jobs, tableNames))</span>
        {
            case 1:
<span class="nc" id="L340">                failed = true;</span>
<span class="nc" id="L341">                out.println(&quot;Aborted upgrading sstables for at least one table in keyspace &quot; + keyspaceName + &quot;, check server logs for more information.&quot;);</span>
<span class="nc" id="L342">                break;</span>
            case 2:
<span class="nc" id="L344">                failed = true;</span>
<span class="nc" id="L345">                out.println(&quot;Failed marking some sstables compacting in keyspace &quot;+keyspaceName+&quot;, check server logs for more information&quot;);</span>
                break;
        }
<span class="nc" id="L348">    }</span>

    public void garbageCollect(PrintStream out, String tombstoneOption, int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (garbageCollect(tombstoneOption, jobs, keyspaceName, tableNames) != 0)</span>
        {
<span class="nc" id="L354">            failed = true;</span>
<span class="nc" id="L355">            out.println(&quot;Aborted garbage collection for at least one table in keyspace &quot; + keyspaceName + &quot;, check server logs for more information.&quot;);</span>
        }
<span class="nc" id="L357">    }</span>

    public void forceUserDefinedCompaction(String datafiles) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L361">        compactionProxy.forceUserDefinedCompaction(datafiles);</span>
<span class="nc" id="L362">    }</span>

    public void forceKeyspaceCompaction(boolean splitOutput, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L366">        ssProxy.forceKeyspaceCompaction(splitOutput, keyspaceName, tableNames);</span>
<span class="nc" id="L367">    }</span>

    public void relocateSSTables(int jobs, String keyspace, String[] cfnames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L371">        ssProxy.relocateSSTables(jobs, keyspace, cfnames);</span>
<span class="nc" id="L372">    }</span>

    public void forceKeyspaceCompactionForTokenRange(String keyspaceName, final String startToken, final String endToken, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L376">        ssProxy.forceKeyspaceCompactionForTokenRange(keyspaceName, startToken, endToken, tableNames);</span>
<span class="nc" id="L377">    }</span>

    public void forceKeyspaceFlush(String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L381">        ssProxy.forceKeyspaceFlush(keyspaceName, tableNames);</span>
<span class="nc" id="L382">    }</span>

    public void repairAsync(final PrintStream out, final String keyspace, Map&lt;String, String&gt; options) throws IOException
    {
<span class="nc" id="L386">        RepairRunner runner = new RepairRunner(out, ssProxy, keyspace, options);</span>
        try
        {
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (jmxc != null)</span>
<span class="nc" id="L390">                jmxc.addConnectionNotificationListener(runner, null, null);</span>
<span class="nc" id="L391">            ssProxy.addNotificationListener(runner, null, null);</span>
<span class="nc" id="L392">            runner.run();</span>
        }
<span class="nc" id="L394">        catch (Exception e)</span>
        {
<span class="nc" id="L396">            throw new IOException(e) ;</span>
        }
        finally
        {
            try
            {
<span class="nc" id="L402">                ssProxy.removeNotificationListener(runner);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                if (jmxc != null)</span>
<span class="nc" id="L404">                    jmxc.removeConnectionNotificationListener(runner);</span>
            }
<span class="nc" id="L406">            catch (Throwable e)</span>
            {
<span class="nc" id="L408">                out.println(&quot;Exception occurred during clean-up. &quot; + e);</span>
<span class="nc" id="L409">            }</span>
        }
<span class="nc" id="L411">    }</span>

    public Map&lt;Sampler, CompositeData&gt; getPartitionSample(String ks, String cf, int capacity, int duration, int count, List&lt;Sampler&gt; samplers) throws OpenDataException
    {
<span class="nc" id="L415">        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(ks, cf);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        for(Sampler sampler : samplers)</span>
        {
<span class="nc" id="L418">            cfsProxy.beginLocalSampling(sampler.name(), capacity);</span>
<span class="nc" id="L419">        }</span>
<span class="nc" id="L420">        Uninterruptibles.sleepUninterruptibly(duration, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L421">        Map&lt;Sampler, CompositeData&gt; result = Maps.newHashMap();</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">        for(Sampler sampler : samplers)</span>
        {
<span class="nc" id="L424">            result.put(sampler, cfsProxy.finishLocalSampling(sampler.name(), count));</span>
<span class="nc" id="L425">        }</span>
<span class="nc" id="L426">        return result;</span>
    }

    public void invalidateCounterCache()
    {
<span class="nc" id="L431">        cacheService.invalidateCounterCache();</span>
<span class="nc" id="L432">    }</span>

    public void invalidateKeyCache()
    {
<span class="nc" id="L436">        cacheService.invalidateKeyCache();</span>
<span class="nc" id="L437">    }</span>

    public void invalidateRowCache()
    {
<span class="nc" id="L441">        cacheService.invalidateRowCache();</span>
<span class="nc" id="L442">    }</span>

    public void drain() throws IOException, InterruptedException, ExecutionException
    {
<span class="nc" id="L446">        ssProxy.drain();</span>
<span class="nc" id="L447">    }</span>

    public Map&lt;String, String&gt; getTokenToEndpointMap()
    {
<span class="nc" id="L451">        return ssProxy.getTokenToEndpointMap();</span>
    }

    public List&lt;String&gt; getLiveNodes()
    {
<span class="nc" id="L456">        return ssProxy.getLiveNodes();</span>
    }

    public List&lt;String&gt; getJoiningNodes()
    {
<span class="nc" id="L461">        return ssProxy.getJoiningNodes();</span>
    }

    public List&lt;String&gt; getLeavingNodes()
    {
<span class="nc" id="L466">        return ssProxy.getLeavingNodes();</span>
    }

    public List&lt;String&gt; getMovingNodes()
    {
<span class="nc" id="L471">        return ssProxy.getMovingNodes();</span>
    }

    public List&lt;String&gt; getUnreachableNodes()
    {
<span class="nc" id="L476">        return ssProxy.getUnreachableNodes();</span>
    }

    public Map&lt;String, String&gt; getLoadMap()
    {
<span class="nc" id="L481">        return ssProxy.getLoadMap();</span>
    }

    public Map&lt;InetAddress, Float&gt; getOwnership()
    {
<span class="nc" id="L486">        return ssProxy.getOwnership();</span>
    }

    public Map&lt;InetAddress, Float&gt; effectiveOwnership(String keyspace) throws IllegalStateException
    {
<span class="nc" id="L491">        return ssProxy.effectiveOwnership(keyspace);</span>
    }

    public CacheServiceMBean getCacheServiceMBean()
    {
<span class="nc" id="L496">        String cachePath = &quot;org.apache.cassandra.db:type=Caches&quot;;</span>

        try
        {
<span class="nc" id="L500">            return JMX.newMBeanProxy(mbeanServerConn, new ObjectName(cachePath), CacheServiceMBean.class);</span>
        }
<span class="nc" id="L502">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L504">            throw new RuntimeException(e);</span>
        }
    }

    public double[] getAndResetGCStats()
    {
<span class="nc" id="L510">        return gcProxy.getAndResetStats();</span>
    }

    public Iterator&lt;Map.Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; getColumnFamilyStoreMBeanProxies()
    {
        try
        {
<span class="nc" id="L517">            return new ColumnFamilyStoreMBeanIterator(mbeanServerConn);</span>
        }
<span class="nc" id="L519">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L521">            throw new RuntimeException(&quot;Invalid ObjectName? Please report this as a bug.&quot;, e);</span>
        }
<span class="nc" id="L523">        catch (IOException e)</span>
        {
<span class="nc" id="L525">            throw new RuntimeException(&quot;Could not retrieve list of stat mbeans.&quot;, e);</span>
        }
    }

    public CompactionManagerMBean getCompactionManagerProxy()
    {
<span class="nc" id="L531">      return compactionProxy;</span>
    }

    public List&lt;String&gt; getTokens()
    {
<span class="nc" id="L536">        return ssProxy.getTokens();</span>
    }

    public List&lt;String&gt; getTokens(String endpoint)
    {
        try
        {
<span class="nc" id="L543">            return ssProxy.getTokens(endpoint);</span>
        }
<span class="nc" id="L545">        catch (UnknownHostException e)</span>
        {
<span class="nc" id="L547">            throw new RuntimeException(e);</span>
        }
    }

    public String getLocalHostId()
    {
<span class="nc" id="L553">        return ssProxy.getLocalHostId();</span>
    }

    public Map&lt;String, String&gt; getHostIdMap()
    {
<span class="nc" id="L558">        return ssProxy.getEndpointToHostId();</span>
    }

    public String getLoadString()
    {
<span class="nc" id="L563">        return ssProxy.getLoadString();</span>
    }

    public String getReleaseVersion()
    {
<span class="nc" id="L568">        return ssProxy.getReleaseVersion();</span>
    }

    public int getCurrentGenerationNumber()
    {
<span class="nc" id="L573">        return ssProxy.getCurrentGenerationNumber();</span>
    }

    public long getUptime()
    {
<span class="nc" id="L578">        return runtimeProxy.getUptime();</span>
    }

    public MemoryUsage getHeapMemoryUsage()
    {
<span class="nc" id="L583">        return memProxy.getHeapMemoryUsage();</span>
    }

    /**
     * Take a snapshot of all the keyspaces, optionally specifying only a specific column family.
     *
     * @param snapshotName the name of the snapshot.
     * @param table the table to snapshot or all on null
     * @param options Options (skipFlush for now)
     * @param keyspaces the keyspaces to snapshot
     */
    public void takeSnapshot(String snapshotName, String table, Map&lt;String, String&gt; options, String... keyspaces) throws IOException
    {
<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (table != null)</span>
        {
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (keyspaces.length != 1)</span>
            {
<span class="nc" id="L600">                throw new IOException(&quot;When specifying the table for a snapshot, you must specify one and only one keyspace&quot;);</span>
            }

<span class="nc" id="L603">            ssProxy.takeSnapshot(snapshotName, options, keyspaces[0] + &quot;.&quot; + table);</span>
        }
        else
<span class="nc" id="L606">            ssProxy.takeSnapshot(snapshotName, options, keyspaces);</span>
<span class="nc" id="L607">    }</span>

    /**
     * Take a snapshot of all column family from different keyspaces.
     *
     * @param snapshotName
     *            the name of the snapshot.
     * @param options
     *            Options (skipFlush for now)
     * @param tableList
     *            list of columnfamily from different keyspace in the form of ks1.cf1 ks2.cf2
     */
    public void takeMultipleTableSnapshot(String snapshotName, Map&lt;String, String&gt; options, String... tableList)
            throws IOException
    {
<span class="nc bnc" id="L622" title="All 4 branches missed.">        if (null != tableList &amp;&amp; tableList.length != 0)</span>
        {
<span class="nc" id="L624">            ssProxy.takeSnapshot(snapshotName, options, tableList);</span>
        }
        else
        {
<span class="nc" id="L628">            throw new IOException(&quot;The column family List  for a snapshot should not be empty or null&quot;);</span>
        }
<span class="nc" id="L630">    }</span>

    /**
     * Remove all the existing snapshots.
     */
    public void clearSnapshot(String tag, String... keyspaces) throws IOException
    {
<span class="nc" id="L637">        ssProxy.clearSnapshot(tag, keyspaces);</span>
<span class="nc" id="L638">    }</span>

    public Map&lt;String, TabularData&gt; getSnapshotDetails()
    {
<span class="nc" id="L642">        return ssProxy.getSnapshotDetails();</span>
    }

    public long trueSnapshotsSize()
    {
<span class="nc" id="L647">        return ssProxy.trueSnapshotsSize();</span>
    }

    public boolean isJoined()
    {
<span class="nc" id="L652">        return ssProxy.isJoined();</span>
    }

    public boolean isDrained()
    {
<span class="nc" id="L657">        return ssProxy.isDrained();</span>
    }

    public boolean isDraining()
    {
<span class="nc" id="L662">        return ssProxy.isDraining();</span>
    }

    public boolean isBootstrapMode()
    {
<span class="nc" id="L667">        return ssProxy.isBootstrapMode();</span>
    }

    public void joinRing() throws IOException
    {
<span class="nc" id="L672">        ssProxy.joinRing();</span>
<span class="nc" id="L673">    }</span>

    public void decommission() throws InterruptedException
    {
<span class="nc" id="L677">        ssProxy.decommission();</span>
<span class="nc" id="L678">    }</span>

    public void move(String newToken) throws IOException
    {
<span class="nc" id="L682">        ssProxy.move(newToken);</span>
<span class="nc" id="L683">    }</span>

    public void removeNode(String token)
    {
<span class="nc" id="L687">        ssProxy.removeNode(token);</span>
<span class="nc" id="L688">    }</span>

    public String getRemovalStatus()
    {
<span class="nc" id="L692">        return ssProxy.getRemovalStatus();</span>
    }

    public void forceRemoveCompletion()
    {
<span class="nc" id="L697">        ssProxy.forceRemoveCompletion();</span>
<span class="nc" id="L698">    }</span>

    public void assassinateEndpoint(String address) throws UnknownHostException
    {
<span class="nc" id="L702">        gossProxy.assassinateEndpoint(address);</span>
<span class="nc" id="L703">    }</span>

    /**
     * Set the compaction threshold
     *
     * @param minimumCompactionThreshold minimum compaction threshold
     * @param maximumCompactionThreshold maximum compaction threshold
     */
    public void setCompactionThreshold(String ks, String cf, int minimumCompactionThreshold, int maximumCompactionThreshold)
    {
<span class="nc" id="L713">        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(ks, cf);</span>
<span class="nc" id="L714">        cfsProxy.setCompactionThresholds(minimumCompactionThreshold, maximumCompactionThreshold);</span>
<span class="nc" id="L715">    }</span>

    public void disableAutoCompaction(String ks, String ... tables) throws IOException
    {
<span class="nc" id="L719">        ssProxy.disableAutoCompaction(ks, tables);</span>
<span class="nc" id="L720">    }</span>

    public void enableAutoCompaction(String ks, String ... tableNames) throws IOException
    {
<span class="nc" id="L724">        ssProxy.enableAutoCompaction(ks, tableNames);</span>
<span class="nc" id="L725">    }</span>

    public void setIncrementalBackupsEnabled(boolean enabled)
    {
<span class="nc" id="L729">        ssProxy.setIncrementalBackupsEnabled(enabled);</span>
<span class="nc" id="L730">    }</span>

    public boolean isIncrementalBackupsEnabled()
    {
<span class="nc" id="L734">        return ssProxy.isIncrementalBackupsEnabled();</span>
    }

    public void setCacheCapacities(int keyCacheCapacity, int rowCacheCapacity, int counterCacheCapacity)
    {
<span class="nc" id="L739">        CacheServiceMBean cacheMBean = getCacheServiceMBean();</span>
<span class="nc" id="L740">        cacheMBean.setKeyCacheCapacityInMB(keyCacheCapacity);</span>
<span class="nc" id="L741">        cacheMBean.setRowCacheCapacityInMB(rowCacheCapacity);</span>
<span class="nc" id="L742">        cacheMBean.setCounterCacheCapacityInMB(counterCacheCapacity);</span>
<span class="nc" id="L743">    }</span>

    public void setCacheKeysToSave(int keyCacheKeysToSave, int rowCacheKeysToSave, int counterCacheKeysToSave)
    {
<span class="nc" id="L747">        CacheServiceMBean cacheMBean = getCacheServiceMBean();</span>
<span class="nc" id="L748">        cacheMBean.setKeyCacheKeysToSave(keyCacheKeysToSave);</span>
<span class="nc" id="L749">        cacheMBean.setRowCacheKeysToSave(rowCacheKeysToSave);</span>
<span class="nc" id="L750">        cacheMBean.setCounterCacheKeysToSave(counterCacheKeysToSave);</span>
<span class="nc" id="L751">    }</span>

    public void setHintedHandoffThrottleInKB(int throttleInKB)
    {
<span class="nc" id="L755">        ssProxy.setHintedHandoffThrottleInKB(throttleInKB);</span>
<span class="nc" id="L756">    }</span>

    public List&lt;InetAddress&gt; getEndpoints(String keyspace, String cf, String key)
    {
<span class="nc" id="L760">        return ssProxy.getNaturalEndpoints(keyspace, cf, key);</span>
    }

    public List&lt;String&gt; getSSTables(String keyspace, String cf, String key, boolean hexFormat)
    {
<span class="nc" id="L765">        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(keyspace, cf);</span>
<span class="nc" id="L766">        return cfsProxy.getSSTablesForKey(key, hexFormat);</span>
    }

    public Set&lt;StreamState&gt; getStreamStatus()
    {
<span class="nc" id="L771">        return Sets.newHashSet(Iterables.transform(streamProxy.getCurrentStreams(), new Function&lt;CompositeData, StreamState&gt;()</span>
<span class="nc" id="L772">        {</span>
            public StreamState apply(CompositeData input)
            {
<span class="nc" id="L775">                return StreamStateCompositeData.fromCompositeData(input);</span>
            }
        }));
    }

    public String getOperationMode()
    {
<span class="nc" id="L782">        return ssProxy.getOperationMode();</span>
    }

    public boolean isStarting()
    {
<span class="nc" id="L787">        return ssProxy.isStarting();</span>
    }

    public void truncate(String keyspaceName, String tableName)
    {
        try
        {
<span class="nc" id="L794">            ssProxy.truncate(keyspaceName, tableName);</span>
        }
<span class="nc" id="L796">        catch (TimeoutException e)</span>
        {
<span class="nc" id="L798">            throw new RuntimeException(&quot;Error while executing truncate&quot;, e);</span>
        }
<span class="nc" id="L800">        catch (IOException e)</span>
        {
<span class="nc" id="L802">            throw new RuntimeException(&quot;Error while executing truncate&quot;, e);</span>
<span class="nc" id="L803">        }</span>
<span class="nc" id="L804">    }</span>

    public EndpointSnitchInfoMBean getEndpointSnitchInfoProxy()
    {
        try
        {
<span class="nc" id="L810">            return JMX.newMBeanProxy(mbeanServerConn, new ObjectName(&quot;org.apache.cassandra.db:type=EndpointSnitchInfo&quot;), EndpointSnitchInfoMBean.class);</span>
        }
<span class="nc" id="L812">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L814">            throw new RuntimeException(e);</span>
        }
    }

    public DynamicEndpointSnitchMBean getDynamicEndpointSnitchInfoProxy()
    {
        try
        {
<span class="nc" id="L822">            return JMX.newMBeanProxy(mbeanServerConn, new ObjectName(&quot;org.apache.cassandra.db:type=DynamicEndpointSnitch&quot;), DynamicEndpointSnitchMBean.class);</span>
        }
<span class="nc" id="L824">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L826">            throw new RuntimeException(e);</span>
        }
    }

    public ColumnFamilyStoreMBean getCfsProxy(String ks, String cf)
    {
<span class="nc" id="L832">        ColumnFamilyStoreMBean cfsProxy = null;</span>
        try
        {
<span class="nc bnc" id="L835" title="All 2 branches missed.">            String type = cf.contains(&quot;.&quot;) ? &quot;IndexColumnFamilies&quot; : &quot;ColumnFamilies&quot;;</span>
<span class="nc" id="L836">            Set&lt;ObjectName&gt; beans = mbeanServerConn.queryNames(</span>
                    new ObjectName(&quot;org.apache.cassandra.db:type=*&quot; + type +&quot;,keyspace=&quot; + ks + &quot;,columnfamily=&quot; + cf), null);

<span class="nc bnc" id="L839" title="All 2 branches missed.">            if (beans.isEmpty())</span>
<span class="nc" id="L840">                throw new MalformedObjectNameException(&quot;couldn't find that bean&quot;);</span>
<span class="nc bnc" id="L841" title="All 4 branches missed.">            assert beans.size() == 1;</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">            for (ObjectName bean : beans)</span>
<span class="nc" id="L843">                cfsProxy = JMX.newMBeanProxy(mbeanServerConn, bean, ColumnFamilyStoreMBean.class);</span>
        }
<span class="nc" id="L845">        catch (MalformedObjectNameException mone)</span>
        {
<span class="nc" id="L847">            System.err.println(&quot;ColumnFamilyStore for &quot; + ks + &quot;/&quot; + cf + &quot; not found.&quot;);</span>
<span class="nc" id="L848">            System.exit(1);</span>
        }
<span class="nc" id="L850">        catch (IOException e)</span>
        {
<span class="nc" id="L852">            System.err.println(&quot;ColumnFamilyStore for &quot; + ks + &quot;/&quot; + cf + &quot; not found: &quot; + e);</span>
<span class="nc" id="L853">            System.exit(1);</span>
<span class="nc" id="L854">        }</span>

<span class="nc" id="L856">        return cfsProxy;</span>
    }

    public StorageProxyMBean getSpProxy()
    {
<span class="nc" id="L861">        return spProxy;</span>
    }

    public MessagingServiceMBean getMessagingServiceProxy()
    {
<span class="nc" id="L866">        return msProxy;</span>
    }

    public GossiperMBean getGossProxy()
    {
<span class="nc" id="L871">        return gossProxy;</span>
    }

    public String getEndpoint()
    {
<span class="nc" id="L876">        Map&lt;String, String&gt; hostIdToEndpoint = ssProxy.getHostIdToEndpoint();</span>
<span class="nc" id="L877">        return hostIdToEndpoint.get(ssProxy.getLocalHostId());</span>
    }

    public String getDataCenter()
    {
<span class="nc" id="L882">        return getEndpointSnitchInfoProxy().getDatacenter();</span>
    }

    public String getRack()
    {
<span class="nc" id="L887">        return getEndpointSnitchInfoProxy().getRack();</span>
    }

    public List&lt;String&gt; getKeyspaces()
    {
<span class="nc" id="L892">        return ssProxy.getKeyspaces();</span>
    }

    public List&lt;String&gt; getNonSystemKeyspaces()
    {
<span class="nc" id="L897">        return ssProxy.getNonSystemKeyspaces();</span>
    }

    public List&lt;String&gt; getNonLocalStrategyKeyspaces()
    {
<span class="nc" id="L902">        return ssProxy.getNonLocalStrategyKeyspaces();</span>
    }

    public String getClusterName()
    {
<span class="nc" id="L907">        return ssProxy.getClusterName();</span>
    }

    public String getPartitioner()
    {
<span class="nc" id="L912">        return ssProxy.getPartitionerName();</span>
    }

    public void disableHintedHandoff()
    {
<span class="nc" id="L917">        spProxy.setHintedHandoffEnabled(false);</span>
<span class="nc" id="L918">    }</span>

    public void enableHintedHandoff()
    {
<span class="nc" id="L922">        spProxy.setHintedHandoffEnabled(true);</span>
<span class="nc" id="L923">    }</span>

    public boolean isHandoffEnabled()
    {
<span class="nc" id="L927">        return spProxy.getHintedHandoffEnabled();</span>
    }

    public void enableHintsForDC(String dc)
    {
<span class="nc" id="L932">        spProxy.enableHintsForDC(dc);</span>
<span class="nc" id="L933">    }</span>

    public void disableHintsForDC(String dc)
    {
<span class="nc" id="L937">        spProxy.disableHintsForDC(dc);</span>
<span class="nc" id="L938">    }</span>

    public Set&lt;String&gt; getHintedHandoffDisabledDCs()
    {
<span class="nc" id="L942">        return spProxy.getHintedHandoffDisabledDCs();</span>
    }

    public Map&lt;String, String&gt; getViewBuildStatuses(String keyspace, String view)
    {
<span class="nc" id="L947">        return ssProxy.getViewBuildStatuses(keyspace, view);</span>
    }

    public void pauseHintsDelivery()
    {
<span class="nc" id="L952">        hhProxy.pauseHintsDelivery(true);</span>
<span class="nc" id="L953">    }</span>

    public void resumeHintsDelivery()
    {
<span class="nc" id="L957">        hhProxy.pauseHintsDelivery(false);</span>
<span class="nc" id="L958">    }</span>

    public void truncateHints(final String host)
    {
<span class="nc" id="L962">        hhProxy.deleteHintsForEndpoint(host);</span>
<span class="nc" id="L963">    }</span>

    public void truncateHints()
    {
        try
        {
<span class="nc" id="L969">            hhProxy.truncateAllHints();</span>
        }
<span class="nc" id="L971">        catch (ExecutionException | InterruptedException e)</span>
        {
<span class="nc" id="L973">            throw new RuntimeException(&quot;Error while executing truncate hints&quot;, e);</span>
<span class="nc" id="L974">        }</span>
<span class="nc" id="L975">    }</span>

    public void refreshSizeEstimates()
    {
        try
        {
<span class="nc" id="L981">            ssProxy.refreshSizeEstimates();</span>
        }
<span class="nc" id="L983">        catch (ExecutionException e)</span>
        {
<span class="nc" id="L985">            throw new RuntimeException(&quot;Error while refreshing system.size_estimates&quot;, e);</span>
<span class="nc" id="L986">        }</span>
<span class="nc" id="L987">    }</span>

    public void stopNativeTransport()
    {
<span class="nc" id="L991">        ssProxy.stopNativeTransport();</span>
<span class="nc" id="L992">    }</span>

    public void startNativeTransport()
    {
<span class="nc" id="L996">        ssProxy.startNativeTransport();</span>
<span class="nc" id="L997">    }</span>

    public boolean isNativeTransportRunning()
    {
<span class="nc" id="L1001">        return ssProxy.isNativeTransportRunning();</span>
    }

    public void stopGossiping()
    {
<span class="nc" id="L1006">        ssProxy.stopGossiping();</span>
<span class="nc" id="L1007">    }</span>

    public void startGossiping()
    {
<span class="nc" id="L1011">        ssProxy.startGossiping();</span>
<span class="nc" id="L1012">    }</span>

    public boolean isGossipRunning()
    {
<span class="nc" id="L1016">        return ssProxy.isGossipRunning();</span>
    }

    public void stopThriftServer()
    {
<span class="nc" id="L1021">        ssProxy.stopRPCServer();</span>
<span class="nc" id="L1022">    }</span>

    public void startThriftServer()
    {
<span class="nc" id="L1026">        ssProxy.startRPCServer();</span>
<span class="nc" id="L1027">    }</span>

    public boolean isThriftServerRunning()
    {
<span class="nc" id="L1031">        return ssProxy.isRPCServerRunning();</span>
    }

    public void stopCassandraDaemon()
    {
<span class="nc" id="L1036">        ssProxy.stopDaemon();</span>
<span class="nc" id="L1037">    }</span>

    public boolean isInitialized()
    {
<span class="nc" id="L1041">        return ssProxy.isInitialized();</span>
    }

    public void setCompactionThroughput(int value)
    {
<span class="nc" id="L1046">        ssProxy.setCompactionThroughputMbPerSec(value);</span>
<span class="nc" id="L1047">    }</span>

    public int getCompactionThroughput()
    {
<span class="nc" id="L1051">        return ssProxy.getCompactionThroughputMbPerSec();</span>
    }

    public void setConcurrentCompactors(int value)
    {
<span class="nc" id="L1056">        ssProxy.setConcurrentCompactors(value);</span>
<span class="nc" id="L1057">    }</span>

    public int getConcurrentCompactors()
    {
<span class="nc" id="L1061">        return ssProxy.getConcurrentCompactors();</span>
    }

    public long getTimeout(String type)
    {
<span class="nc bnc" id="L1066" title="All 9 branches missed.">        switch (type)</span>
        {
            case &quot;misc&quot;:
<span class="nc" id="L1069">                return ssProxy.getRpcTimeout();</span>
            case &quot;read&quot;:
<span class="nc" id="L1071">                return ssProxy.getReadRpcTimeout();</span>
            case &quot;range&quot;:
<span class="nc" id="L1073">                return ssProxy.getRangeRpcTimeout();</span>
            case &quot;write&quot;:
<span class="nc" id="L1075">                return ssProxy.getWriteRpcTimeout();</span>
            case &quot;counterwrite&quot;:
<span class="nc" id="L1077">                return ssProxy.getCounterWriteRpcTimeout();</span>
            case &quot;cascontention&quot;:
<span class="nc" id="L1079">                return ssProxy.getCasContentionTimeout();</span>
            case &quot;truncate&quot;:
<span class="nc" id="L1081">                return ssProxy.getTruncateRpcTimeout();</span>
            case &quot;streamingsocket&quot;:
<span class="nc" id="L1083">                return (long) ssProxy.getStreamingSocketTimeout();</span>
            default:
<span class="nc" id="L1085">                throw new RuntimeException(&quot;Timeout type requires one of (&quot; + GetTimeout.TIMEOUT_TYPES + &quot;)&quot;);</span>
        }
    }

    public int getStreamThroughput()
    {
<span class="nc" id="L1091">        return ssProxy.getStreamThroughputMbPerSec();</span>
    }

    public int getInterDCStreamThroughput()
    {
<span class="nc" id="L1096">        return ssProxy.getInterDCStreamThroughputMbPerSec();</span>
    }

    public double getTraceProbability()
    {
<span class="nc" id="L1101">        return ssProxy.getTraceProbability();</span>
    }

    public int getExceptionCount()
    {
<span class="nc" id="L1106">        return (int)StorageMetrics.exceptions.getCount();</span>
    }

    public Map&lt;String, Integer&gt; getDroppedMessages()
    {
<span class="nc" id="L1111">        return msProxy.getDroppedMessages();</span>
    }

    public void loadNewSSTables(String ksName, String cfName)
    {
<span class="nc" id="L1116">        ssProxy.loadNewSSTables(ksName, cfName);</span>
<span class="nc" id="L1117">    }</span>

    public void rebuildIndex(String ksName, String cfName, String... idxNames)
    {
<span class="nc" id="L1121">        ssProxy.rebuildSecondaryIndex(ksName, cfName, idxNames);</span>
<span class="nc" id="L1122">    }</span>

    public String getGossipInfo()
    {
<span class="nc" id="L1126">        return fdProxy.getAllEndpointStates();</span>
    }

    public void stop(String string)
    {
<span class="nc" id="L1131">        compactionProxy.stopCompaction(string);</span>
<span class="nc" id="L1132">    }</span>

    public void setTimeout(String type, long value)
    {
<span class="nc bnc" id="L1136" title="All 2 branches missed.">        if (value &lt; 0)</span>
<span class="nc" id="L1137">            throw new RuntimeException(&quot;timeout must be non-negative&quot;);</span>

<span class="nc bnc" id="L1139" title="All 9 branches missed.">        switch (type)</span>
        {
            case &quot;misc&quot;:
<span class="nc" id="L1142">                ssProxy.setRpcTimeout(value);</span>
<span class="nc" id="L1143">                break;</span>
            case &quot;read&quot;:
<span class="nc" id="L1145">                ssProxy.setReadRpcTimeout(value);</span>
<span class="nc" id="L1146">                break;</span>
            case &quot;range&quot;:
<span class="nc" id="L1148">                ssProxy.setRangeRpcTimeout(value);</span>
<span class="nc" id="L1149">                break;</span>
            case &quot;write&quot;:
<span class="nc" id="L1151">                ssProxy.setWriteRpcTimeout(value);</span>
<span class="nc" id="L1152">                break;</span>
            case &quot;counterwrite&quot;:
<span class="nc" id="L1154">                ssProxy.setCounterWriteRpcTimeout(value);</span>
<span class="nc" id="L1155">                break;</span>
            case &quot;cascontention&quot;:
<span class="nc" id="L1157">                ssProxy.setCasContentionTimeout(value);</span>
<span class="nc" id="L1158">                break;</span>
            case &quot;truncate&quot;:
<span class="nc" id="L1160">                ssProxy.setTruncateRpcTimeout(value);</span>
<span class="nc" id="L1161">                break;</span>
            case &quot;streamingsocket&quot;:
<span class="nc bnc" id="L1163" title="All 2 branches missed.">                if (value &gt; Integer.MAX_VALUE)</span>
<span class="nc" id="L1164">                    throw new RuntimeException(&quot;streamingsocket timeout must be less than &quot; + Integer.MAX_VALUE);</span>
<span class="nc" id="L1165">                ssProxy.setStreamingSocketTimeout((int) value);</span>
<span class="nc" id="L1166">                break;</span>
            default:
<span class="nc" id="L1168">                throw new RuntimeException(&quot;Timeout type requires one of (&quot; + GetTimeout.TIMEOUT_TYPES + &quot;)&quot;);</span>
        }
<span class="nc" id="L1170">    }</span>

    public void stopById(String compactionId)
    {
<span class="nc" id="L1174">        compactionProxy.stopCompactionById(compactionId);</span>
<span class="nc" id="L1175">    }</span>

    public void setStreamThroughput(int value)
    {
<span class="nc" id="L1179">        ssProxy.setStreamThroughputMbPerSec(value);</span>
<span class="nc" id="L1180">    }</span>

    public void setInterDCStreamThroughput(int value)
    {
<span class="nc" id="L1184">        ssProxy.setInterDCStreamThroughputMbPerSec(value);</span>
<span class="nc" id="L1185">    }</span>

    public void setTraceProbability(double value)
    {
<span class="nc" id="L1189">        ssProxy.setTraceProbability(value);</span>
<span class="nc" id="L1190">    }</span>

    public String getSchemaVersion()
    {
<span class="nc" id="L1194">        return ssProxy.getSchemaVersion();</span>
    }

    public List&lt;String&gt; describeRing(String keyspaceName) throws IOException
    {
<span class="nc" id="L1199">        return ssProxy.describeRingJMX(keyspaceName);</span>
    }

    public void rebuild(String sourceDc, String keyspace, String tokens, String specificSources)
    {
<span class="nc" id="L1204">        ssProxy.rebuild(sourceDc, keyspace, tokens, specificSources);</span>
<span class="nc" id="L1205">    }</span>

    public List&lt;String&gt; sampleKeyRange()
    {
<span class="nc" id="L1209">        return ssProxy.sampleKeyRange();</span>
    }

    public void resetLocalSchema() throws IOException
    {
<span class="nc" id="L1214">        ssProxy.resetLocalSchema();</span>
<span class="nc" id="L1215">    }</span>

    public void reloadLocalSchema()
    {
<span class="nc" id="L1219">        ssProxy.reloadLocalSchema();</span>
<span class="nc" id="L1220">    }</span>

    public boolean isFailed()
    {
<span class="nc" id="L1224">        return failed;</span>
    }

    public long getReadRepairAttempted()
    {
<span class="nc" id="L1229">        return spProxy.getReadRepairAttempted();</span>
    }

    public long getReadRepairRepairedBlocking()
    {
<span class="nc" id="L1234">        return spProxy.getReadRepairRepairedBlocking();</span>
    }

    public long getReadRepairRepairedBackground()
    {
<span class="nc" id="L1239">        return spProxy.getReadRepairRepairedBackground();</span>
    }

    // JMX getters for the o.a.c.metrics API below.
    /**
     * Retrieve cache metrics based on the cache type (KeyCache, RowCache, or CounterCache)
     * @param cacheType KeyCach, RowCache, or CounterCache
     * @param metricName Capacity, Entries, HitRate, Size, Requests or Hits.
     */
    public Object getCacheMetric(String cacheType, String metricName)
    {
        try
        {
<span class="nc bnc" id="L1252" title="All 5 branches missed.">            switch(metricName)</span>
            {
                case &quot;Capacity&quot;:
                case &quot;Entries&quot;:
                case &quot;HitRate&quot;:
                case &quot;Size&quot;:
<span class="nc" id="L1258">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Cache,scope=&quot; + cacheType + &quot;,name=&quot; + metricName),
<span class="nc" id="L1260">                            CassandraMetricsRegistry.JmxGaugeMBean.class).getValue();</span>
                case &quot;Requests&quot;:
                case &quot;Hits&quot;:
                case &quot;Misses&quot;:
<span class="nc" id="L1264">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Cache,scope=&quot; + cacheType + &quot;,name=&quot; + metricName),
<span class="nc" id="L1266">                            CassandraMetricsRegistry.JmxMeterMBean.class).getCount();</span>
                case &quot;MissLatency&quot;:
<span class="nc" id="L1268">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Cache,scope=&quot; + cacheType + &quot;,name=&quot; + metricName),
<span class="nc" id="L1270">                            CassandraMetricsRegistry.JmxTimerMBean.class).getMean();</span>
                case &quot;MissLatencyUnit&quot;:
<span class="nc" id="L1272">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Cache,scope=&quot; + cacheType + &quot;,name=MissLatency&quot;),
<span class="nc" id="L1274">                            CassandraMetricsRegistry.JmxTimerMBean.class).getDurationUnit();</span>
                default:
<span class="nc" id="L1276">                    throw new RuntimeException(&quot;Unknown cache metric name.&quot;);</span>

            }
        }
<span class="nc" id="L1280">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1282">            throw new RuntimeException(e);</span>
        }
    }

    public Object getThreadPoolMetric(String pathName, String poolName, String metricName)
    {
<span class="nc" id="L1288">        return ThreadPoolMetrics.getJmxMetric(mbeanServerConn, pathName, poolName, metricName);</span>
    }

    /**
     * Retrieve threadpool paths and names for threadpools with metrics.
     * @return Multimap from path (internal, request, etc.) to name
     */
    public Multimap&lt;String, String&gt; getThreadPools()
    {
<span class="nc" id="L1297">        return ThreadPoolMetrics.getJmxThreadPools(mbeanServerConn);</span>
    }

    public int getNumberOfTables()
    {
<span class="nc" id="L1302">        return spProxy.getNumberOfTables();</span>
    }

    /**
     * Retrieve ColumnFamily metrics
     * @param ks Keyspace for which stats are to be displayed or null for the global value
     * @param cf ColumnFamily for which stats are to be displayed or null for the keyspace value (if ks supplied)
     * @param metricName View {@link TableMetrics}.
     */
    public Object getColumnFamilyMetric(String ks, String cf, String metricName)
    {
        try
        {
<span class="nc" id="L1315">            ObjectName oName = null;</span>
<span class="nc bnc" id="L1316" title="All 4 branches missed.">            if (!Strings.isNullOrEmpty(ks) &amp;&amp; !Strings.isNullOrEmpty(cf))</span>
            {
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                String type = cf.contains(&quot;.&quot;) ? &quot;IndexTable&quot; : &quot;Table&quot;;</span>
<span class="nc" id="L1319">                oName = new ObjectName(String.format(&quot;org.apache.cassandra.metrics:type=%s,keyspace=%s,scope=%s,name=%s&quot;, type, ks, cf, metricName));</span>
<span class="nc" id="L1320">            }</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">            else if (!Strings.isNullOrEmpty(ks))</span>
            {
<span class="nc" id="L1323">                oName = new ObjectName(String.format(&quot;org.apache.cassandra.metrics:type=Keyspace,keyspace=%s,name=%s&quot;, ks, metricName));</span>
            }
            else
            {
<span class="nc" id="L1327">                oName = new ObjectName(String.format(&quot;org.apache.cassandra.metrics:type=Table,name=%s&quot;, metricName));</span>
            }
<span class="nc bnc" id="L1329" title="All 5 branches missed.">            switch(metricName)</span>
            {
                case &quot;BloomFilterDiskSpaceUsed&quot;:
                case &quot;BloomFilterFalsePositives&quot;:
                case &quot;BloomFilterFalseRatio&quot;:
                case &quot;BloomFilterOffHeapMemoryUsed&quot;:
                case &quot;IndexSummaryOffHeapMemoryUsed&quot;:
                case &quot;CompressionMetadataOffHeapMemoryUsed&quot;:
                case &quot;CompressionRatio&quot;:
                case &quot;EstimatedColumnCountHistogram&quot;:
                case &quot;EstimatedPartitionSizeHistogram&quot;:
                case &quot;EstimatedPartitionCount&quot;:
                case &quot;KeyCacheHitRate&quot;:
                case &quot;LiveSSTableCount&quot;:
                case &quot;MaxPartitionSize&quot;:
                case &quot;MeanPartitionSize&quot;:
                case &quot;MemtableColumnsCount&quot;:
                case &quot;MemtableLiveDataSize&quot;:
                case &quot;MemtableOffHeapSize&quot;:
                case &quot;MinPartitionSize&quot;:
                case &quot;PercentRepaired&quot;:
                case &quot;RecentBloomFilterFalsePositives&quot;:
                case &quot;RecentBloomFilterFalseRatio&quot;:
                case &quot;SnapshotsSize&quot;:
<span class="nc" id="L1353">                    return JMX.newMBeanProxy(mbeanServerConn, oName, CassandraMetricsRegistry.JmxGaugeMBean.class).getValue();</span>
                case &quot;LiveDiskSpaceUsed&quot;:
                case &quot;MemtableSwitchCount&quot;:
                case &quot;SpeculativeRetries&quot;:
                case &quot;TotalDiskSpaceUsed&quot;:
                case &quot;WriteTotalLatency&quot;:
                case &quot;ReadTotalLatency&quot;:
                case &quot;PendingFlushes&quot;:
                case &quot;DroppedMutations&quot;:
<span class="nc" id="L1362">                    return JMX.newMBeanProxy(mbeanServerConn, oName, CassandraMetricsRegistry.JmxCounterMBean.class).getCount();</span>
                case &quot;CoordinatorReadLatency&quot;:
                case &quot;CoordinatorScanLatency&quot;:
                case &quot;ReadLatency&quot;:
                case &quot;WriteLatency&quot;:
<span class="nc" id="L1367">                    return JMX.newMBeanProxy(mbeanServerConn, oName, CassandraMetricsRegistry.JmxTimerMBean.class);</span>
                case &quot;LiveScannedHistogram&quot;:
                case &quot;SSTablesPerReadHistogram&quot;:
                case &quot;TombstoneScannedHistogram&quot;:
<span class="nc" id="L1371">                    return JMX.newMBeanProxy(mbeanServerConn, oName, CassandraMetricsRegistry.JmxHistogramMBean.class);</span>
                default:
<span class="nc" id="L1373">                    throw new RuntimeException(&quot;Unknown table metric &quot; + metricName);</span>
            }
        }
<span class="nc" id="L1376">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1378">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Retrieve Proxy metrics
     * @param scope RangeSlice, Read or Write
     */
    public CassandraMetricsRegistry.JmxTimerMBean getProxyMetric(String scope)
    {
        try
        {
<span class="nc" id="L1390">            return JMX.newMBeanProxy(mbeanServerConn,</span>
                    new ObjectName(&quot;org.apache.cassandra.metrics:type=ClientRequest,scope=&quot; + scope + &quot;,name=Latency&quot;),
                    CassandraMetricsRegistry.JmxTimerMBean.class);
        }
<span class="nc" id="L1394">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1396">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Retrieve Proxy metrics
     * @param metricName CompletedTasks, PendingTasks, BytesCompacted or TotalCompactionsCompleted.
     */
    public Object getCompactionMetric(String metricName)
    {
        try
        {
<span class="nc bnc" id="L1408" title="All 4 branches missed.">            switch(metricName)</span>
            {
                case &quot;BytesCompacted&quot;:
<span class="nc" id="L1411">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Compaction,name=&quot; + metricName),
                            CassandraMetricsRegistry.JmxCounterMBean.class);
                case &quot;CompletedTasks&quot;:
                case &quot;PendingTasks&quot;:
                case &quot;PendingTasksByTableName&quot;:
<span class="nc" id="L1417">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Compaction,name=&quot; + metricName),
<span class="nc" id="L1419">                            CassandraMetricsRegistry.JmxGaugeMBean.class).getValue();</span>
                case &quot;TotalCompactionsCompleted&quot;:
<span class="nc" id="L1421">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Compaction,name=&quot; + metricName),
                            CassandraMetricsRegistry.JmxMeterMBean.class);
                default:
<span class="nc" id="L1425">                    throw new RuntimeException(&quot;Unknown compaction metric.&quot;);</span>
            }
        }
<span class="nc" id="L1428">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1430">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Retrieve Proxy metrics
     * @param metricName Exceptions, Load, TotalHints or TotalHintsInProgress.
     */
    public long getStorageMetric(String metricName)
    {
        try
        {
<span class="nc" id="L1442">            return JMX.newMBeanProxy(mbeanServerConn,</span>
                    new ObjectName(&quot;org.apache.cassandra.metrics:type=Storage,name=&quot; + metricName),
<span class="nc" id="L1444">                    CassandraMetricsRegistry.JmxCounterMBean.class).getCount();</span>
        }
<span class="nc" id="L1446">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1448">            throw new RuntimeException(e);</span>
        }
    }

    public double[] metricPercentilesAsArray(CassandraMetricsRegistry.JmxHistogramMBean metric)
    {
<span class="nc" id="L1454">        return new double[]{ metric.get50thPercentile(),</span>
<span class="nc" id="L1455">                metric.get75thPercentile(),</span>
<span class="nc" id="L1456">                metric.get95thPercentile(),</span>
<span class="nc" id="L1457">                metric.get98thPercentile(),</span>
<span class="nc" id="L1458">                metric.get99thPercentile(),</span>
<span class="nc" id="L1459">                metric.getMin(),</span>
<span class="nc" id="L1460">                metric.getMax()};</span>
    }

    public double[] metricPercentilesAsArray(CassandraMetricsRegistry.JmxTimerMBean metric)
    {
<span class="nc" id="L1465">        return new double[]{ metric.get50thPercentile(),</span>
<span class="nc" id="L1466">                metric.get75thPercentile(),</span>
<span class="nc" id="L1467">                metric.get95thPercentile(),</span>
<span class="nc" id="L1468">                metric.get98thPercentile(),</span>
<span class="nc" id="L1469">                metric.get99thPercentile(),</span>
<span class="nc" id="L1470">                metric.getMin(),</span>
<span class="nc" id="L1471">                metric.getMax()};</span>
    }

    public TabularData getCompactionHistory()
    {
<span class="nc" id="L1476">        return compactionProxy.getCompactionHistory();</span>
    }

    public void reloadTriggers()
    {
<span class="nc" id="L1481">        spProxy.reloadTriggerClasses();</span>
<span class="nc" id="L1482">    }</span>

    public void setLoggingLevel(String classQualifier, String level)
    {
        try
        {
<span class="nc" id="L1488">            ssProxy.setLoggingLevel(classQualifier, level);</span>
        }
<span class="nc" id="L1490">        catch (Exception e)</span>
        {
<span class="nc" id="L1492">          throw new RuntimeException(&quot;Error setting log for &quot; + classQualifier +&quot; on level &quot; + level +&quot;. Please check logback configuration and ensure to have &lt;jmxConfigurator /&gt; set&quot;, e);</span>
<span class="nc" id="L1493">        }</span>
<span class="nc" id="L1494">    }</span>

    public Map&lt;String, String&gt; getLoggingLevels()
    {
<span class="nc" id="L1498">        return ssProxy.getLoggingLevels();</span>
    }

    public void resumeBootstrap(PrintStream out) throws IOException
    {
<span class="nc" id="L1503">        BootstrapMonitor monitor = new BootstrapMonitor(out);</span>
        try
        {
<span class="nc bnc" id="L1506" title="All 2 branches missed.">            if (jmxc != null)</span>
<span class="nc" id="L1507">                jmxc.addConnectionNotificationListener(monitor, null, null);</span>
<span class="nc" id="L1508">            ssProxy.addNotificationListener(monitor, null, null);</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">            if (ssProxy.resumeBootstrap())</span>
            {
<span class="nc" id="L1511">                out.println(&quot;Resuming bootstrap&quot;);</span>
<span class="nc" id="L1512">                monitor.awaitCompletion();</span>
            }
            else
            {
<span class="nc" id="L1516">                out.println(&quot;Node is already bootstrapped.&quot;);</span>
            }
        }
<span class="nc" id="L1519">        catch (Exception e)</span>
        {
<span class="nc" id="L1521">            throw new IOException(e);</span>
        }
        finally
        {
            try
            {
<span class="nc" id="L1527">                ssProxy.removeNotificationListener(monitor);</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">                if (jmxc != null)</span>
<span class="nc" id="L1529">                    jmxc.removeConnectionNotificationListener(monitor);</span>
            }
<span class="nc" id="L1531">            catch (Throwable e)</span>
            {
<span class="nc" id="L1533">                out.println(&quot;Exception occurred during clean-up. &quot; + e);</span>
<span class="nc" id="L1534">            }</span>
        }
<span class="nc" id="L1536">    }</span>

    public void replayBatchlog() throws IOException
    {
        try
        {
<span class="nc" id="L1542">            bmProxy.forceBatchlogReplay();</span>
        }
<span class="nc" id="L1544">        catch (Exception e)</span>
        {
<span class="nc" id="L1546">            throw new IOException(e);</span>
<span class="nc" id="L1547">        }</span>
<span class="nc" id="L1548">    }</span>

    public TabularData getFailureDetectorPhilValues()
    {
        try
        {
<span class="nc" id="L1554">            return fdProxy.getPhiValues();</span>
        }
<span class="nc" id="L1556">        catch (OpenDataException e)</span>
        {
<span class="nc" id="L1558">            throw new RuntimeException(e);</span>
        }
    }
}

class ColumnFamilyStoreMBeanIterator implements Iterator&lt;Map.Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt;
{
    private MBeanServerConnection mbeanServerConn;
    Iterator&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; mbeans;

    public ColumnFamilyStoreMBeanIterator(MBeanServerConnection mbeanServerConn)
        throws MalformedObjectNameException, NullPointerException, IOException
<span class="nc" id="L1570">    {</span>
<span class="nc" id="L1571">        this.mbeanServerConn = mbeanServerConn;</span>
<span class="nc" id="L1572">        List&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; cfMbeans = getCFSMBeans(mbeanServerConn, &quot;ColumnFamilies&quot;);</span>
<span class="nc" id="L1573">        cfMbeans.addAll(getCFSMBeans(mbeanServerConn, &quot;IndexColumnFamilies&quot;));</span>
<span class="nc" id="L1574">        Collections.sort(cfMbeans, new Comparator&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt;()</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">        {</span>
            public int compare(Entry&lt;String, ColumnFamilyStoreMBean&gt; e1, Entry&lt;String, ColumnFamilyStoreMBean&gt; e2)
            {
                //compare keyspace, then CF name, then normal vs. index
<span class="nc" id="L1579">                int keyspaceNameCmp = e1.getKey().compareTo(e2.getKey());</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">                if(keyspaceNameCmp != 0)</span>
<span class="nc" id="L1581">                    return keyspaceNameCmp;</span>

                // get CF name and split it for index name
<span class="nc" id="L1584">                String e1CF[] = e1.getValue().getColumnFamilyName().split(&quot;\\.&quot;);</span>
<span class="nc" id="L1585">                String e2CF[] = e2.getValue().getColumnFamilyName().split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L1586" title="All 6 branches missed.">                assert e1CF.length &lt;= 2 &amp;&amp; e2CF.length &lt;= 2 : &quot;unexpected split count for table name&quot;;</span>

                //if neither are indexes, just compare CF names
<span class="nc bnc" id="L1589" title="All 4 branches missed.">                if(e1CF.length == 1 &amp;&amp; e2CF.length == 1)</span>
<span class="nc" id="L1590">                    return e1CF[0].compareTo(e2CF[0]);</span>

                //check if it's the same CF
<span class="nc" id="L1593">                int cfNameCmp = e1CF[0].compareTo(e2CF[0]);</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">                if(cfNameCmp != 0)</span>
<span class="nc" id="L1595">                    return cfNameCmp;</span>

                // if both are indexes (for the same CF), compare them
<span class="nc bnc" id="L1598" title="All 4 branches missed.">                if(e1CF.length == 2 &amp;&amp; e2CF.length == 2)</span>
<span class="nc" id="L1599">                    return e1CF[1].compareTo(e2CF[1]);</span>

                //if length of e1CF is 1, it's not an index, so sort it higher
<span class="nc bnc" id="L1602" title="All 2 branches missed.">                return e1CF.length == 1 ? 1 : -1;</span>
            }
        });
<span class="nc" id="L1605">        mbeans = cfMbeans.iterator();</span>
<span class="nc" id="L1606">    }</span>

    private List&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; getCFSMBeans(MBeanServerConnection mbeanServerConn, String type)
            throws MalformedObjectNameException, IOException
    {
<span class="nc" id="L1611">        ObjectName query = new ObjectName(&quot;org.apache.cassandra.db:type=&quot; + type +&quot;,*&quot;);</span>
<span class="nc" id="L1612">        Set&lt;ObjectName&gt; cfObjects = mbeanServerConn.queryNames(query, null);</span>
<span class="nc" id="L1613">        List&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; mbeans = new ArrayList&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt;(cfObjects.size());</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">        for(ObjectName n : cfObjects)</span>
        {
<span class="nc" id="L1616">            String keyspaceName = n.getKeyProperty(&quot;keyspace&quot;);</span>
<span class="nc" id="L1617">            ColumnFamilyStoreMBean cfsProxy = JMX.newMBeanProxy(mbeanServerConn, n, ColumnFamilyStoreMBean.class);</span>
<span class="nc" id="L1618">            mbeans.add(new AbstractMap.SimpleImmutableEntry&lt;String, ColumnFamilyStoreMBean&gt;(keyspaceName, cfsProxy));</span>
<span class="nc" id="L1619">        }</span>
<span class="nc" id="L1620">        return mbeans;</span>
    }

    public boolean hasNext()
    {
<span class="nc" id="L1625">        return mbeans.hasNext();</span>
    }

    public Entry&lt;String, ColumnFamilyStoreMBean&gt; next()
    {
<span class="nc" id="L1630">        return mbeans.next();</span>
    }

    public void remove()
    {
<span class="nc" id="L1635">        throw new UnsupportedOperationException();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>