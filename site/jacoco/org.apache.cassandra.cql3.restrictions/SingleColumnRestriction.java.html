<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SingleColumnRestriction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.restrictions</a> &gt; <span class="el_source">SingleColumnRestriction.java</span></div><h1>SingleColumnRestriction.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.restrictions;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.cassandra.config.ColumnDefinition;
import org.apache.cassandra.cql3.*;
import org.apache.cassandra.cql3.Term.Terminal;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.cql3.statements.Bound;
import org.apache.cassandra.db.MultiCBuilder;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.index.Index;
import org.apache.cassandra.index.SecondaryIndexManager;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.Pair;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkBindValueSet;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkNotNull;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

public abstract class SingleColumnRestriction implements SingleRestriction
{
    /**
     * The definition of the column to which apply the restriction.
     */
    protected final ColumnDefinition columnDef;

    public SingleColumnRestriction(ColumnDefinition columnDef)
<span class="fc" id="L52">    {</span>
<span class="fc" id="L53">        this.columnDef = columnDef;</span>
<span class="fc" id="L54">    }</span>

    @Override
    public List&lt;ColumnDefinition&gt; getColumnDefs()
    {
<span class="fc" id="L59">        return Collections.singletonList(columnDef);</span>
    }

    @Override
    public ColumnDefinition getFirstColumn()
    {
<span class="fc" id="L65">        return columnDef;</span>
    }

    @Override
    public ColumnDefinition getLastColumn()
    {
<span class="fc" id="L71">        return columnDef;</span>
    }

    @Override
    public boolean hasSupportingIndex(SecondaryIndexManager indexManager)
    {
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        for (Index index : indexManager.listIndexes())</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">            if (isSupportedBy(index))</span>
<span class="nc" id="L79">                return true;</span>

<span class="fc" id="L81">        return false;</span>
    }

    @Override
    public final SingleRestriction mergeWith(SingleRestriction otherRestriction)
    {
        // We want to allow query like: b &gt; ? AND (b,c) &lt; (?, ?)
<span class="nc bnc" id="L88" title="All 4 branches missed.">        if (otherRestriction.isMultiColumn() &amp;&amp; canBeConvertedToMultiColumnRestriction())</span>
        {
<span class="nc" id="L90">            return toMultiColumnRestriction().mergeWith(otherRestriction);</span>
        }

<span class="nc" id="L93">        return doMergeWith(otherRestriction);</span>
    }

    protected abstract SingleRestriction doMergeWith(SingleRestriction otherRestriction);

    /**
     * Converts this &lt;code&gt;SingleColumnRestriction&lt;/code&gt; into a {@link MultiColumnRestriction}
     *
     * @return the &lt;code&gt;MultiColumnRestriction&lt;/code&gt; corresponding to this
     */
    abstract MultiColumnRestriction toMultiColumnRestriction();

    /**
     * Checks if this &lt;code&gt;Restriction&lt;/code&gt; can be converted into a {@link MultiColumnRestriction}
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Restriction&lt;/code&gt; can be converted into a
     * {@link MultiColumnRestriction}, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean canBeConvertedToMultiColumnRestriction()
    {
<span class="nc" id="L113">        return true;</span>
    }

    /**
     * Check if this type of restriction is supported by the specified index.
     *
     * @param index the secondary index
     * @return &lt;code&gt;true&lt;/code&gt; this type of restriction is supported by the specified index,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    protected abstract boolean isSupportedBy(Index index);

    public static class EQRestriction extends SingleColumnRestriction
    {
        public final Term value;

        public EQRestriction(ColumnDefinition columnDef, Term value)
        {
<span class="fc" id="L131">            super(columnDef);</span>
<span class="fc" id="L132">            this.value = value;</span>
<span class="fc" id="L133">        }</span>

        @Override
        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="fc" id="L138">            value.addFunctionsTo(functions);</span>
<span class="fc" id="L139">        }</span>

        @Override
        public boolean isEQ()
        {
<span class="fc" id="L144">            return true;</span>
        }

        @Override
        MultiColumnRestriction toMultiColumnRestriction()
        {
<span class="nc" id="L150">            return new MultiColumnRestriction.EQRestriction(Collections.singletonList(columnDef), value);</span>
        }

        @Override
        public void addRowFilterTo(RowFilter filter,
                                   SecondaryIndexManager indexManager,
                                   QueryOptions options)
        {
<span class="nc" id="L158">            filter.add(columnDef, Operator.EQ, value.bindAndGet(options));</span>
<span class="nc" id="L159">        }</span>

        @Override
        public MultiCBuilder appendTo(MultiCBuilder builder, QueryOptions options)
        {
<span class="fc" id="L164">            builder.addElementToAll(value.bindAndGet(options));</span>
<span class="fc" id="L165">            checkFalse(builder.containsNull(), &quot;Invalid null value in condition for column %s&quot;, columnDef.name);</span>
<span class="fc" id="L166">            checkFalse(builder.containsUnset(), &quot;Invalid unset value for column %s&quot;, columnDef.name);</span>
<span class="fc" id="L167">            return builder;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L173">            return String.format(&quot;EQ(%s)&quot;, value);</span>
        }

        @Override
        public SingleRestriction doMergeWith(SingleRestriction otherRestriction)
        {
<span class="nc" id="L179">            throw invalidRequest(&quot;%s cannot be restricted by more than one relation if it includes an Equal&quot;, columnDef.name);</span>
        }

        @Override
        protected boolean isSupportedBy(Index index)
        {
<span class="nc" id="L185">            return index.supportsExpression(columnDef, Operator.EQ);</span>
        }
    }

    public static abstract class INRestriction extends SingleColumnRestriction
    {
        public INRestriction(ColumnDefinition columnDef)
        {
<span class="fc" id="L193">            super(columnDef);</span>
<span class="fc" id="L194">        }</span>

        @Override
        public final boolean isIN()
        {
<span class="fc" id="L199">            return true;</span>
        }

        @Override
        public final SingleRestriction doMergeWith(SingleRestriction otherRestriction)
        {
<span class="nc" id="L205">            throw invalidRequest(&quot;%s cannot be restricted by more than one relation if it includes a IN&quot;, columnDef.name);</span>
        }

        @Override
        public MultiCBuilder appendTo(MultiCBuilder builder, QueryOptions options)
        {
<span class="fc" id="L211">            builder.addEachElementToAll(getValues(options));</span>
<span class="fc" id="L212">            checkFalse(builder.containsNull(), &quot;Invalid null value in condition for column %s&quot;, columnDef.name);</span>
<span class="fc" id="L213">            checkFalse(builder.containsUnset(), &quot;Invalid unset value for column %s&quot;, columnDef.name);</span>
<span class="fc" id="L214">            return builder;</span>
        }

        @Override
        public void addRowFilterTo(RowFilter filter,
                                   SecondaryIndexManager indexManager,
                                   QueryOptions options)
        {
<span class="nc" id="L222">            throw invalidRequest(&quot;IN restrictions are not supported on indexed columns&quot;);</span>
        }

        @Override
        protected final boolean isSupportedBy(Index index)
        {
<span class="nc" id="L228">            return index.supportsExpression(columnDef, Operator.IN);</span>
        }

        protected abstract List&lt;ByteBuffer&gt; getValues(QueryOptions options);
    }

    public static class InRestrictionWithValues extends INRestriction
    {
        protected final List&lt;Term&gt; values;

        public InRestrictionWithValues(ColumnDefinition columnDef, List&lt;Term&gt; values)
        {
<span class="nc" id="L240">            super(columnDef);</span>
<span class="nc" id="L241">            this.values = values;</span>
<span class="nc" id="L242">        }</span>

        @Override
        MultiColumnRestriction toMultiColumnRestriction()
        {
<span class="nc" id="L247">            return new MultiColumnRestriction.InRestrictionWithValues(Collections.singletonList(columnDef), values);</span>
        }

        @Override
        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="nc" id="L253">            Terms.addFunctions(values, functions);</span>
<span class="nc" id="L254">        }</span>

        @Override
        protected List&lt;ByteBuffer&gt; getValues(QueryOptions options)
        {
<span class="nc" id="L259">            List&lt;ByteBuffer&gt; buffers = new ArrayList&lt;&gt;(values.size());</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            for (Term value : values)</span>
<span class="nc" id="L261">                buffers.add(value.bindAndGet(options));</span>
<span class="nc" id="L262">            return buffers;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L268">            return String.format(&quot;IN(%s)&quot;, values);</span>
        }
    }

    public static class InRestrictionWithMarker extends INRestriction
    {
        protected final AbstractMarker marker;

        public InRestrictionWithMarker(ColumnDefinition columnDef, AbstractMarker marker)
        {
<span class="fc" id="L278">            super(columnDef);</span>
<span class="fc" id="L279">            this.marker = marker;</span>
<span class="fc" id="L280">        }</span>

        @Override
        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="nc" id="L285">        }</span>

        @Override
        MultiColumnRestriction toMultiColumnRestriction()
        {
<span class="nc" id="L290">            return new MultiColumnRestriction.InRestrictionWithMarker(Collections.singletonList(columnDef), marker);</span>
        }

        @Override
        protected List&lt;ByteBuffer&gt; getValues(QueryOptions options)
        {
<span class="fc" id="L296">            Terminal term = marker.bind(options);</span>
<span class="fc" id="L297">            checkNotNull(term, &quot;Invalid null value for column %s&quot;, columnDef.name);</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            checkFalse(term == Constants.UNSET_VALUE, &quot;Invalid unset value for column %s&quot;, columnDef.name);</span>
<span class="fc" id="L299">            Term.MultiItemTerminal lval = (Term.MultiItemTerminal) term;</span>
<span class="fc" id="L300">            return lval.getElements();</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L306">            return &quot;IN ?&quot;;</span>
        }
    }

    public static class SliceRestriction extends SingleColumnRestriction
    {
        public final TermSlice slice;

        public SliceRestriction(ColumnDefinition columnDef, Bound bound, boolean inclusive, Term term)
        {
<span class="nc" id="L316">            super(columnDef);</span>
<span class="nc" id="L317">            slice = TermSlice.newInstance(bound, inclusive, term);</span>
<span class="nc" id="L318">        }</span>

        @Override
        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="nc" id="L323">            slice.addFunctionsTo(functions);</span>
<span class="nc" id="L324">        }</span>

        @Override
        MultiColumnRestriction toMultiColumnRestriction()
        {
<span class="nc" id="L329">            return new MultiColumnRestriction.SliceRestriction(Collections.singletonList(columnDef), slice);</span>
        }

        @Override
        public boolean isSlice()
        {
<span class="nc" id="L335">            return true;</span>
        }

        @Override
        public MultiCBuilder appendTo(MultiCBuilder builder, QueryOptions options)
        {
<span class="nc" id="L341">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean hasBound(Bound b)
        {
<span class="nc" id="L347">            return slice.hasBound(b);</span>
        }

        @Override
        public MultiCBuilder appendBoundTo(MultiCBuilder builder, Bound bound, QueryOptions options)
        {
<span class="nc" id="L353">            Bound b = bound.reverseIfNeeded(getFirstColumn());</span>

<span class="nc bnc" id="L355" title="All 2 branches missed.">            if (!hasBound(b))</span>
<span class="nc" id="L356">                return builder;</span>

<span class="nc" id="L358">            ByteBuffer value = slice.bound(b).bindAndGet(options);</span>
<span class="nc" id="L359">            checkBindValueSet(value, &quot;Invalid unset value for column %s&quot;, columnDef.name);</span>
<span class="nc" id="L360">            return builder.addElementToAll(value);</span>

        }

        @Override
        public boolean isInclusive(Bound b)
        {
<span class="nc" id="L367">            return slice.isInclusive(b);</span>
        }

        @Override
        public SingleRestriction doMergeWith(SingleRestriction otherRestriction)
        {
<span class="nc" id="L373">            checkTrue(otherRestriction.isSlice(),</span>
                      &quot;Column \&quot;%s\&quot; cannot be restricted by both an equality and an inequality relation&quot;,
                      columnDef.name);

<span class="nc" id="L377">            SingleColumnRestriction.SliceRestriction otherSlice = (SingleColumnRestriction.SliceRestriction) otherRestriction;</span>

<span class="nc bnc" id="L379" title="All 4 branches missed.">            checkFalse(hasBound(Bound.START) &amp;&amp; otherSlice.hasBound(Bound.START),</span>
                       &quot;More than one restriction was found for the start bound on %s&quot;, columnDef.name);

<span class="nc bnc" id="L382" title="All 4 branches missed.">            checkFalse(hasBound(Bound.END) &amp;&amp; otherSlice.hasBound(Bound.END),</span>
                       &quot;More than one restriction was found for the end bound on %s&quot;, columnDef.name);

<span class="nc" id="L385">            return new SliceRestriction(columnDef,  slice.merge(otherSlice.slice));</span>
        }

        @Override
        public void addRowFilterTo(RowFilter filter, SecondaryIndexManager indexManager, QueryOptions options)
        {
<span class="nc bnc" id="L391" title="All 2 branches missed.">            for (Bound b : Bound.values())</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                if (hasBound(b))</span>
<span class="nc" id="L393">                    filter.add(columnDef, slice.getIndexOperator(b), slice.bound(b).bindAndGet(options));</span>
<span class="nc" id="L394">        }</span>

        @Override
        protected boolean isSupportedBy(Index index)
        {
<span class="nc" id="L399">            return slice.isSupportedBy(columnDef, index);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L405">            return String.format(&quot;SLICE%s&quot;, slice);</span>
        }

        SliceRestriction(ColumnDefinition columnDef, TermSlice slice)
        {
<span class="nc" id="L410">            super(columnDef);</span>
<span class="nc" id="L411">            this.slice = slice;</span>
<span class="nc" id="L412">        }</span>
    }

    // This holds CONTAINS, CONTAINS_KEY, and map[key] = value restrictions because we might want to have any combination of them.
<span class="nc bnc" id="L416" title="All 2 branches missed.">    public static final class ContainsRestriction extends SingleColumnRestriction</span>
    {
<span class="nc" id="L418">        private List&lt;Term&gt; values = new ArrayList&lt;&gt;(); // for CONTAINS</span>
<span class="nc" id="L419">        private List&lt;Term&gt; keys = new ArrayList&lt;&gt;(); // for CONTAINS_KEY</span>
<span class="nc" id="L420">        private List&lt;Term&gt; entryKeys = new ArrayList&lt;&gt;(); // for map[key] = value</span>
<span class="nc" id="L421">        private List&lt;Term&gt; entryValues = new ArrayList&lt;&gt;(); // for map[key] = value</span>

        public ContainsRestriction(ColumnDefinition columnDef, Term t, boolean isKey)
        {
<span class="nc" id="L425">            super(columnDef);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (isKey)</span>
<span class="nc" id="L427">                keys.add(t);</span>
            else
<span class="nc" id="L429">                values.add(t);</span>
<span class="nc" id="L430">        }</span>

        public ContainsRestriction(ColumnDefinition columnDef, Term mapKey, Term mapValue)
        {
<span class="nc" id="L434">            super(columnDef);</span>
<span class="nc" id="L435">            entryKeys.add(mapKey);</span>
<span class="nc" id="L436">            entryValues.add(mapValue);</span>
<span class="nc" id="L437">        }</span>

        @Override
        MultiColumnRestriction toMultiColumnRestriction()
        {
<span class="nc" id="L442">            throw new UnsupportedOperationException();</span>
        }

        @Override
        boolean canBeConvertedToMultiColumnRestriction()
        {
<span class="nc" id="L448">            return false;</span>
        }

        @Override
        public MultiCBuilder appendTo(MultiCBuilder builder, QueryOptions options)
        {
<span class="nc" id="L454">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean isContains()
        {
<span class="nc" id="L460">            return true;</span>
        }

        @Override
        public SingleRestriction doMergeWith(SingleRestriction otherRestriction)
        {
<span class="nc" id="L466">            checkTrue(otherRestriction.isContains(),</span>
                      &quot;Collection column %s can only be restricted by CONTAINS, CONTAINS KEY, or map-entry equality&quot;,
                      columnDef.name);

<span class="nc" id="L470">            SingleColumnRestriction.ContainsRestriction newContains = new ContainsRestriction(columnDef);</span>

<span class="nc" id="L472">            copyKeysAndValues(this, newContains);</span>
<span class="nc" id="L473">            copyKeysAndValues((ContainsRestriction) otherRestriction, newContains);</span>

<span class="nc" id="L475">            return newContains;</span>
        }

        @Override
        public void addRowFilterTo(RowFilter filter, SecondaryIndexManager indexManager, QueryOptions options)
        {
<span class="nc bnc" id="L481" title="All 2 branches missed.">            for (ByteBuffer value : bindAndGet(values, options))</span>
<span class="nc" id="L482">                filter.add(columnDef, Operator.CONTAINS, value);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">            for (ByteBuffer key : bindAndGet(keys, options))</span>
<span class="nc" id="L484">                filter.add(columnDef, Operator.CONTAINS_KEY, key);</span>

<span class="nc" id="L486">            List&lt;ByteBuffer&gt; eks = bindAndGet(entryKeys, options);</span>
<span class="nc" id="L487">            List&lt;ByteBuffer&gt; evs = bindAndGet(entryValues, options);</span>
<span class="nc bnc" id="L488" title="All 4 branches missed.">            assert eks.size() == evs.size();</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            for (int i = 0; i &lt; eks.size(); i++)</span>
<span class="nc" id="L490">                filter.addMapEquality(columnDef, eks.get(i), Operator.EQ, evs.get(i));</span>
<span class="nc" id="L491">        }</span>

        @Override
        protected boolean isSupportedBy(Index index)
        {
<span class="nc" id="L496">            boolean supported = false;</span>

<span class="nc bnc" id="L498" title="All 2 branches missed.">            if (numberOfValues() &gt; 0)</span>
<span class="nc" id="L499">                supported |= index.supportsExpression(columnDef, Operator.CONTAINS);</span>

<span class="nc bnc" id="L501" title="All 2 branches missed.">            if (numberOfKeys() &gt; 0)</span>
<span class="nc" id="L502">                supported |= index.supportsExpression(columnDef, Operator.CONTAINS_KEY);</span>

<span class="nc bnc" id="L504" title="All 2 branches missed.">            if (numberOfEntries() &gt; 0)</span>
<span class="nc" id="L505">                supported |= index.supportsExpression(columnDef, Operator.EQ);</span>

<span class="nc" id="L507">            return supported;</span>
        }

        public int numberOfValues()
        {
<span class="nc" id="L512">            return values.size();</span>
        }

        public int numberOfKeys()
        {
<span class="nc" id="L517">            return keys.size();</span>
        }

        public int numberOfEntries()
        {
<span class="nc" id="L522">            return entryKeys.size();</span>
        }

        @Override
        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="nc" id="L528">            Terms.addFunctions(values, functions);</span>
<span class="nc" id="L529">            Terms.addFunctions(keys, functions);</span>
<span class="nc" id="L530">            Terms.addFunctions(entryKeys, functions);</span>
<span class="nc" id="L531">            Terms.addFunctions(entryValues, functions);</span>
<span class="nc" id="L532">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L537">            return String.format(&quot;CONTAINS(values=%s, keys=%s, entryKeys=%s, entryValues=%s)&quot;, values, keys, entryKeys, entryValues);</span>
        }

        @Override
        public boolean hasBound(Bound b)
        {
<span class="nc" id="L543">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public MultiCBuilder appendBoundTo(MultiCBuilder builder, Bound bound, QueryOptions options)
        {
<span class="nc" id="L549">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean isInclusive(Bound b)
        {
<span class="nc" id="L555">            throw new UnsupportedOperationException();</span>
        }

        /**
         * Binds the query options to the specified terms and returns the resulting values.
         *
         * @param terms the terms
         * @param options the query options
         * @return the value resulting from binding the query options to the specified terms
         */
        private static List&lt;ByteBuffer&gt; bindAndGet(List&lt;Term&gt; terms, QueryOptions options)
        {
<span class="nc" id="L567">            List&lt;ByteBuffer&gt; buffers = new ArrayList&lt;&gt;(terms.size());</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            for (Term value : terms)</span>
<span class="nc" id="L569">                buffers.add(value.bindAndGet(options));</span>
<span class="nc" id="L570">            return buffers;</span>
        }

        /**
         * Copies the keys and value from the first &lt;code&gt;Contains&lt;/code&gt; to the second one.
         *
         * @param from the &lt;code&gt;Contains&lt;/code&gt; to copy from
         * @param to the &lt;code&gt;Contains&lt;/code&gt; to copy to
         */
        private static void copyKeysAndValues(ContainsRestriction from, ContainsRestriction to)
        {
<span class="nc" id="L581">            to.values.addAll(from.values);</span>
<span class="nc" id="L582">            to.keys.addAll(from.keys);</span>
<span class="nc" id="L583">            to.entryKeys.addAll(from.entryKeys);</span>
<span class="nc" id="L584">            to.entryValues.addAll(from.entryValues);</span>
<span class="nc" id="L585">        }</span>

        private ContainsRestriction(ColumnDefinition columnDef)
        {
<span class="nc" id="L589">            super(columnDef);</span>
<span class="nc" id="L590">        }</span>
    }

    public static final class IsNotNullRestriction extends SingleColumnRestriction
    {
        public IsNotNullRestriction(ColumnDefinition columnDef)
        {
<span class="nc" id="L597">            super(columnDef);</span>
<span class="nc" id="L598">        }</span>

        @Override
        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="nc" id="L603">        }</span>

        @Override
        public boolean isNotNull()
        {
<span class="nc" id="L608">            return true;</span>
        }

        @Override
        MultiColumnRestriction toMultiColumnRestriction()
        {
<span class="nc" id="L614">            return new MultiColumnRestriction.NotNullRestriction(Collections.singletonList(columnDef));</span>
        }

        @Override
        public void addRowFilterTo(RowFilter filter,
                                   SecondaryIndexManager indexManager,
                                   QueryOptions options)
        {
<span class="nc" id="L622">            throw new UnsupportedOperationException(&quot;Secondary indexes do not support IS NOT NULL restrictions&quot;);</span>
        }

        @Override
        public MultiCBuilder appendTo(MultiCBuilder builder, QueryOptions options)
        {
<span class="nc" id="L628">            throw new UnsupportedOperationException(&quot;Cannot use IS NOT NULL restriction for slicing&quot;);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L634">            return &quot;IS NOT NULL&quot;;</span>
        }

        @Override
        public SingleRestriction doMergeWith(SingleRestriction otherRestriction)
        {
<span class="nc" id="L640">            throw invalidRequest(&quot;%s cannot be restricted by a relation if it includes an IS NOT NULL&quot;, columnDef.name);</span>
        }

        @Override
        protected boolean isSupportedBy(Index index)
        {
<span class="nc" id="L646">            return index.supportsExpression(columnDef, Operator.IS_NOT);</span>
        }
    }

    public static final class LikeRestriction extends SingleColumnRestriction
    {
<span class="nc" id="L652">        private static final ByteBuffer LIKE_WILDCARD = ByteBufferUtil.bytes(&quot;%&quot;);</span>
        private final Operator operator;
        private final Term value;

        public LikeRestriction(ColumnDefinition columnDef, Operator operator, Term value)
        {
<span class="nc" id="L658">            super(columnDef);</span>
<span class="nc" id="L659">            this.operator = operator;</span>
<span class="nc" id="L660">            this.value = value;</span>
<span class="nc" id="L661">        }</span>

        @Override
        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="nc" id="L666">            value.addFunctionsTo(functions);</span>
<span class="nc" id="L667">        }</span>

        @Override
        public boolean isEQ()
        {
<span class="nc" id="L672">            return false;</span>
        }

        @Override
        public boolean isLIKE()
        {
<span class="nc" id="L678">            return true;</span>
        }

        @Override
        public boolean canBeConvertedToMultiColumnRestriction()
        {
<span class="nc" id="L684">            return false;</span>
        }

        @Override
        MultiColumnRestriction toMultiColumnRestriction()
        {
<span class="nc" id="L690">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public void addRowFilterTo(RowFilter filter,
                                   SecondaryIndexManager indexManager,
                                   QueryOptions options)
        {
<span class="nc" id="L698">            Pair&lt;Operator, ByteBuffer&gt; operation = makeSpecific(value.bindAndGet(options));</span>

            // there must be a suitable INDEX for LIKE_XXX expressions
<span class="nc" id="L701">            RowFilter.SimpleExpression expression = filter.add(columnDef, operation.left, operation.right);</span>
<span class="nc" id="L702">            indexManager.getBestIndexFor(expression)</span>
<span class="nc" id="L703">                        .orElseThrow(() -&gt; invalidRequest(&quot;%s is only supported on properly indexed columns&quot;,</span>
                                                          expression));
<span class="nc" id="L705">        }</span>

        @Override
        public MultiCBuilder appendTo(MultiCBuilder builder, QueryOptions options)
        {
            // LIKE can be used with clustering columns, but as it doesn't
            // represent an actual clustering value, it can't be used in a
            // clustering filter.
<span class="nc" id="L713">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L719">            return operator.toString();</span>
        }

        @Override
        public SingleRestriction doMergeWith(SingleRestriction otherRestriction)
        {
<span class="nc" id="L725">            throw invalidRequest(&quot;%s cannot be restricted by more than one relation if it includes a %s&quot;, columnDef.name, operator);</span>
        }

        @Override
        protected boolean isSupportedBy(Index index)
        {
<span class="nc" id="L731">            return index.supportsExpression(columnDef, operator);</span>
        }

        /**
         * As the specific subtype of LIKE (LIKE_PREFIX, LIKE_SUFFIX, LIKE_CONTAINS, LIKE_MATCHES) can only be
         * determined by examining the value, which in turn can only be known after binding, all LIKE restrictions
         * are initially created with the generic LIKE operator. This function takes the bound value, trims the
         * wildcard '%' chars from it and returns a tuple of the inferred operator subtype and the final value
         * @param value the bound value for the LIKE operation
         * @return  Pair containing the inferred LIKE subtype and the value with wildcards removed
         */
        private static Pair&lt;Operator, ByteBuffer&gt; makeSpecific(ByteBuffer value)
        {
            Operator operator;
<span class="nc" id="L745">            int beginIndex = value.position();</span>
<span class="nc" id="L746">            int endIndex = value.limit() - 1;</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            if (ByteBufferUtil.endsWith(value, LIKE_WILDCARD))</span>
            {
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if (ByteBufferUtil.startsWith(value, LIKE_WILDCARD))</span>
                {
<span class="nc" id="L751">                    operator = Operator.LIKE_CONTAINS;</span>
<span class="nc" id="L752">                    beginIndex =+ 1;</span>
                }
                else
                {
<span class="nc" id="L756">                    operator = Operator.LIKE_PREFIX;</span>
                }
            }
<span class="nc bnc" id="L759" title="All 2 branches missed.">            else if (ByteBufferUtil.startsWith(value, LIKE_WILDCARD))</span>
            {
<span class="nc" id="L761">                operator = Operator.LIKE_SUFFIX;</span>
<span class="nc" id="L762">                beginIndex += 1;</span>
<span class="nc" id="L763">                endIndex += 1;</span>
            }
            else
            {
<span class="nc" id="L767">                operator = Operator.LIKE_MATCHES;</span>
<span class="nc" id="L768">                endIndex += 1;</span>
            }

<span class="nc bnc" id="L771" title="All 4 branches missed.">            if (endIndex == 0 || beginIndex == endIndex)</span>
<span class="nc" id="L772">                throw invalidRequest(&quot;LIKE value can't be empty.&quot;);</span>

<span class="nc" id="L774">            ByteBuffer newValue = value.duplicate();</span>
<span class="nc" id="L775">            newValue.position(beginIndex);</span>
<span class="nc" id="L776">            newValue.limit(endIndex);</span>
<span class="nc" id="L777">            return Pair.create(operator, newValue);</span>
        }
    }

    /**
     * Super Column Compatibiltiy
     */

<span class="nc bnc" id="L785" title="All 2 branches missed.">    public static class SuperColumnMultiEQRestriction extends EQRestriction</span>
    {
        public ByteBuffer firstValue;
        public ByteBuffer secondValue;

        public SuperColumnMultiEQRestriction(ColumnDefinition columnDef, Term value)
        {
<span class="nc" id="L792">            super(columnDef, value);</span>
<span class="nc" id="L793">        }</span>

        @Override
        public MultiCBuilder appendTo(MultiCBuilder builder, QueryOptions options)
        {
<span class="nc" id="L798">            Term term = value.bind(options);</span>

<span class="nc bnc" id="L800" title="All 4 branches missed.">            assert (term instanceof Tuples.Value);</span>
<span class="nc" id="L801">            firstValue = ((Tuples.Value)term).getElements().get(0);</span>
<span class="nc" id="L802">            secondValue = ((Tuples.Value)term).getElements().get(1);</span>

<span class="nc" id="L804">            builder.addElementToAll(firstValue);</span>
<span class="nc" id="L805">            checkFalse(builder.containsNull(), &quot;Invalid null value in condition for column %s&quot;, columnDef.name);</span>
<span class="nc" id="L806">            checkFalse(builder.containsUnset(), &quot;Invalid unset value for column %s&quot;, columnDef.name);</span>
<span class="nc" id="L807">            return builder;</span>
        }
    }

<span class="nc bnc" id="L811" title="All 2 branches missed.">    public static class SuperColumnMultiSliceRestriction extends SliceRestriction</span>
    {
        public ByteBuffer firstValue;
        public ByteBuffer secondValue;

        // These are here to avoid polluting SliceRestriction
        public final Bound bound;
        public final boolean trueInclusive;
        public SuperColumnMultiSliceRestriction(ColumnDefinition columnDef, Bound bound, boolean inclusive, Term term)
        {
<span class="nc" id="L821">            super(columnDef, bound, true, term);</span>
<span class="nc" id="L822">            this.bound = bound;</span>
<span class="nc" id="L823">            this.trueInclusive = inclusive;</span>

<span class="nc" id="L825">        }</span>

        @Override
        public MultiCBuilder appendBoundTo(MultiCBuilder builder, Bound bound, QueryOptions options)
        {
<span class="nc" id="L830">            Bound b = bound.reverseIfNeeded(getFirstColumn());</span>

<span class="nc bnc" id="L832" title="All 2 branches missed.">            if (!hasBound(b))</span>
<span class="nc" id="L833">                return builder;</span>

<span class="nc" id="L835">            Term term = slice.bound(b);</span>

<span class="nc bnc" id="L837" title="All 4 branches missed.">            assert (term instanceof Tuples.Value);</span>
<span class="nc" id="L838">            firstValue = ((Tuples.Value)term).getElements().get(0);</span>
<span class="nc" id="L839">            secondValue = ((Tuples.Value)term).getElements().get(1);</span>

<span class="nc" id="L841">            checkBindValueSet(firstValue, &quot;Invalid unset value for column %s&quot;, columnDef.name);</span>
<span class="nc" id="L842">            checkBindValueSet(secondValue, &quot;Invalid unset value for column %s&quot;, columnDef.name);</span>
<span class="nc" id="L843">            return builder.addElementToAll(firstValue);</span>

        }
    }

    public static final class SuperColumnKeyEQRestriction extends EQRestriction
    {
        public SuperColumnKeyEQRestriction(ColumnDefinition columnDef, Term value)
        {
<span class="nc" id="L852">            super(columnDef, value);</span>
<span class="nc" id="L853">        }</span>

        public ByteBuffer bindValue(QueryOptions options)
        {
<span class="nc" id="L857">            return value.bindAndGet(options);</span>
        }

        @Override
        public MultiCBuilder appendBoundTo(MultiCBuilder builder, Bound bound, QueryOptions options)
        {
            // no-op
<span class="nc" id="L864">            return builder;</span>
        }

        @Override
        public void addRowFilterTo(RowFilter filter, SecondaryIndexManager indexManager, QueryOptions options) throws InvalidRequestException
        {
            // no-op
<span class="nc" id="L871">        }</span>
    }

    public static abstract class SuperColumnKeyINRestriction extends INRestriction
    {
        public SuperColumnKeyINRestriction(ColumnDefinition columnDef)
        {
<span class="nc" id="L878">            super(columnDef);</span>
<span class="nc" id="L879">        }</span>

        @Override
        public MultiCBuilder appendTo(MultiCBuilder builder, QueryOptions options)
        {
            // no-op
<span class="nc" id="L885">            return builder;</span>
        }

        @Override
        public void addRowFilterTo(RowFilter filter,
                                   SecondaryIndexManager indexManager,
                                   QueryOptions options) throws InvalidRequestException
        {
            // no-op
<span class="nc" id="L894">        }</span>

        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
            // no-op
<span class="nc" id="L899">        }</span>

        MultiColumnRestriction toMultiColumnRestriction()
        {
            // no-op
<span class="nc" id="L904">            return null;</span>
        }

        public abstract List&lt;ByteBuffer&gt; getValues(QueryOptions options) throws InvalidRequestException;
    }

    public static class SuperColumnKeyINRestrictionWithMarkers extends SuperColumnKeyINRestriction
    {
        protected final AbstractMarker marker;

        public SuperColumnKeyINRestrictionWithMarkers(ColumnDefinition columnDef, AbstractMarker marker)
        {
<span class="nc" id="L916">            super(columnDef);</span>
<span class="nc" id="L917">            this.marker = marker;</span>
<span class="nc" id="L918">        }</span>

        public List&lt;ByteBuffer&gt; getValues(QueryOptions options) throws InvalidRequestException
        {
<span class="nc" id="L922">            Terminal term = marker.bind(options);</span>
<span class="nc" id="L923">            checkNotNull(term, &quot;Invalid null value for column %s&quot;, columnDef.name);</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">            checkFalse(term == Constants.UNSET_VALUE, &quot;Invalid unset value for column %s&quot;, columnDef.name);</span>
<span class="nc" id="L925">            Term.MultiItemTerminal lval = (Term.MultiItemTerminal) term;</span>
<span class="nc" id="L926">            return lval.getElements();</span>
        }
    }

    public static class SuperColumnKeyINRestrictionWithValues extends SuperColumnKeyINRestriction
    {
        private final List&lt;Term&gt; values;

        public SuperColumnKeyINRestrictionWithValues(ColumnDefinition columnDef, List&lt;Term&gt; values)
        {
<span class="nc" id="L936">            super(columnDef);</span>
<span class="nc" id="L937">            this.values = values;</span>
<span class="nc" id="L938">        }</span>

        public List&lt;ByteBuffer&gt; getValues(QueryOptions options) throws InvalidRequestException
        {
<span class="nc" id="L942">            List&lt;ByteBuffer&gt; buffers = new ArrayList&lt;&gt;(values.size());</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">            for (Term value : values)</span>
<span class="nc" id="L944">                buffers.add(value.bindAndGet(options));</span>
<span class="nc" id="L945">            return buffers;</span>
        }
    }

    public static class SuperColumnKeySliceRestriction extends SliceRestriction
    {
        // These are here to avoid polluting SliceRestriction
        private Term term;

        public SuperColumnKeySliceRestriction(ColumnDefinition columnDef, Bound bound, boolean inclusive, Term term)
        {
<span class="nc" id="L956">            super(columnDef, bound, inclusive, term);</span>
<span class="nc" id="L957">            this.term = term;</span>
<span class="nc" id="L958">        }</span>

        public ByteBuffer bindValue(QueryOptions options)
        {
<span class="nc" id="L962">            return term.bindAndGet(options);</span>
        }

        @Override
        public MultiCBuilder appendBoundTo(MultiCBuilder builder, Bound bound, QueryOptions options)
        {
            // no-op
<span class="nc" id="L969">            return builder;</span>
        }

        @Override
        public void addRowFilterTo(RowFilter filter, SecondaryIndexManager indexManager, QueryOptions options) throws InvalidRequestException
        {
            // no-op
<span class="nc" id="L976">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>