<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataLimits.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.filter</a> &gt; <span class="el_source">DataLimits.java</span></div><h1>DataLimits.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.filter;

import java.io.IOException;
import java.nio.ByteBuffer;

import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.aggregation.GroupMaker;
import org.apache.cassandra.db.aggregation.GroupingState;
import org.apache.cassandra.db.aggregation.AggregationSpecification;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.db.partitions.*;
import org.apache.cassandra.db.transform.BasePartitions;
import org.apache.cassandra.db.transform.BaseRows;
import org.apache.cassandra.db.transform.StoppingTransformation;
import org.apache.cassandra.db.transform.Transformation;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.utils.ByteBufferUtil;

/**
 * Object in charge of tracking if we have fetch enough data for a given query.
 *
 * The reason this is not just a simple integer is that Thrift and CQL3 count
 * stuffs in different ways. This is what abstract those differences.
 */
<span class="fc" id="L44">public abstract class DataLimits</span>
{
<span class="fc" id="L46">    public static final Serializer serializer = new Serializer();</span>

    public static final int NO_LIMIT = Integer.MAX_VALUE;

<span class="fc" id="L50">    public static final DataLimits NONE = new CQLLimits(NO_LIMIT)</span>
<span class="fc" id="L51">    {</span>
        @Override
        public boolean hasEnoughLiveData(CachedPartition cached, int nowInSec, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
        {
<span class="nc" id="L55">            return false;</span>
        }

        @Override
        public UnfilteredPartitionIterator filter(UnfilteredPartitionIterator iter,
                                                  int nowInSec,
                                                  boolean countPartitionsWithOnlyStaticData)
        {
<span class="fc" id="L63">            return iter;</span>
        }

        @Override
        public UnfilteredRowIterator filter(UnfilteredRowIterator iter,
                                            int nowInSec,
                                            boolean countPartitionsWithOnlyStaticData)
        {
<span class="nc" id="L71">            return iter;</span>
        }

        @Override
        public PartitionIterator filter(PartitionIterator iter, int nowInSec, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
        {
<span class="fc" id="L77">            return iter;</span>
        }
    };

    // We currently deal with distinct queries by querying full partitions but limiting the result at 1 row per
    // partition (see SelectStatement.makeFilter). So an &quot;unbounded&quot; distinct is still actually doing some filtering.
<span class="fc" id="L83">    public static final DataLimits DISTINCT_NONE = new CQLLimits(NO_LIMIT, 1, true);</span>

<span class="fc" id="L85">    public enum Kind { CQL_LIMIT, CQL_PAGING_LIMIT, THRIFT_LIMIT, SUPER_COLUMN_COUNTING_LIMIT, CQL_GROUP_BY_LIMIT, CQL_GROUP_BY_PAGING_LIMIT }</span>

    public static DataLimits cqlLimits(int cqlRowLimit)
    {
<span class="nc bnc" id="L89" title="All 2 branches missed.">        return cqlRowLimit == NO_LIMIT ? NONE : new CQLLimits(cqlRowLimit);</span>
    }

    // mixed mode partition range scans on compact storage tables without clustering columns coordinated by 2.x are
    // returned as one (cql) row per cell, but we need to count each partition as a single row. So we just return a
    // CQLLimits instance that doesn't count rows towards it's limit. See CASSANDRA-15072
    public static DataLimits legacyCompactStaticCqlLimits(int cqlRowLimits)
    {
<span class="nc" id="L97">        return new CQLLimits(cqlRowLimits) {</span>
            public Counter newCounter(int nowInSec, boolean assumeLiveData, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
            {
<span class="nc" id="L100">                return new CQLCounter(nowInSec, assumeLiveData, countPartitionsWithOnlyStaticData, enforceStrictLiveness) {</span>
                    public Row applyToRow(Row row)
                    {
                        // noop: only count full partitions
<span class="nc" id="L104">                        return row;</span>
                    }
                };
            }
        };
    }

    public static DataLimits cqlLimits(int cqlRowLimit, int perPartitionLimit)
    {
<span class="pc bpc" id="L113" title="1 of 4 branches missed.">        return cqlRowLimit == NO_LIMIT &amp;&amp; perPartitionLimit == NO_LIMIT</span>
             ? NONE
             : new CQLLimits(cqlRowLimit, perPartitionLimit);
    }

    private static DataLimits cqlLimits(int cqlRowLimit, int perPartitionLimit, boolean isDistinct)
    {
<span class="pc bpc" id="L120" title="2 of 6 branches missed.">        return cqlRowLimit == NO_LIMIT &amp;&amp; perPartitionLimit == NO_LIMIT &amp;&amp; !isDistinct</span>
             ? NONE
             : new CQLLimits(cqlRowLimit, perPartitionLimit, isDistinct);
    }

    public static DataLimits groupByLimits(int groupLimit,
                                           int groupPerPartitionLimit,
                                           int rowLimit,
                                           AggregationSpecification groupBySpec)
    {
<span class="nc" id="L130">        return new CQLGroupByLimits(groupLimit, groupPerPartitionLimit, rowLimit, groupBySpec);</span>
    }

    public static DataLimits distinctLimits(int cqlRowLimit)
    {
<span class="nc" id="L135">        return CQLLimits.distinct(cqlRowLimit);</span>
    }

    public static DataLimits thriftLimits(int partitionLimit, int cellPerPartitionLimit)
    {
<span class="nc" id="L140">        return new ThriftLimits(partitionLimit, cellPerPartitionLimit);</span>
    }

    public static DataLimits superColumnCountingLimits(int partitionLimit, int cellPerPartitionLimit)
    {
<span class="nc" id="L145">        return new SuperColumnCountingLimits(partitionLimit, cellPerPartitionLimit);</span>
    }

    public abstract Kind kind();

    public abstract boolean isUnlimited();
    public abstract boolean isDistinct();

    public boolean isGroupByLimit()
    {
<span class="nc" id="L155">        return false;</span>
    }

    public boolean isExhausted(Counter counter)
    {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        return counter.counted() &lt; count();</span>
    }

    public abstract DataLimits forPaging(int pageSize);
    public abstract DataLimits forPaging(int pageSize, ByteBuffer lastReturnedKey, int lastReturnedKeyRemaining);

    public abstract DataLimits forShortReadRetry(int toFetch);

    /**
     * Creates a &lt;code&gt;DataLimits&lt;/code&gt; instance to be used for paginating internally GROUP BY queries.
     *
     * @param state the &lt;code&gt;GroupMaker&lt;/code&gt; state
     * @return a &lt;code&gt;DataLimits&lt;/code&gt; instance to be used for paginating internally GROUP BY queries
     */
    public DataLimits forGroupByInternalPaging(GroupingState state)
    {
<span class="nc" id="L176">        throw new UnsupportedOperationException();</span>
    }

    public abstract boolean hasEnoughLiveData(CachedPartition cached,
                                              int nowInSec,
                                              boolean countPartitionsWithOnlyStaticData,
                                              boolean enforceStrictLiveness);

    /**
     * Returns a new {@code Counter} for this limits.
     *
     * @param nowInSec the current time in second (to decide what is expired or not).
     * @param assumeLiveData if true, the counter will assume that every row passed is live and won't
     * thus check for liveness, otherwise it will. This should be {@code true} when used on a
     * {@code RowIterator} (since it only returns live rows), false otherwise.
     * @param countPartitionsWithOnlyStaticData if {@code true} the partitions with only static data should be counted
     * as 1 valid row.
     * @param enforceStrictLiveness whether the row should be purged if there is no PK liveness info,
     *                              normally retrieved from {@link CFMetaData#enforceStrictLiveness()}
     * @return a new {@code Counter} for this limits.
     */
    public abstract Counter newCounter(int nowInSec,
                                       boolean assumeLiveData,
                                       boolean countPartitionsWithOnlyStaticData,
                                       boolean enforceStrictLiveness);

    /**
     * The max number of results this limits enforces.
     * &lt;p&gt;
     * Note that the actual definition of &quot;results&quot; depends a bit: for CQL, it's always rows, but for
     * thrift, it means cells.
     *
     * @return the maximum number of results this limits enforces.
     */
    public abstract int count();

    public abstract int perPartitionCount();

    /**
     * Returns equivalent limits but where any internal state kept to track where we are of paging and/or grouping is
     * discarded.
     */
    public abstract DataLimits withoutState();

    public UnfilteredPartitionIterator filter(UnfilteredPartitionIterator iter,
                                              int nowInSec,
                                              boolean countPartitionsWithOnlyStaticData)
    {
<span class="fc" id="L224">        return this.newCounter(nowInSec,</span>
                               false,
                               countPartitionsWithOnlyStaticData,
<span class="fc" id="L227">                               iter.metadata().enforceStrictLiveness())</span>
<span class="fc" id="L228">                   .applyTo(iter);</span>
    }

    public UnfilteredRowIterator filter(UnfilteredRowIterator iter,
                                        int nowInSec,
                                        boolean countPartitionsWithOnlyStaticData)
    {
<span class="nc" id="L235">        return this.newCounter(nowInSec,</span>
                               false,
                               countPartitionsWithOnlyStaticData,
<span class="nc" id="L238">                               iter.metadata().enforceStrictLiveness())</span>
<span class="nc" id="L239">                   .applyTo(iter);</span>
    }

    public PartitionIterator filter(PartitionIterator iter, int nowInSec, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
    {
<span class="fc" id="L244">        return this.newCounter(nowInSec, true, countPartitionsWithOnlyStaticData, enforceStrictLiveness).applyTo(iter);</span>
    }

    /**
     * Estimate the number of results (the definition of &quot;results&quot; will be rows for CQL queries
     * and partitions for thrift ones) that a full scan of the provided cfs would yield.
     */
    public abstract float estimateTotalResults(ColumnFamilyStore cfs);

    public static abstract class Counter extends StoppingTransformation&lt;BaseRowIterator&lt;?&gt;&gt;
    {
        protected final int nowInSec;
        protected final boolean assumeLiveData;
        private final boolean enforceStrictLiveness;

        // false means we do not propagate our stop signals onto the iterator, we only count
<span class="fc" id="L260">        private boolean enforceLimits = true;</span>

        protected Counter(int nowInSec, boolean assumeLiveData, boolean enforceStrictLiveness)
<span class="fc" id="L263">        {</span>
<span class="fc" id="L264">            this.nowInSec = nowInSec;</span>
<span class="fc" id="L265">            this.assumeLiveData = assumeLiveData;</span>
<span class="fc" id="L266">            this.enforceStrictLiveness = enforceStrictLiveness;</span>
<span class="fc" id="L267">        }</span>

        public Counter onlyCount()
        {
<span class="nc" id="L271">            this.enforceLimits = false;</span>
<span class="nc" id="L272">            return this;</span>
        }

        public PartitionIterator applyTo(PartitionIterator partitions)
        {
<span class="fc" id="L277">            return Transformation.apply(partitions, this);</span>
        }

        public UnfilteredPartitionIterator applyTo(UnfilteredPartitionIterator partitions)
        {
<span class="fc" id="L282">            return Transformation.apply(partitions, this);</span>
        }

        public UnfilteredRowIterator applyTo(UnfilteredRowIterator partition)
        {
<span class="nc" id="L287">            return (UnfilteredRowIterator) applyToPartition(partition);</span>
        }

        public RowIterator applyTo(RowIterator partition)
        {
<span class="nc" id="L292">            return (RowIterator) applyToPartition(partition);</span>
        }

        /**
         * The number of results counted.
         * &lt;p&gt;
         * Note that the definition of &quot;results&quot; should be the same that for {@link #count}.
         *
         * @return the number of results counted.
         */
        public abstract int counted();

        public abstract int countedInCurrentPartition();

        /**
         * The number of rows counted.
         *
         * @return the number of rows counted.
         */
        public abstract int rowCounted();

        /**
         * The number of rows counted in the current partition.
         *
         * @return the number of rows counted in the current partition.
         */
        public abstract int rowCountedInCurrentPartition();

        public abstract boolean isDone();
        public abstract boolean isDoneForPartition();

        protected boolean isLive(Row row)
        {
<span class="nc bnc" id="L325" title="All 4 branches missed.">            return assumeLiveData || row.hasLiveData(nowInSec, enforceStrictLiveness);</span>
        }

        @Override
        protected BaseRowIterator&lt;?&gt; applyToPartition(BaseRowIterator&lt;?&gt; partition)
        {
<span class="nc bnc" id="L331" title="All 2 branches missed.">            return partition instanceof UnfilteredRowIterator ? Transformation.apply((UnfilteredRowIterator) partition, this)</span>
<span class="nc" id="L332">                                                              : Transformation.apply((RowIterator) partition, this);</span>
        }

        // called before we process a given partition
        protected abstract void applyToPartition(DecoratedKey partitionKey, Row staticRow);

        @Override
        protected void attachTo(BasePartitions partitions)
        {
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">            if (enforceLimits)</span>
<span class="fc" id="L342">                super.attachTo(partitions);</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">            if (isDone())</span>
<span class="nc" id="L344">                stop();</span>
<span class="fc" id="L345">        }</span>

        @Override
        protected void attachTo(BaseRows rows)
        {
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (enforceLimits)</span>
<span class="nc" id="L351">                super.attachTo(rows);</span>
<span class="nc" id="L352">            applyToPartition(rows.partitionKey(), rows.staticRow());</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (isDoneForPartition())</span>
<span class="nc" id="L354">                stopInPartition();</span>
<span class="nc" id="L355">        }</span>

        @Override
        public void onClose()
        {
<span class="fc" id="L360">            super.onClose();</span>
<span class="fc" id="L361">        }</span>
    }

    /**
     * Limits used by CQL; this counts rows.
     */
    private static class CQLLimits extends DataLimits
    {
        protected final int rowLimit;
        protected final int perPartitionLimit;

        // Whether the query is a distinct query or not.
        protected final boolean isDistinct;

        private CQLLimits(int rowLimit)
        {
<span class="fc" id="L377">            this(rowLimit, NO_LIMIT);</span>
<span class="fc" id="L378">        }</span>

        private CQLLimits(int rowLimit, int perPartitionLimit)
        {
<span class="fc" id="L382">            this(rowLimit, perPartitionLimit, false);</span>
<span class="fc" id="L383">        }</span>

        private CQLLimits(int rowLimit, int perPartitionLimit, boolean isDistinct)
<span class="fc" id="L386">        {</span>
<span class="fc" id="L387">            this.rowLimit = rowLimit;</span>
<span class="fc" id="L388">            this.perPartitionLimit = perPartitionLimit;</span>
<span class="fc" id="L389">            this.isDistinct = isDistinct;</span>
<span class="fc" id="L390">        }</span>

        private static CQLLimits distinct(int rowLimit)
        {
<span class="nc" id="L394">            return new CQLLimits(rowLimit, 1, true);</span>
        }

        public Kind kind()
        {
<span class="fc" id="L399">            return Kind.CQL_LIMIT;</span>
        }

        public boolean isUnlimited()
        {
<span class="nc bnc" id="L404" title="All 4 branches missed.">            return rowLimit == NO_LIMIT &amp;&amp; perPartitionLimit == NO_LIMIT;</span>
        }

        public boolean isDistinct()
        {
<span class="nc" id="L409">            return isDistinct;</span>
        }

        public DataLimits forPaging(int pageSize)
        {
<span class="fc" id="L414">            return new CQLLimits(pageSize, perPartitionLimit, isDistinct);</span>
        }

        public DataLimits forPaging(int pageSize, ByteBuffer lastReturnedKey, int lastReturnedKeyRemaining)
        {
<span class="nc" id="L419">            return new CQLPagingLimits(pageSize, perPartitionLimit, isDistinct, lastReturnedKey, lastReturnedKeyRemaining);</span>
        }

        public DataLimits forShortReadRetry(int toFetch)
        {
<span class="nc" id="L424">            return new CQLLimits(toFetch, perPartitionLimit, isDistinct);</span>
        }

        public boolean hasEnoughLiveData(CachedPartition cached, int nowInSec, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
        {
            // We want the number of row that are currently live. Getting that precise number forces
            // us to iterate the cached partition in general, but we can avoid that if:
            //   - The number of rows with at least one non-expiring cell is greater than what we ask,
            //     in which case we know we have enough live.
            //   - The number of rows is less than requested, in which case we  know we won't have enough.
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (cached.rowsWithNonExpiringCells() &gt;= rowLimit)</span>
<span class="nc" id="L435">                return true;</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">            if (cached.rowCount() &lt; rowLimit)</span>
<span class="nc" id="L438">                return false;</span>

            // Otherwise, we need to re-count

<span class="nc" id="L442">            DataLimits.Counter counter = newCounter(nowInSec, false, countPartitionsWithOnlyStaticData, enforceStrictLiveness);</span>
<span class="nc" id="L443">            try (UnfilteredRowIterator cacheIter = cached.unfilteredIterator(ColumnFilter.selection(cached.columns()), Slices.ALL, false);</span>
<span class="nc" id="L444">                 UnfilteredRowIterator iter = counter.applyTo(cacheIter))</span>
            {
                // Consume the iterator until we've counted enough
<span class="nc bnc" id="L447" title="All 2 branches missed.">                while (iter.hasNext())</span>
<span class="nc" id="L448">                    iter.next();</span>
<span class="nc" id="L449">                return counter.isDone();</span>
            }
        }

        public Counter newCounter(int nowInSec,
                                  boolean assumeLiveData,
                                  boolean countPartitionsWithOnlyStaticData,
                                  boolean enforceStrictLiveness)
        {
<span class="fc" id="L458">            return new CQLCounter(nowInSec, assumeLiveData, countPartitionsWithOnlyStaticData, enforceStrictLiveness);</span>
        }

        public int count()
        {
<span class="fc" id="L463">            return rowLimit;</span>
        }

        public int perPartitionCount()
        {
<span class="fc" id="L468">            return perPartitionLimit;</span>
        }

        public DataLimits withoutState()
        {
<span class="nc" id="L473">            return this;</span>
        }

        public float estimateTotalResults(ColumnFamilyStore cfs)
        {
            // TODO: we should start storing stats on the number of rows (instead of the number of cells, which
            // is what getMeanColumns returns)
<span class="fc" id="L480">            float rowsPerPartition = ((float) cfs.getMeanColumns()) / cfs.metadata.partitionColumns().regulars.size();</span>
<span class="fc" id="L481">            return rowsPerPartition * (cfs.estimateKeys());</span>
        }

        protected class CQLCounter extends Counter
        {
            protected int rowCounted;
            protected int rowInCurrentPartition;
            protected final boolean countPartitionsWithOnlyStaticData;

            protected boolean hasLiveStaticRow;

            public CQLCounter(int nowInSec,
                              boolean assumeLiveData,
                              boolean countPartitionsWithOnlyStaticData,
                              boolean enforceStrictLiveness)
<span class="fc" id="L496">            {</span>
<span class="fc" id="L497">                super(nowInSec, assumeLiveData, enforceStrictLiveness);</span>
<span class="fc" id="L498">                this.countPartitionsWithOnlyStaticData = countPartitionsWithOnlyStaticData;</span>
<span class="fc" id="L499">            }</span>

            @Override
            public void applyToPartition(DecoratedKey partitionKey, Row staticRow)
            {
<span class="nc" id="L504">                rowInCurrentPartition = 0;</span>
<span class="nc bnc" id="L505" title="All 4 branches missed.">                hasLiveStaticRow = !staticRow.isEmpty() &amp;&amp; isLive(staticRow);</span>
<span class="nc" id="L506">            }</span>

            @Override
            public Row applyToRow(Row row)
            {
<span class="nc bnc" id="L511" title="All 2 branches missed.">                if (isLive(row))</span>
<span class="nc" id="L512">                    incrementRowCount();</span>
<span class="nc" id="L513">                return row;</span>
            }

            @Override
            public void onPartitionClose()
            {
                // Normally, we don't count static rows as from a CQL point of view, it will be merge with other
                // rows in the partition. However, if we only have the static row, it will be returned as one row
                // so count it.
<span class="nc bnc" id="L522" title="All 6 branches missed.">                if (countPartitionsWithOnlyStaticData &amp;&amp; hasLiveStaticRow &amp;&amp; rowInCurrentPartition == 0)</span>
<span class="nc" id="L523">                    incrementRowCount();</span>
<span class="nc" id="L524">                super.onPartitionClose();</span>
<span class="nc" id="L525">            }</span>

            protected void incrementRowCount()
            {
<span class="nc bnc" id="L529" title="All 2 branches missed.">                if (++rowCounted &gt;= rowLimit)</span>
<span class="nc" id="L530">                    stop();</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                if (++rowInCurrentPartition &gt;= perPartitionLimit)</span>
<span class="nc" id="L532">                    stopInPartition();</span>
<span class="nc" id="L533">            }</span>

            public int counted()
            {
<span class="fc" id="L537">                return rowCounted;</span>
            }

            public int countedInCurrentPartition()
            {
<span class="fc" id="L542">                return rowInCurrentPartition;</span>
            }

            public int rowCounted()
            {
<span class="nc" id="L547">                return rowCounted;</span>
            }

            public int rowCountedInCurrentPartition()
            {
<span class="nc" id="L552">                return rowInCurrentPartition;</span>
            }

            public boolean isDone()
            {
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">                return rowCounted &gt;= rowLimit;</span>
            }

            public boolean isDoneForPartition()
            {
<span class="nc bnc" id="L562" title="All 4 branches missed.">                return isDone() || rowInCurrentPartition &gt;= perPartitionLimit;</span>
            }
        }

        @Override
        public String toString()
        {
<span class="nc" id="L569">            StringBuilder sb = new StringBuilder();</span>

<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (rowLimit != NO_LIMIT)</span>
            {
<span class="nc" id="L573">                sb.append(&quot;LIMIT &quot;).append(rowLimit);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                if (perPartitionLimit != NO_LIMIT)</span>
<span class="nc" id="L575">                    sb.append(' ');</span>
            }

<span class="nc bnc" id="L578" title="All 2 branches missed.">            if (perPartitionLimit != NO_LIMIT)</span>
<span class="nc" id="L579">                sb.append(&quot;PER PARTITION LIMIT &quot;).append(perPartitionLimit);</span>

<span class="nc" id="L581">            return sb.toString();</span>
        }
    }

    private static class CQLPagingLimits extends CQLLimits
    {
        private final ByteBuffer lastReturnedKey;
        private final int lastReturnedKeyRemaining;

        public CQLPagingLimits(int rowLimit, int perPartitionLimit, boolean isDistinct, ByteBuffer lastReturnedKey, int lastReturnedKeyRemaining)
        {
<span class="nc" id="L592">            super(rowLimit, perPartitionLimit, isDistinct);</span>
<span class="nc" id="L593">            this.lastReturnedKey = lastReturnedKey;</span>
<span class="nc" id="L594">            this.lastReturnedKeyRemaining = lastReturnedKeyRemaining;</span>
<span class="nc" id="L595">        }</span>

        @Override
        public Kind kind()
        {
<span class="nc" id="L600">            return Kind.CQL_PAGING_LIMIT;</span>
        }

        @Override
        public DataLimits forPaging(int pageSize)
        {
<span class="nc" id="L606">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public DataLimits forPaging(int pageSize, ByteBuffer lastReturnedKey, int lastReturnedKeyRemaining)
        {
<span class="nc" id="L612">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public DataLimits withoutState()
        {
<span class="nc" id="L618">            return new CQLLimits(rowLimit, perPartitionLimit, isDistinct);</span>
        }

        @Override
        public Counter newCounter(int nowInSec, boolean assumeLiveData, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
        {
<span class="nc" id="L624">            return new PagingAwareCounter(nowInSec, assumeLiveData, countPartitionsWithOnlyStaticData, enforceStrictLiveness);</span>
        }

        private class PagingAwareCounter extends CQLCounter
        {
            private PagingAwareCounter(int nowInSec,
                                       boolean assumeLiveData,
                                       boolean countPartitionsWithOnlyStaticData,
                                       boolean enforceStrictLiveness)
<span class="nc" id="L633">            {</span>
<span class="nc" id="L634">                super(nowInSec, assumeLiveData, countPartitionsWithOnlyStaticData, enforceStrictLiveness);</span>
<span class="nc" id="L635">            }</span>

            @Override
            public void applyToPartition(DecoratedKey partitionKey, Row staticRow)
            {
<span class="nc bnc" id="L640" title="All 2 branches missed.">                if (partitionKey.getKey().equals(lastReturnedKey))</span>
                {
<span class="nc" id="L642">                    rowInCurrentPartition = perPartitionLimit - lastReturnedKeyRemaining;</span>
                    // lastReturnedKey is the last key for which we're returned rows in the first page.
                    // So, since we know we have returned rows, we know we have accounted for the static row
                    // if any already, so force hasLiveStaticRow to false so we make sure to not count it
                    // once more.
<span class="nc" id="L647">                    hasLiveStaticRow = false;</span>
                }
                else
                {
<span class="nc" id="L651">                    super.applyToPartition(partitionKey, staticRow);</span>
                }
<span class="nc" id="L653">            }</span>
        }
    }

    /**
     * &lt;code&gt;CQLLimits&lt;/code&gt; used for GROUP BY queries or queries with aggregates.
     * &lt;p&gt;Internally, GROUP BY queries are always paginated by number of rows to avoid OOMExceptions. By consequence,
     * the limits keep track of the number of rows as well as the number of groups.&lt;/p&gt;
     * &lt;p&gt;A group can only be counted if the next group or the end of the data is reached.&lt;/p&gt;
     */
    private static class CQLGroupByLimits extends CQLLimits
    {
        /**
         * The &lt;code&gt;GroupMaker&lt;/code&gt; state
         */
        protected final GroupingState state;

        /**
         * The GROUP BY specification
         */
        protected final AggregationSpecification groupBySpec;

        /**
         * The limit on the number of groups
         */
        protected final int groupLimit;

        /**
         * The limit on the number of groups per partition
         */
        protected final int groupPerPartitionLimit;

        public CQLGroupByLimits(int groupLimit,
                                int groupPerPartitionLimit,
                                int rowLimit,
                                AggregationSpecification groupBySpec)
        {
<span class="nc" id="L690">            this(groupLimit, groupPerPartitionLimit, rowLimit, groupBySpec, GroupingState.EMPTY_STATE);</span>
<span class="nc" id="L691">        }</span>

        private CQLGroupByLimits(int groupLimit,
                                 int groupPerPartitionLimit,
                                 int rowLimit,
                                 AggregationSpecification groupBySpec,
                                 GroupingState state)
        {
<span class="nc" id="L699">            super(rowLimit, NO_LIMIT, false);</span>
<span class="nc" id="L700">            this.groupLimit = groupLimit;</span>
<span class="nc" id="L701">            this.groupPerPartitionLimit = groupPerPartitionLimit;</span>
<span class="nc" id="L702">            this.groupBySpec = groupBySpec;</span>
<span class="nc" id="L703">            this.state = state;</span>
<span class="nc" id="L704">        }</span>

        @Override
        public Kind kind()
        {
<span class="nc" id="L709">            return Kind.CQL_GROUP_BY_LIMIT;</span>
        }

        @Override
        public boolean isGroupByLimit()
        {
<span class="nc" id="L715">            return true;</span>
        }

        public boolean isUnlimited()
        {
<span class="nc bnc" id="L720" title="All 6 branches missed.">            return groupLimit == NO_LIMIT &amp;&amp; groupPerPartitionLimit == NO_LIMIT &amp;&amp; rowLimit == NO_LIMIT;</span>
        }

        public DataLimits forShortReadRetry(int toFetch)
        {
<span class="nc" id="L725">            return new CQLLimits(toFetch);</span>
        }

        @Override
        public float estimateTotalResults(ColumnFamilyStore cfs)
        {
            // For the moment, we return the estimated number of rows as we have no good way of estimating 
            // the number of groups that will be returned. Hopefully, we should be able to fix
            // that problem at some point.
<span class="nc" id="L734">            return super.estimateTotalResults(cfs);</span>
        }

        @Override
        public DataLimits forPaging(int pageSize)
        {
<span class="nc" id="L740">            return new CQLGroupByLimits(pageSize,</span>
                                        groupPerPartitionLimit,
                                        rowLimit,
                                        groupBySpec,
                                        state);
        }

        @Override
        public DataLimits forPaging(int pageSize, ByteBuffer lastReturnedKey, int lastReturnedKeyRemaining)
        {
<span class="nc" id="L750">            return new CQLGroupByPagingLimits(pageSize,</span>
                                              groupPerPartitionLimit,
                                              rowLimit,
                                              groupBySpec,
                                              state,
                                              lastReturnedKey,
                                              lastReturnedKeyRemaining);
        }

        @Override
        public DataLimits forGroupByInternalPaging(GroupingState state)
        {
<span class="nc" id="L762">            return new CQLGroupByLimits(rowLimit,</span>
                                        groupPerPartitionLimit,
                                        rowLimit,
                                        groupBySpec,
                                        state);
        }

        @Override
        public Counter newCounter(int nowInSec,
                                  boolean assumeLiveData,
                                  boolean countPartitionsWithOnlyStaticData,
                                  boolean enforceStrictLiveness)
        {
<span class="nc" id="L775">            return new GroupByAwareCounter(nowInSec, assumeLiveData, countPartitionsWithOnlyStaticData, enforceStrictLiveness);</span>
        }

        @Override
        public int count()
        {
<span class="nc" id="L781">            return groupLimit;</span>
        }

        @Override
        public int perPartitionCount()
        {
<span class="nc" id="L787">            return groupPerPartitionLimit;</span>
        }

        @Override
        public DataLimits withoutState()
        {
<span class="nc bnc" id="L793" title="All 2 branches missed.">            return state == GroupingState.EMPTY_STATE</span>
                 ? this
                 : new CQLGroupByLimits(groupLimit, groupPerPartitionLimit, rowLimit, groupBySpec);
        }

        @Override
        public String toString()
        {
<span class="nc" id="L801">            StringBuilder sb = new StringBuilder();</span>

<span class="nc bnc" id="L803" title="All 2 branches missed.">            if (groupLimit != NO_LIMIT)</span>
            {
<span class="nc" id="L805">                sb.append(&quot;GROUP LIMIT &quot;).append(groupLimit);</span>
<span class="nc bnc" id="L806" title="All 4 branches missed.">                if (groupPerPartitionLimit != NO_LIMIT || rowLimit != NO_LIMIT)</span>
<span class="nc" id="L807">                    sb.append(' ');</span>
            }

<span class="nc bnc" id="L810" title="All 2 branches missed.">            if (groupPerPartitionLimit != NO_LIMIT)</span>
            {
<span class="nc" id="L812">                sb.append(&quot;GROUP PER PARTITION LIMIT &quot;).append(groupPerPartitionLimit);</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">                if (rowLimit != NO_LIMIT)</span>
<span class="nc" id="L814">                    sb.append(' ');</span>
            }

<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (rowLimit != NO_LIMIT)</span>
            {
<span class="nc" id="L819">                sb.append(&quot;LIMIT &quot;).append(rowLimit);</span>
            }

<span class="nc" id="L822">            return sb.toString();</span>
        }

        @Override
        public boolean isExhausted(Counter counter)
        {
<span class="nc bnc" id="L828" title="All 2 branches missed.">            return ((GroupByAwareCounter) counter).rowCounted &lt; rowLimit</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">                    &amp;&amp; counter.counted() &lt; groupLimit;</span>
        }

        protected class GroupByAwareCounter extends Counter
        {
            private final GroupMaker groupMaker;

            protected final boolean countPartitionsWithOnlyStaticData;

            /**
             * The key of the partition being processed.
             */
            protected DecoratedKey currentPartitionKey;

            /**
             * The number of rows counted so far.
             */
            protected int rowCounted;

            /**
             * The number of rows counted so far in the current partition.
             */
            protected int rowCountedInCurrentPartition;

            /**
             * The number of groups counted so far. A group is counted only once it is complete
             * (e.g the next one has been reached).
             */
            protected int groupCounted;

            /**
             * The number of groups in the current partition.
             */
            protected int groupInCurrentPartition;

            protected boolean hasGroupStarted;

            protected boolean hasLiveStaticRow;

            protected boolean hasReturnedRowsFromCurrentPartition;

            private GroupByAwareCounter(int nowInSec,
                                        boolean assumeLiveData,
                                        boolean countPartitionsWithOnlyStaticData,
                                        boolean enforceStrictLiveness)
<span class="nc" id="L874">            {</span>
<span class="nc" id="L875">                super(nowInSec, assumeLiveData, enforceStrictLiveness);</span>
<span class="nc" id="L876">                this.groupMaker = groupBySpec.newGroupMaker(state);</span>
<span class="nc" id="L877">                this.countPartitionsWithOnlyStaticData = countPartitionsWithOnlyStaticData;</span>

                // If the end of the partition was reached at the same time than the row limit, the last group might
                // not have been counted yet. Due to that we need to guess, based on the state, if the previous group
                // is still open.
<span class="nc" id="L882">                hasGroupStarted = state.hasClustering();</span>
<span class="nc" id="L883">            }</span>

            @Override
            public void applyToPartition(DecoratedKey partitionKey, Row staticRow)
            {
<span class="nc bnc" id="L888" title="All 2 branches missed.">                if (partitionKey.getKey().equals(state.partitionKey()))</span>
                {
                    // The only case were we could have state.partitionKey() equals to the partition key
                    // is if some of the partition rows have been returned in the previous page but the
                    // partition was not exhausted (as the state partition key has not been updated yet).
                    // Since we know we have returned rows, we know we have accounted for
                    // the static row if any already, so force hasLiveStaticRow to false so we make sure to not count it
                    // once more.
<span class="nc" id="L896">                    hasLiveStaticRow = false;</span>
<span class="nc" id="L897">                    hasReturnedRowsFromCurrentPartition = true;</span>
<span class="nc" id="L898">                    hasGroupStarted = true;</span>
                }
                else
                {
                    // We need to increment our count of groups if we have reached a new one and unless we had no new
                    // content added since we closed our last group (that is, if hasGroupStarted). Note that we may get
                    // here with hasGroupStarted == false in the following cases:
                    // * the partition limit was reached for the previous partition
                    // * the previous partition was containing only one static row
                    // * the rows of the last group of the previous partition were all marked as deleted
<span class="nc bnc" id="L908" title="All 4 branches missed.">                    if (hasGroupStarted &amp;&amp; groupMaker.isNewGroup(partitionKey, Clustering.STATIC_CLUSTERING))</span>
                    {
<span class="nc" id="L910">                        incrementGroupCount();</span>
                        // If we detect, before starting the new partition, that we are done, we need to increase
                        // the per partition group count of the previous partition as the next page will start from
                        // there.
<span class="nc bnc" id="L914" title="All 2 branches missed.">                        if (isDone())</span>
<span class="nc" id="L915">                            incrementGroupInCurrentPartitionCount();</span>
<span class="nc" id="L916">                        hasGroupStarted = false;</span>
                    }
<span class="nc" id="L918">                    hasReturnedRowsFromCurrentPartition = false;</span>
<span class="nc bnc" id="L919" title="All 4 branches missed.">                    hasLiveStaticRow = !staticRow.isEmpty() &amp;&amp; isLive(staticRow);</span>
                }
<span class="nc" id="L921">                currentPartitionKey = partitionKey;</span>
                // If we are done we need to preserve the groupInCurrentPartition and rowCountedInCurrentPartition
                // because the pager need to retrieve the count associated to the last value it has returned.
<span class="nc bnc" id="L924" title="All 2 branches missed.">                if (!isDone())</span>
                {
<span class="nc" id="L926">                    groupInCurrentPartition = 0;</span>
<span class="nc" id="L927">                    rowCountedInCurrentPartition = 0;</span>
                }
<span class="nc" id="L929">            }</span>

            @Override
            protected Row applyToStatic(Row row)
            {
                // It's possible that we're &quot;done&quot; if the partition we just started bumped the number of groups (in
                // applyToPartition() above), in which case Transformation will still call this method. In that case, we
                // want to ignore the static row, it should (and will) be returned with the next page/group if needs be.
<span class="nc bnc" id="L937" title="All 2 branches missed.">                if (isDone())</span>
                {
<span class="nc" id="L939">                    hasLiveStaticRow = false; // The row has not been returned</span>
<span class="nc" id="L940">                    return Rows.EMPTY_STATIC_ROW;</span>
                }
<span class="nc" id="L942">                return row;</span>
            }

            @Override
            public Row applyToRow(Row row)
            {
                // We want to check if the row belongs to a new group even if it has been deleted. The goal being
                // to minimize the chances of having to go through the same data twice if we detect on the next
                // non deleted row that we have reached the limit.
<span class="nc bnc" id="L951" title="All 2 branches missed.">                if (groupMaker.isNewGroup(currentPartitionKey, row.clustering()))</span>
                {
<span class="nc bnc" id="L953" title="All 2 branches missed.">                    if (hasGroupStarted)</span>
                    {
<span class="nc" id="L955">                        incrementGroupCount();</span>
<span class="nc" id="L956">                        incrementGroupInCurrentPartitionCount();</span>
                    }
<span class="nc" id="L958">                    hasGroupStarted = false;</span>
                }

                // That row may have made us increment the group count, which may mean we're done for this partition, in
                // which case we shouldn't count this row (it won't be returned).
<span class="nc bnc" id="L963" title="All 2 branches missed.">                if (isDoneForPartition())</span>
                {
<span class="nc" id="L965">                    hasGroupStarted = false;</span>
<span class="nc" id="L966">                    return null;</span>
                }

<span class="nc bnc" id="L969" title="All 2 branches missed.">                if (isLive(row))</span>
                {
<span class="nc" id="L971">                    hasGroupStarted = true;</span>
<span class="nc" id="L972">                    incrementRowCount();</span>
<span class="nc" id="L973">                    hasReturnedRowsFromCurrentPartition = true;</span>
                }

<span class="nc" id="L976">                return row;</span>
            }

            @Override
            public int counted()
            {
<span class="nc" id="L982">                return groupCounted;</span>
            }

            @Override
            public int countedInCurrentPartition()
            {
<span class="nc" id="L988">                return groupInCurrentPartition;</span>
            }

            @Override
            public int rowCounted()
            {
<span class="nc" id="L994">                return rowCounted;</span>
            }

            @Override
            public int rowCountedInCurrentPartition()
            {
<span class="nc" id="L1000">                return rowCountedInCurrentPartition;</span>
            }

            protected void incrementRowCount()
            {
<span class="nc" id="L1005">                rowCountedInCurrentPartition++;</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                if (++rowCounted &gt;= rowLimit)</span>
<span class="nc" id="L1007">                    stop();</span>
<span class="nc" id="L1008">            }</span>

            private void incrementGroupCount()
            {
<span class="nc" id="L1012">                groupCounted++;</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">                if (groupCounted &gt;= groupLimit)</span>
<span class="nc" id="L1014">                    stop();</span>
<span class="nc" id="L1015">            }</span>

            private void incrementGroupInCurrentPartitionCount()
            {
<span class="nc" id="L1019">                groupInCurrentPartition++;</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                if (groupInCurrentPartition &gt;= groupPerPartitionLimit)</span>
<span class="nc" id="L1021">                    stopInPartition();</span>
<span class="nc" id="L1022">            }</span>

            @Override
            public boolean isDoneForPartition()
            {
<span class="nc bnc" id="L1027" title="All 4 branches missed.">                return isDone() || groupInCurrentPartition &gt;= groupPerPartitionLimit;</span>
            }

            @Override
            public boolean isDone()
            {
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                return groupCounted &gt;= groupLimit;</span>
            }

            @Override
            public void onPartitionClose()
            {
                // Normally, we don't count static rows as from a CQL point of view, it will be merge with other
                // rows in the partition. However, if we only have the static row, it will be returned as one group
                // so count it.
<span class="nc bnc" id="L1042" title="All 6 branches missed.">                if (countPartitionsWithOnlyStaticData &amp;&amp; hasLiveStaticRow &amp;&amp; !hasReturnedRowsFromCurrentPartition)</span>
                {
<span class="nc" id="L1044">                    incrementRowCount();</span>
<span class="nc" id="L1045">                    incrementGroupCount();</span>
<span class="nc" id="L1046">                    incrementGroupInCurrentPartitionCount();</span>
<span class="nc" id="L1047">                    hasGroupStarted = false;</span>
                }
<span class="nc" id="L1049">                super.onPartitionClose();</span>
<span class="nc" id="L1050">            }</span>

            @Override
            public void onClose()
            {
                // Groups are only counted when the end of the group is reached.
                // The end of a group is detected by 2 ways:
                // 1) a new group is reached
                // 2) the end of the data is reached
                // We know that the end of the data is reached if the group limit has not been reached
                // and the number of rows counted is smaller than the internal page size.
<span class="nc bnc" id="L1061" title="All 6 branches missed.">                if (hasGroupStarted &amp;&amp; groupCounted &lt; groupLimit &amp;&amp; rowCounted &lt; rowLimit)</span>
                {
<span class="nc" id="L1063">                    incrementGroupCount();</span>
<span class="nc" id="L1064">                    incrementGroupInCurrentPartitionCount();</span>
                }

<span class="nc" id="L1067">                super.onClose();</span>
<span class="nc" id="L1068">            }</span>
        }
    }

<span class="nc bnc" id="L1072" title="All 2 branches missed.">    private static class CQLGroupByPagingLimits extends CQLGroupByLimits</span>
    {
        private final ByteBuffer lastReturnedKey;

        private final int lastReturnedKeyRemaining;

        public CQLGroupByPagingLimits(int groupLimit,
                                      int groupPerPartitionLimit,
                                      int rowLimit,
                                      AggregationSpecification groupBySpec,
                                      GroupingState state,
                                      ByteBuffer lastReturnedKey,
                                      int lastReturnedKeyRemaining)
        {
<span class="nc" id="L1086">            super(groupLimit,</span>
                  groupPerPartitionLimit,
                  rowLimit,
                  groupBySpec,
                  state);

<span class="nc" id="L1092">            this.lastReturnedKey = lastReturnedKey;</span>
<span class="nc" id="L1093">            this.lastReturnedKeyRemaining = lastReturnedKeyRemaining;</span>
<span class="nc" id="L1094">        }</span>

        @Override
        public Kind kind()
        {
<span class="nc" id="L1099">            return Kind.CQL_GROUP_BY_PAGING_LIMIT;</span>
        }

        @Override
        public DataLimits forPaging(int pageSize)
        {
<span class="nc" id="L1105">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public DataLimits forPaging(int pageSize, ByteBuffer lastReturnedKey, int lastReturnedKeyRemaining)
        {
<span class="nc" id="L1111">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public DataLimits forGroupByInternalPaging(GroupingState state)
        {
<span class="nc" id="L1117">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public Counter newCounter(int nowInSec, boolean assumeLiveData, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
        {
<span class="nc bnc" id="L1123" title="All 6 branches missed.">            assert state == GroupingState.EMPTY_STATE || lastReturnedKey.equals(state.partitionKey());</span>
<span class="nc" id="L1124">            return new PagingGroupByAwareCounter(nowInSec, assumeLiveData, countPartitionsWithOnlyStaticData, enforceStrictLiveness);</span>
        }

        @Override
        public DataLimits withoutState()
        {
<span class="nc" id="L1130">            return new CQLGroupByLimits(groupLimit, groupPerPartitionLimit, rowLimit, groupBySpec);</span>
        }

        private class PagingGroupByAwareCounter extends GroupByAwareCounter
        {
            private PagingGroupByAwareCounter(int nowInSec, boolean assumeLiveData, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
<span class="nc" id="L1136">            {</span>
<span class="nc" id="L1137">                super(nowInSec, assumeLiveData, countPartitionsWithOnlyStaticData, enforceStrictLiveness);</span>
<span class="nc" id="L1138">            }</span>

            @Override
            public void applyToPartition(DecoratedKey partitionKey, Row staticRow)
            {
<span class="nc bnc" id="L1143" title="All 2 branches missed.">                if (partitionKey.getKey().equals(lastReturnedKey))</span>
                {
<span class="nc" id="L1145">                    currentPartitionKey = partitionKey;</span>
<span class="nc" id="L1146">                    groupInCurrentPartition = groupPerPartitionLimit - lastReturnedKeyRemaining;</span>
<span class="nc" id="L1147">                    hasReturnedRowsFromCurrentPartition = true;</span>
<span class="nc" id="L1148">                    hasLiveStaticRow = false;</span>
<span class="nc" id="L1149">                    hasGroupStarted = state.hasClustering();</span>
                }
                else
                {
<span class="nc" id="L1153">                    super.applyToPartition(partitionKey, staticRow);</span>
                }
<span class="nc" id="L1155">            }</span>
        }
    }

    /**
     * Limits used by thrift; this count partition and cells.
     */
<span class="nc bnc" id="L1162" title="All 2 branches missed.">    private static class ThriftLimits extends DataLimits</span>
    {
        protected final int partitionLimit;
        protected final int cellPerPartitionLimit;

        private ThriftLimits(int partitionLimit, int cellPerPartitionLimit)
<span class="nc" id="L1168">        {</span>
<span class="nc" id="L1169">            this.partitionLimit = partitionLimit;</span>
<span class="nc" id="L1170">            this.cellPerPartitionLimit = cellPerPartitionLimit;</span>
<span class="nc" id="L1171">        }</span>

        public Kind kind()
        {
<span class="nc" id="L1175">            return Kind.THRIFT_LIMIT;</span>
        }

        public boolean isUnlimited()
        {
<span class="nc bnc" id="L1180" title="All 4 branches missed.">            return partitionLimit == NO_LIMIT &amp;&amp; cellPerPartitionLimit == NO_LIMIT;</span>
        }

        public boolean isDistinct()
        {
<span class="nc" id="L1185">            return false;</span>
        }

        public DataLimits forPaging(int pageSize)
        {
            // We don't support paging on thrift in general but do use paging under the hood for get_count. For
            // that case, we only care about limiting cellPerPartitionLimit (since it's paging over a single
            // partition). We do check that the partition limit is 1 however to make sure this is not misused
            // (as this wouldn't work properly for range queries).
<span class="nc bnc" id="L1194" title="All 4 branches missed.">            assert partitionLimit == 1;</span>
<span class="nc" id="L1195">            return new ThriftLimits(partitionLimit, pageSize);</span>
        }

        public DataLimits forPaging(int pageSize, ByteBuffer lastReturnedKey, int lastReturnedKeyRemaining)
        {
<span class="nc" id="L1200">            throw new UnsupportedOperationException();</span>
        }

        public DataLimits forShortReadRetry(int toFetch)
        {
            // Short read retries are always done for a single partition at a time, so it's ok to ignore the
            // partition limit for those
<span class="nc" id="L1207">            return new ThriftLimits(1, toFetch);</span>
        }

        public boolean hasEnoughLiveData(CachedPartition cached, int nowInSec, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
        {
            // We want the number of cells that are currently live. Getting that precise number forces
            // us to iterate the cached partition in general, but we can avoid that if:
            //   - The number of non-expiring live cells is greater than the number of cells asked (we then
            //     know we have enough live cells).
            //   - The number of cells cached is less than requested, in which case we know we won't have enough.
<span class="nc bnc" id="L1217" title="All 2 branches missed.">            if (cached.nonExpiringLiveCells() &gt;= cellPerPartitionLimit)</span>
<span class="nc" id="L1218">                return true;</span>

<span class="nc bnc" id="L1220" title="All 2 branches missed.">            if (cached.nonTombstoneCellCount() &lt; cellPerPartitionLimit)</span>
<span class="nc" id="L1221">                return false;</span>

            // Otherwise, we need to re-count
<span class="nc" id="L1224">            DataLimits.Counter counter = newCounter(nowInSec, false, countPartitionsWithOnlyStaticData, enforceStrictLiveness);</span>
<span class="nc" id="L1225">            try (UnfilteredRowIterator cacheIter = cached.unfilteredIterator(ColumnFilter.selection(cached.columns()), Slices.ALL, false);</span>
<span class="nc" id="L1226">                 UnfilteredRowIterator iter = counter.applyTo(cacheIter))</span>
            {
                // Consume the iterator until we've counted enough
<span class="nc bnc" id="L1229" title="All 2 branches missed.">                while (iter.hasNext())</span>
<span class="nc" id="L1230">                    iter.next();</span>
<span class="nc" id="L1231">                return counter.isDone();</span>
            }
        }

        public Counter newCounter(int nowInSec, boolean assumeLiveData, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
        {
<span class="nc" id="L1237">            return new ThriftCounter(nowInSec, assumeLiveData, enforceStrictLiveness);</span>
        }

        public int count()
        {
<span class="nc" id="L1242">            return partitionLimit * cellPerPartitionLimit;</span>
        }

        public int perPartitionCount()
        {
<span class="nc" id="L1247">            return cellPerPartitionLimit;</span>
        }

        public DataLimits withoutState()
        {
<span class="nc" id="L1252">            return this;</span>
        }

        public float estimateTotalResults(ColumnFamilyStore cfs)
        {
            // remember that getMeansColumns returns a number of cells: we should clean nomenclature
<span class="nc" id="L1258">            float cellsPerPartition = ((float) cfs.getMeanColumns()) / cfs.metadata.partitionColumns().regulars.size();</span>
<span class="nc" id="L1259">            return cellsPerPartition * cfs.estimateKeys();</span>
        }

        protected class ThriftCounter extends Counter
        {
            protected int partitionsCounted;
            protected int cellsCounted;
            protected int cellsInCurrentPartition;

            public ThriftCounter(int nowInSec, boolean assumeLiveData, boolean enforceStrictLiveness)
<span class="nc" id="L1269">            {</span>
<span class="nc" id="L1270">                super(nowInSec, assumeLiveData, enforceStrictLiveness);</span>
<span class="nc" id="L1271">            }</span>

            @Override
            public void applyToPartition(DecoratedKey partitionKey, Row staticRow)
            {
<span class="nc" id="L1276">                cellsInCurrentPartition = 0;</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">                if (!staticRow.isEmpty())</span>
<span class="nc" id="L1278">                    applyToRow(staticRow);</span>
<span class="nc" id="L1279">            }</span>

            @Override
            public Row applyToRow(Row row)
            {
<span class="nc bnc" id="L1284" title="All 2 branches missed.">                for (Cell cell : row.cells())</span>
                {
<span class="nc bnc" id="L1286" title="All 4 branches missed.">                    if (assumeLiveData || cell.isLive(nowInSec))</span>
                    {
<span class="nc" id="L1288">                        ++cellsCounted;</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                        if (++cellsInCurrentPartition &gt;= cellPerPartitionLimit)</span>
<span class="nc" id="L1290">                            stopInPartition();</span>
                    }
<span class="nc" id="L1292">                }</span>
<span class="nc" id="L1293">                return row;</span>
            }

            @Override
            public void onPartitionClose()
            {
<span class="nc bnc" id="L1299" title="All 2 branches missed.">                if (++partitionsCounted &gt;= partitionLimit)</span>
<span class="nc" id="L1300">                    stop();</span>
<span class="nc" id="L1301">                super.onPartitionClose();</span>
<span class="nc" id="L1302">            }</span>

            public int counted()
            {
<span class="nc" id="L1306">                return cellsCounted;</span>
            }

            public int countedInCurrentPartition()
            {
<span class="nc" id="L1311">                return cellsInCurrentPartition;</span>
            }

            public int rowCounted()
            {
<span class="nc" id="L1316">                throw new UnsupportedOperationException();</span>
            }

            public int rowCountedInCurrentPartition()
            {
<span class="nc" id="L1321">                throw new UnsupportedOperationException();</span>
            }

            public boolean isDone()
            {
<span class="nc bnc" id="L1326" title="All 2 branches missed.">                return partitionsCounted &gt;= partitionLimit;</span>
            }

            public boolean isDoneForPartition()
            {
<span class="nc bnc" id="L1331" title="All 4 branches missed.">                return isDone() || cellsInCurrentPartition &gt;= cellPerPartitionLimit;</span>
            }
        }

        @Override
        public String toString()
        {
            // This is not valid CQL, but that's ok since it's not used for CQL queries.
<span class="nc" id="L1339">            return String.format(&quot;THRIFT LIMIT (partitions=%d, cells_per_partition=%d)&quot;, partitionLimit, cellPerPartitionLimit);</span>
        }
    }

    /**
     * Limits used for thrift get_count when we only want to count super columns.
     */
<span class="nc bnc" id="L1346" title="All 2 branches missed.">    private static class SuperColumnCountingLimits extends ThriftLimits</span>
    {
        private SuperColumnCountingLimits(int partitionLimit, int cellPerPartitionLimit)
        {
<span class="nc" id="L1350">            super(partitionLimit, cellPerPartitionLimit);</span>
<span class="nc" id="L1351">        }</span>

        public Kind kind()
        {
<span class="nc" id="L1355">            return Kind.SUPER_COLUMN_COUNTING_LIMIT;</span>
        }

        public DataLimits forPaging(int pageSize)
        {
            // We don't support paging on thrift in general but do use paging under the hood for get_count. For
            // that case, we only care about limiting cellPerPartitionLimit (since it's paging over a single
            // partition). We do check that the partition limit is 1 however to make sure this is not misused
            // (as this wouldn't work properly for range queries).
<span class="nc bnc" id="L1364" title="All 4 branches missed.">            assert partitionLimit == 1;</span>
<span class="nc" id="L1365">            return new SuperColumnCountingLimits(partitionLimit, pageSize);</span>
        }

        public DataLimits forShortReadRetry(int toFetch)
        {
            // Short read retries are always done for a single partition at a time, so it's ok to ignore the
            // partition limit for those
<span class="nc" id="L1372">            return new SuperColumnCountingLimits(1, toFetch);</span>
        }

        @Override
        public Counter newCounter(int nowInSec, boolean assumeLiveData, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)
        {
<span class="nc" id="L1378">            return new SuperColumnCountingCounter(nowInSec, assumeLiveData, enforceStrictLiveness);</span>
        }

        protected class SuperColumnCountingCounter extends ThriftCounter
        {
            private final boolean enforceStrictLiveness;

            public SuperColumnCountingCounter(int nowInSec, boolean assumeLiveData, boolean enforceStrictLiveness)
<span class="nc" id="L1386">            {</span>
<span class="nc" id="L1387">                super(nowInSec, assumeLiveData, enforceStrictLiveness);</span>
<span class="nc" id="L1388">                this.enforceStrictLiveness = enforceStrictLiveness;</span>
<span class="nc" id="L1389">            }</span>

            @Override
            public Row applyToRow(Row row)
            {
                // In the internal format, a row == a super column, so that's what we want to count.
<span class="nc bnc" id="L1395" title="All 2 branches missed.">                if (isLive(row))</span>
                {
<span class="nc" id="L1397">                    ++cellsCounted;</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">                    if (++cellsInCurrentPartition &gt;= cellPerPartitionLimit)</span>
<span class="nc" id="L1399">                        stopInPartition();</span>
                }
<span class="nc" id="L1401">                return row;</span>
            }
        }
    }

<span class="fc" id="L1406">    public static class Serializer</span>
    {
        public void serialize(DataLimits limits, DataOutputPlus out, int version, ClusteringComparator comparator) throws IOException
        {
<span class="fc" id="L1410">            out.writeByte(limits.kind().ordinal());</span>
<span class="pc bpc" id="L1411" title="3 of 4 branches missed.">            switch (limits.kind())</span>
            {
                case CQL_LIMIT:
                case CQL_PAGING_LIMIT:
<span class="fc" id="L1415">                    CQLLimits cqlLimits = (CQLLimits)limits;</span>
<span class="fc" id="L1416">                    out.writeUnsignedVInt(cqlLimits.rowLimit);</span>
<span class="fc" id="L1417">                    out.writeUnsignedVInt(cqlLimits.perPartitionLimit);</span>
<span class="fc" id="L1418">                    out.writeBoolean(cqlLimits.isDistinct);</span>
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">                    if (limits.kind() == Kind.CQL_PAGING_LIMIT)</span>
                    {
<span class="nc" id="L1421">                        CQLPagingLimits pagingLimits = (CQLPagingLimits)cqlLimits;</span>
<span class="nc" id="L1422">                        ByteBufferUtil.writeWithVIntLength(pagingLimits.lastReturnedKey, out);</span>
<span class="nc" id="L1423">                        out.writeUnsignedVInt(pagingLimits.lastReturnedKeyRemaining);</span>
<span class="nc" id="L1424">                    }</span>
                    break;
                case CQL_GROUP_BY_LIMIT:
                case CQL_GROUP_BY_PAGING_LIMIT:
<span class="nc" id="L1428">                    CQLGroupByLimits groupByLimits = (CQLGroupByLimits) limits;</span>
<span class="nc" id="L1429">                    out.writeUnsignedVInt(groupByLimits.groupLimit);</span>
<span class="nc" id="L1430">                    out.writeUnsignedVInt(groupByLimits.groupPerPartitionLimit);</span>
<span class="nc" id="L1431">                    out.writeUnsignedVInt(groupByLimits.rowLimit);</span>

<span class="nc" id="L1433">                    AggregationSpecification groupBySpec = groupByLimits.groupBySpec;</span>
<span class="nc" id="L1434">                    AggregationSpecification.serializer.serialize(groupBySpec, out, version);</span>

<span class="nc" id="L1436">                    GroupingState.serializer.serialize(groupByLimits.state, out, version, comparator);</span>

<span class="nc bnc" id="L1438" title="All 2 branches missed.">                    if (limits.kind() == Kind.CQL_GROUP_BY_PAGING_LIMIT)</span>
                    {
<span class="nc" id="L1440">                        CQLGroupByPagingLimits pagingLimits = (CQLGroupByPagingLimits) groupByLimits;</span>
<span class="nc" id="L1441">                        ByteBufferUtil.writeWithVIntLength(pagingLimits.lastReturnedKey, out);</span>
<span class="nc" id="L1442">                        out.writeUnsignedVInt(pagingLimits.lastReturnedKeyRemaining);</span>
<span class="nc" id="L1443">                     }</span>
                     break;
                case THRIFT_LIMIT:
                case SUPER_COLUMN_COUNTING_LIMIT:
<span class="nc" id="L1447">                    ThriftLimits thriftLimits = (ThriftLimits)limits;</span>
<span class="nc" id="L1448">                    out.writeUnsignedVInt(thriftLimits.partitionLimit);</span>
<span class="nc" id="L1449">                    out.writeUnsignedVInt(thriftLimits.cellPerPartitionLimit);</span>
                    break;
            }
<span class="fc" id="L1452">        }</span>

        public DataLimits deserialize(DataInputPlus in, int version, ClusteringComparator comparator) throws IOException
        {
<span class="fc" id="L1456">            Kind kind = Kind.values()[in.readUnsignedByte()];</span>
<span class="pc bpc" id="L1457" title="3 of 4 branches missed.">            switch (kind)</span>
            {
                case CQL_LIMIT:
                case CQL_PAGING_LIMIT:
                {
<span class="fc" id="L1462">                    int rowLimit = (int) in.readUnsignedVInt();</span>
<span class="fc" id="L1463">                    int perPartitionLimit = (int) in.readUnsignedVInt();</span>
<span class="fc" id="L1464">                    boolean isDistinct = in.readBoolean();</span>
<span class="pc bpc" id="L1465" title="1 of 2 branches missed.">                    if (kind == Kind.CQL_LIMIT)</span>
<span class="fc" id="L1466">                        return cqlLimits(rowLimit, perPartitionLimit, isDistinct);</span>
<span class="nc" id="L1467">                    ByteBuffer lastKey = ByteBufferUtil.readWithVIntLength(in);</span>
<span class="nc" id="L1468">                    int lastRemaining = (int) in.readUnsignedVInt();</span>
<span class="nc" id="L1469">                    return new CQLPagingLimits(rowLimit, perPartitionLimit, isDistinct, lastKey, lastRemaining);</span>
                }
                case CQL_GROUP_BY_LIMIT:
                case CQL_GROUP_BY_PAGING_LIMIT:
                {
<span class="nc" id="L1474">                    int groupLimit = (int) in.readUnsignedVInt();</span>
<span class="nc" id="L1475">                    int groupPerPartitionLimit = (int) in.readUnsignedVInt();</span>
<span class="nc" id="L1476">                    int rowLimit = (int) in.readUnsignedVInt();</span>

<span class="nc" id="L1478">                    AggregationSpecification groupBySpec = AggregationSpecification.serializer.deserialize(in, version, comparator);</span>

<span class="nc" id="L1480">                    GroupingState state = GroupingState.serializer.deserialize(in, version, comparator);</span>

<span class="nc bnc" id="L1482" title="All 2 branches missed.">                    if (kind == Kind.CQL_GROUP_BY_LIMIT)</span>
<span class="nc" id="L1483">                        return new CQLGroupByLimits(groupLimit,</span>
                                                    groupPerPartitionLimit,
                                                    rowLimit,
                                                    groupBySpec,
                                                    state);

<span class="nc" id="L1489">                    ByteBuffer lastKey = ByteBufferUtil.readWithVIntLength(in);</span>
<span class="nc" id="L1490">                    int lastRemaining = (int) in.readUnsignedVInt();</span>
<span class="nc" id="L1491">                    return new CQLGroupByPagingLimits(groupLimit,</span>
                                                      groupPerPartitionLimit,
                                                      rowLimit,
                                                      groupBySpec,
                                                      state,
                                                      lastKey,
                                                      lastRemaining);
                }
                case THRIFT_LIMIT:
                case SUPER_COLUMN_COUNTING_LIMIT:
<span class="nc" id="L1501">                    int partitionLimit = (int) in.readUnsignedVInt();</span>
<span class="nc" id="L1502">                    int cellPerPartitionLimit = (int) in.readUnsignedVInt();</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">                    return kind == Kind.THRIFT_LIMIT</span>
                            ? new ThriftLimits(partitionLimit, cellPerPartitionLimit)
                            : new SuperColumnCountingLimits(partitionLimit, cellPerPartitionLimit);
            }
<span class="nc" id="L1507">            throw new AssertionError();</span>
        }

        public long serializedSize(DataLimits limits, int version, ClusteringComparator comparator)
        {
<span class="fc" id="L1512">            long size = TypeSizes.sizeof((byte) limits.kind().ordinal());</span>
<span class="pc bpc" id="L1513" title="3 of 4 branches missed.">            switch (limits.kind())</span>
            {
                case CQL_LIMIT:
                case CQL_PAGING_LIMIT:
<span class="fc" id="L1517">                    CQLLimits cqlLimits = (CQLLimits) limits;</span>
<span class="fc" id="L1518">                    size += TypeSizes.sizeofUnsignedVInt(cqlLimits.rowLimit);</span>
<span class="fc" id="L1519">                    size += TypeSizes.sizeofUnsignedVInt(cqlLimits.perPartitionLimit);</span>
<span class="fc" id="L1520">                    size += TypeSizes.sizeof(cqlLimits.isDistinct);</span>
<span class="pc bpc" id="L1521" title="1 of 2 branches missed.">                    if (limits.kind() == Kind.CQL_PAGING_LIMIT)</span>
                    {
<span class="nc" id="L1523">                        CQLPagingLimits pagingLimits = (CQLPagingLimits) cqlLimits;</span>
<span class="nc" id="L1524">                        size += ByteBufferUtil.serializedSizeWithVIntLength(pagingLimits.lastReturnedKey);</span>
<span class="nc" id="L1525">                        size += TypeSizes.sizeofUnsignedVInt(pagingLimits.lastReturnedKeyRemaining);</span>
<span class="nc" id="L1526">                    }</span>
                    break;
                case CQL_GROUP_BY_LIMIT:
                case CQL_GROUP_BY_PAGING_LIMIT:
<span class="nc" id="L1530">                    CQLGroupByLimits groupByLimits = (CQLGroupByLimits) limits;</span>
<span class="nc" id="L1531">                    size += TypeSizes.sizeofUnsignedVInt(groupByLimits.groupLimit);</span>
<span class="nc" id="L1532">                    size += TypeSizes.sizeofUnsignedVInt(groupByLimits.groupPerPartitionLimit);</span>
<span class="nc" id="L1533">                    size += TypeSizes.sizeofUnsignedVInt(groupByLimits.rowLimit);</span>

<span class="nc" id="L1535">                    AggregationSpecification groupBySpec = groupByLimits.groupBySpec;</span>
<span class="nc" id="L1536">                    size += AggregationSpecification.serializer.serializedSize(groupBySpec, version);</span>

<span class="nc" id="L1538">                    size += GroupingState.serializer.serializedSize(groupByLimits.state, version, comparator);</span>

<span class="nc bnc" id="L1540" title="All 2 branches missed.">                    if (limits.kind() == Kind.CQL_GROUP_BY_PAGING_LIMIT)</span>
                    {
<span class="nc" id="L1542">                        CQLGroupByPagingLimits pagingLimits = (CQLGroupByPagingLimits) groupByLimits;</span>
<span class="nc" id="L1543">                        size += ByteBufferUtil.serializedSizeWithVIntLength(pagingLimits.lastReturnedKey);</span>
<span class="nc" id="L1544">                        size += TypeSizes.sizeofUnsignedVInt(pagingLimits.lastReturnedKeyRemaining);</span>
<span class="nc" id="L1545">                    }</span>
                    break;
                case THRIFT_LIMIT:
                case SUPER_COLUMN_COUNTING_LIMIT:
<span class="nc" id="L1549">                    ThriftLimits thriftLimits = (ThriftLimits) limits;</span>
<span class="nc" id="L1550">                    size += TypeSizes.sizeofUnsignedVInt(thriftLimits.partitionLimit);</span>
<span class="nc" id="L1551">                    size += TypeSizes.sizeofUnsignedVInt(thriftLimits.cellPerPartitionLimit);</span>
<span class="nc" id="L1552">                    break;</span>
                default:
<span class="nc" id="L1554">                    throw new AssertionError();</span>
            }
<span class="fc" id="L1556">            return size;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>