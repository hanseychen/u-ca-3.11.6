<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StorageService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service</a> &gt; <span class="el_source">StorageService.java</span></div><h1>StorageService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.service;

import java.io.*;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.MatchResult;
import java.util.regex.Pattern;
import java.util.stream.StreamSupport;

import javax.annotation.Nullable;
import javax.management.*;
import javax.management.openmbean.TabularData;
import javax.management.openmbean.TabularDataSupport;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.collect.*;
import com.google.common.util.concurrent.*;

import org.apache.commons.lang3.StringUtils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.auth.AuthKeyspace;
import org.apache.cassandra.auth.AuthMigrationListener;
import org.apache.cassandra.batchlog.BatchRemoveVerbHandler;
import org.apache.cassandra.batchlog.BatchStoreVerbHandler;
import org.apache.cassandra.batchlog.BatchlogManager;
import org.apache.cassandra.concurrent.NamedThreadFactory;
import org.apache.cassandra.concurrent.ScheduledExecutors;
import org.apache.cassandra.concurrent.Stage;
import org.apache.cassandra.concurrent.StageManager;
import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.Config;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.Schema;
import org.apache.cassandra.config.SchemaConstants;
import org.apache.cassandra.config.ViewDefinition;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.commitlog.CommitLog;
import org.apache.cassandra.db.compaction.CompactionManager;
import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
import org.apache.cassandra.dht.*;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token.TokenFactory;
import org.apache.cassandra.exceptions.*;
import org.apache.cassandra.gms.*;
import org.apache.cassandra.hints.HintVerbHandler;
import org.apache.cassandra.hints.HintsService;
import org.apache.cassandra.io.sstable.SSTableLoader;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.locator.*;
import org.apache.cassandra.metrics.StorageMetrics;
import org.apache.cassandra.net.*;
import org.apache.cassandra.repair.*;
import org.apache.cassandra.repair.messages.RepairOption;
import org.apache.cassandra.schema.CompactionParams.TombstoneOption;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.SchemaKeyspace;
import org.apache.cassandra.service.paxos.CommitVerbHandler;
import org.apache.cassandra.service.paxos.PrepareVerbHandler;
import org.apache.cassandra.service.paxos.ProposeVerbHandler;
import org.apache.cassandra.streaming.*;
import org.apache.cassandra.thrift.EndpointDetails;
import org.apache.cassandra.thrift.TokenRange;
import org.apache.cassandra.thrift.cassandraConstants;
import org.apache.cassandra.tracing.TraceKeyspace;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.*;
import org.apache.cassandra.utils.logging.LoggingSupportFactory;
import org.apache.cassandra.utils.progress.ProgressEvent;
import org.apache.cassandra.utils.progress.ProgressEventType;
import org.apache.cassandra.utils.progress.jmx.JMXProgressSupport;
import org.apache.cassandra.utils.progress.jmx.LegacyJMXProgressSupport;

import static java.util.Arrays.asList;
import static java.util.concurrent.TimeUnit.MINUTES;
import static java.util.stream.Collectors.toList;
import static org.apache.cassandra.index.SecondaryIndexManager.getIndexName;
import static org.apache.cassandra.index.SecondaryIndexManager.isIndexColumnFamily;
import static org.apache.cassandra.service.MigrationManager.evolveSystemKeyspace;

/**
 * This abstraction contains the token/identifier of this node
 * on the identifier space. This token gets gossiped around.
 * This class will also maintain histograms of the load information
 * of other nodes in the cluster.
 */
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">public class StorageService extends NotificationBroadcasterSupport implements IEndpointStateChangeSubscriber, StorageServiceMBean</span>
{
<span class="fc" id="L116">    private static final Logger logger = LoggerFactory.getLogger(StorageService.class);</span>

<span class="fc" id="L118">    public static final int RING_DELAY = getRingDelay(); // delay after which we assume ring has stablized</span>

<span class="fc" id="L120">    private final JMXProgressSupport progressSupport = new JMXProgressSupport(this);</span>

    /**
     * @deprecated backward support to previous notification interface
     * Will be removed on 4.0
     */
    @Deprecated
    private final LegacyJMXProgressSupport legacyProgressSupport;

<span class="fc" id="L129">    private static final AtomicInteger threadCounter = new AtomicInteger(1);</span>

    private static int getRingDelay()
    {
<span class="fc" id="L133">        String newdelay = System.getProperty(&quot;cassandra.ring_delay_ms&quot;);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (newdelay != null)</span>
        {
<span class="nc" id="L136">            logger.info(&quot;Overriding RING_DELAY to {}ms&quot;, newdelay);</span>
<span class="nc" id="L137">            return Integer.parseInt(newdelay);</span>
        }
        else
<span class="fc" id="L140">            return 30 * 1000;</span>
    }

    /* This abstraction maintains the token/endpoint metadata information */
<span class="fc" id="L144">    private TokenMetadata tokenMetadata = new TokenMetadata();</span>

<span class="fc" id="L146">    public volatile VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(tokenMetadata.partitioner);</span>

<span class="fc" id="L148">    private Thread drainOnShutdown = null;</span>
<span class="fc" id="L149">    private volatile boolean isShutdown = false;</span>
<span class="fc" id="L150">    private final List&lt;Runnable&gt; preShutdownHooks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L151">    private final List&lt;Runnable&gt; postShutdownHooks = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L153">    public static final StorageService instance = new StorageService();</span>

    @Deprecated
    public boolean isInShutdownHook()
    {
<span class="nc" id="L158">        return isShutdown();</span>
    }

    public boolean isShutdown()
    {
<span class="nc" id="L163">        return isShutdown;</span>
    }

    public Collection&lt;Range&lt;Token&gt;&gt; getLocalRanges(String keyspaceName)
    {
<span class="nc" id="L168">        return getRangesForEndpoint(keyspaceName, FBUtilities.getBroadcastAddress());</span>
    }

    public Collection&lt;Range&lt;Token&gt;&gt; getPrimaryRanges(String keyspace)
    {
<span class="nc" id="L173">        return getPrimaryRangesForEndpoint(keyspace, FBUtilities.getBroadcastAddress());</span>
    }

    public Collection&lt;Range&lt;Token&gt;&gt; getPrimaryRangesWithinDC(String keyspace)
    {
<span class="nc" id="L178">        return getPrimaryRangeForEndpointWithinDC(keyspace, FBUtilities.getBroadcastAddress());</span>
    }

<span class="fc" id="L181">    private final Set&lt;InetAddress&gt; replicatingNodes = Collections.synchronizedSet(new HashSet&lt;InetAddress&gt;());</span>
    private CassandraDaemon daemon;

    private InetAddress removingNode;

    /* Are we starting this node in bootstrap mode? */
    private volatile boolean isBootstrapMode;

    /* we bootstrap but do NOT join the ring unless told to do so */
<span class="fc" id="L190">    private boolean isSurveyMode = Boolean.parseBoolean(System.getProperty(&quot;cassandra.write_survey&quot;, &quot;false&quot;));</span>
    /* true if node is rebuilding and receiving data */
<span class="fc" id="L192">    private final AtomicBoolean isRebuilding = new AtomicBoolean();</span>
<span class="fc" id="L193">    private final AtomicBoolean isDecommissioning = new AtomicBoolean();</span>

<span class="fc" id="L195">    private volatile boolean initialized = false;</span>
<span class="fc" id="L196">    private volatile boolean joined = false;</span>
<span class="fc" id="L197">    private volatile boolean gossipActive = false;</span>
<span class="fc" id="L198">    private final AtomicBoolean authSetupCalled = new AtomicBoolean(false);</span>
<span class="fc" id="L199">    private volatile boolean authSetupComplete = false;</span>

    /* the probability for tracing any particular request, 0 disables tracing and 1 enables for all */
<span class="fc" id="L202">    private double traceProbability = 0.0;</span>

<span class="fc" id="L204">    private static enum Mode { STARTING, NORMAL, JOINING, LEAVING, DECOMMISSIONED, MOVING, DRAINING, DRAINED }</span>
<span class="fc" id="L205">    private volatile Mode operationMode = Mode.STARTING;</span>

    /* Used for tracking drain progress */
    private volatile int totalCFs, remainingCFs;

<span class="fc" id="L210">    private static final AtomicInteger nextRepairCommand = new AtomicInteger();</span>

<span class="fc" id="L212">    private final List&lt;IEndpointLifecycleSubscriber&gt; lifecycleSubscribers = new CopyOnWriteArrayList&lt;&gt;();</span>

    private final String jmxObjectName;

<span class="fc" id="L216">    private Collection&lt;Token&gt; bootstrapTokens = null;</span>

    // true when keeping strict consistency while bootstrapping
<span class="fc" id="L219">    private static final boolean useStrictConsistency = Boolean.parseBoolean(System.getProperty(&quot;cassandra.consistent.rangemovement&quot;, &quot;true&quot;));</span>
<span class="fc" id="L220">    private static final boolean allowSimultaneousMoves = Boolean.parseBoolean(System.getProperty(&quot;cassandra.consistent.simultaneousmoves.allow&quot;,&quot;false&quot;));</span>
<span class="fc" id="L221">    private static final boolean joinRing = Boolean.parseBoolean(System.getProperty(&quot;cassandra.join_ring&quot;, &quot;true&quot;));</span>
    private boolean replacing;

<span class="fc" id="L224">    private final StreamStateStore streamStateStore = new StreamStateStore();</span>

    public boolean isSurveyMode()
    {
<span class="fc" id="L228">        return isSurveyMode;</span>
    }

    public boolean hasJoined()
    {
<span class="fc" id="L233">        return joined;</span>
    }

    /** This method updates the local token on disk  */
    public void setTokens(Collection&lt;Token&gt; tokens)
    {
<span class="pc bpc" id="L239" title="3 of 6 branches missed.">        assert tokens != null &amp;&amp; !tokens.isEmpty() : &quot;Node needs at least one token.&quot;;</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L241">            logger.debug(&quot;Setting tokens to {}&quot;, tokens);</span>
<span class="fc" id="L242">        SystemKeyspace.updateTokens(tokens);</span>
<span class="fc" id="L243">        Collection&lt;Token&gt; localTokens = getLocalTokens();</span>
<span class="fc" id="L244">        setGossipTokens(localTokens);</span>
<span class="fc" id="L245">        tokenMetadata.updateNormalTokens(tokens, FBUtilities.getBroadcastAddress());</span>
<span class="fc" id="L246">        setMode(Mode.NORMAL, false);</span>
<span class="fc" id="L247">    }</span>

    public void setGossipTokens(Collection&lt;Token&gt; tokens)
    {
<span class="fc" id="L251">        List&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt; states = new ArrayList&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt;();</span>
<span class="fc" id="L252">        states.add(Pair.create(ApplicationState.TOKENS, valueFactory.tokens(tokens)));</span>
<span class="fc" id="L253">        states.add(Pair.create(ApplicationState.STATUS, valueFactory.normal(tokens)));</span>
<span class="fc" id="L254">        Gossiper.instance.addLocalApplicationStates(states);</span>
<span class="fc" id="L255">    }</span>

    public StorageService()
    {
        // use dedicated executor for sending JMX notifications
<span class="fc" id="L260">        super(Executors.newSingleThreadExecutor());</span>

<span class="fc" id="L262">        jmxObjectName = &quot;org.apache.cassandra.db:type=StorageService&quot;;</span>
<span class="fc" id="L263">        MBeanWrapper.instance.registerMBean(this, jmxObjectName);</span>
<span class="fc" id="L264">        MBeanWrapper.instance.registerMBean(StreamManager.instance, StreamManager.OBJECT_NAME);</span>

<span class="fc" id="L266">        legacyProgressSupport = new LegacyJMXProgressSupport(this, jmxObjectName);</span>

        /* register the verb handlers */
<span class="fc" id="L269">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.MUTATION, new MutationVerbHandler());</span>
<span class="fc" id="L270">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.READ_REPAIR, new ReadRepairVerbHandler());</span>
<span class="fc" id="L271">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.READ, new ReadCommandVerbHandler());</span>
<span class="fc" id="L272">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.RANGE_SLICE, new RangeSliceVerbHandler());</span>
<span class="fc" id="L273">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.PAGED_RANGE, new RangeSliceVerbHandler());</span>
<span class="fc" id="L274">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.COUNTER_MUTATION, new CounterMutationVerbHandler());</span>
<span class="fc" id="L275">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.TRUNCATE, new TruncateVerbHandler());</span>
<span class="fc" id="L276">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.PAXOS_PREPARE, new PrepareVerbHandler());</span>
<span class="fc" id="L277">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.PAXOS_PROPOSE, new ProposeVerbHandler());</span>
<span class="fc" id="L278">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.PAXOS_COMMIT, new CommitVerbHandler());</span>
<span class="fc" id="L279">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.HINT, new HintVerbHandler());</span>

        // see BootStrapper for a summary of how the bootstrap verbs interact
<span class="fc" id="L282">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.REPLICATION_FINISHED, new ReplicationFinishedVerbHandler());</span>
<span class="fc" id="L283">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.REQUEST_RESPONSE, new ResponseVerbHandler());</span>
<span class="fc" id="L284">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.INTERNAL_RESPONSE, new ResponseVerbHandler());</span>
<span class="fc" id="L285">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.REPAIR_MESSAGE, new RepairMessageVerbHandler());</span>
<span class="fc" id="L286">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.GOSSIP_SHUTDOWN, new GossipShutdownVerbHandler());</span>

<span class="fc" id="L288">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.GOSSIP_DIGEST_SYN, new GossipDigestSynVerbHandler());</span>
<span class="fc" id="L289">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.GOSSIP_DIGEST_ACK, new GossipDigestAckVerbHandler());</span>
<span class="fc" id="L290">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.GOSSIP_DIGEST_ACK2, new GossipDigestAck2VerbHandler());</span>

<span class="fc" id="L292">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.DEFINITIONS_UPDATE, new DefinitionsUpdateVerbHandler());</span>
<span class="fc" id="L293">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.SCHEMA_CHECK, new SchemaCheckVerbHandler());</span>
<span class="fc" id="L294">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.MIGRATION_REQUEST, new MigrationRequestVerbHandler());</span>

<span class="fc" id="L296">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.SNAPSHOT, new SnapshotVerbHandler());</span>
<span class="fc" id="L297">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.ECHO, new EchoVerbHandler());</span>

<span class="fc" id="L299">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.BATCH_STORE, new BatchStoreVerbHandler());</span>
<span class="fc" id="L300">        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.BATCH_REMOVE, new BatchRemoveVerbHandler());</span>
<span class="fc" id="L301">    }</span>

    public void registerDaemon(CassandraDaemon daemon)
    {
<span class="fc" id="L305">        this.daemon = daemon;</span>
<span class="fc" id="L306">    }</span>

    public void register(IEndpointLifecycleSubscriber subscriber)
    {
<span class="fc" id="L310">        lifecycleSubscribers.add(subscriber);</span>
<span class="fc" id="L311">    }</span>

    public void unregister(IEndpointLifecycleSubscriber subscriber)
    {
<span class="nc" id="L315">        lifecycleSubscribers.remove(subscriber);</span>
<span class="nc" id="L316">    }</span>

    // should only be called via JMX
    public void stopGossiping()
    {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (gossipActive)</span>
        {
<span class="nc" id="L323">            logger.warn(&quot;Stopping gossip by operator request&quot;);</span>
<span class="nc" id="L324">            Gossiper.instance.stop();</span>
<span class="nc" id="L325">            gossipActive = false;</span>
        }
<span class="nc" id="L327">    }</span>

    // should only be called via JMX
    public synchronized void startGossiping()
    {
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (!gossipActive)</span>
        {
<span class="nc" id="L334">            checkServiceAllowedToStart(&quot;gossip&quot;);</span>

<span class="nc" id="L336">            logger.warn(&quot;Starting gossip by operator request&quot;);</span>
<span class="nc" id="L337">            Collection&lt;Token&gt; tokens = SystemKeyspace.getSavedTokens();</span>

<span class="nc bnc" id="L339" title="All 4 branches missed.">            boolean validTokens = tokens != null &amp;&amp; !tokens.isEmpty();</span>

            // shouldn't be called before these are set if we intend to join the ring/are in the process of doing so
<span class="nc bnc" id="L342" title="All 4 branches missed.">            if (joined || joinRing)</span>
<span class="nc bnc" id="L343" title="All 4 branches missed.">                assert validTokens : &quot;Cannot start gossiping for a node intended to join without valid tokens&quot;;</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (validTokens)</span>
<span class="nc" id="L346">                setGossipTokens(tokens);</span>

<span class="nc" id="L348">            Gossiper.instance.forceNewerGeneration();</span>
<span class="nc" id="L349">            Gossiper.instance.start((int) (System.currentTimeMillis() / 1000));</span>
<span class="nc" id="L350">            gossipActive = true;</span>
        }
<span class="nc" id="L352">    }</span>

    // should only be called via JMX
    public boolean isGossipRunning()
    {
<span class="nc" id="L357">        return Gossiper.instance.isEnabled();</span>
    }

    // should only be called via JMX
    public synchronized void startRPCServer()
    {
<span class="nc" id="L363">        checkServiceAllowedToStart(&quot;thrift&quot;);</span>

<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (daemon == null)</span>
        {
<span class="nc" id="L367">            throw new IllegalStateException(&quot;No configured daemon&quot;);</span>
        }

        // We only start transports if bootstrap has completed and we're not in survey mode, OR if we are in
        // survey mode and streaming has completed but we're not using auth.
        // OR if we have not joined the ring yet.
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (StorageService.instance.hasJoined() &amp;&amp;</span>
<span class="nc bnc" id="L374" title="All 4 branches missed.">                ((!StorageService.instance.isSurveyMode() &amp;&amp; !SystemKeyspace.bootstrapComplete()) ||</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">                (StorageService.instance.isSurveyMode() &amp;&amp; StorageService.instance.isBootstrapMode())))</span>
        {
<span class="nc" id="L377">            throw new IllegalStateException(&quot;Node is not yet bootstrapped completely. Use nodetool to check bootstrap state and resume. For more, see `nodetool help bootstrap`&quot;);</span>
        }
<span class="nc bnc" id="L379" title="All 4 branches missed.">        else if (StorageService.instance.hasJoined() &amp;&amp; StorageService.instance.isSurveyMode() &amp;&amp;</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">                DatabaseDescriptor.getAuthenticator().requireAuthentication())</span>
        {
            // Auth isn't initialised until we join the ring, so if we're in survey mode auth will always fail.
<span class="nc" id="L383">            throw new IllegalStateException(&quot;Not starting RPC server as write_survey mode and authentication is enabled&quot;);</span>
        }

<span class="nc" id="L386">        daemon.thriftServer.start();</span>
<span class="nc" id="L387">    }</span>

    public void stopRPCServer()
    {
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (daemon == null)</span>
        {
<span class="nc" id="L393">            throw new IllegalStateException(&quot;No configured daemon&quot;);</span>
        }
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (daemon.thriftServer != null)</span>
<span class="fc" id="L396">            daemon.thriftServer.stop();</span>
<span class="fc" id="L397">    }</span>

    public boolean isRPCServerRunning()
    {
<span class="nc bnc" id="L401" title="All 4 branches missed.">        if ((daemon == null) || (daemon.thriftServer == null))</span>
        {
<span class="nc" id="L403">            return false;</span>
        }
<span class="nc" id="L405">        return daemon.thriftServer.isRunning();</span>
    }

    public synchronized void startNativeTransport()
    {
<span class="nc" id="L410">        checkServiceAllowedToStart(&quot;native transport&quot;);</span>

<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (daemon == null)</span>
        {
<span class="nc" id="L414">            throw new IllegalStateException(&quot;No configured daemon&quot;);</span>
        }

        try
        {
<span class="nc" id="L419">            daemon.startNativeTransport();</span>
        }
<span class="nc" id="L421">        catch (Exception e)</span>
        {
<span class="nc" id="L423">            throw new RuntimeException(&quot;Error starting native transport: &quot; + e.getMessage());</span>
<span class="nc" id="L424">        }</span>
<span class="nc" id="L425">    }</span>

    public void stopNativeTransport()
    {
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (daemon == null)</span>
        {
<span class="nc" id="L431">            throw new IllegalStateException(&quot;No configured daemon&quot;);</span>
        }
<span class="fc" id="L433">        daemon.stopNativeTransport();</span>
<span class="fc" id="L434">    }</span>

    public boolean isNativeTransportRunning()
    {
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (daemon == null)</span>
        {
<span class="nc" id="L440">            return false;</span>
        }
<span class="nc" id="L442">        return daemon.isNativeTransportRunning();</span>
    }

    public int getMaxNativeProtocolVersion()
    {
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (daemon == null)</span>
        {
<span class="nc" id="L449">            throw new IllegalStateException(&quot;No configured daemon&quot;);</span>
        }
<span class="nc" id="L451">        return daemon.getMaxNativeProtocolVersion();</span>
    }

    private void refreshMaxNativeProtocolVersion()
    {
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">        if (daemon != null)</span>
        {
<span class="fc" id="L458">            daemon.refreshMaxNativeProtocolVersion();</span>
        }
<span class="fc" id="L460">    }</span>

    public void stopTransports()
    {
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (isGossipActive())</span>
        {
<span class="nc" id="L466">            logger.error(&quot;Stopping gossiper&quot;);</span>
<span class="nc" id="L467">            stopGossiping();</span>
        }
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (isRPCServerRunning())</span>
        {
<span class="nc" id="L471">            logger.error(&quot;Stopping RPC server&quot;);</span>
<span class="nc" id="L472">            stopRPCServer();</span>
        }
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (isNativeTransportRunning())</span>
        {
<span class="nc" id="L476">            logger.error(&quot;Stopping native transport&quot;);</span>
<span class="nc" id="L477">            stopNativeTransport();</span>
        }
<span class="nc" id="L479">    }</span>

    /**
     * Set the Gossip flag RPC_READY to false and then
     * shutdown the client services (thrift and CQL).
     *
     * Note that other nodes will do this for us when
     * they get the Gossip shutdown message, so even if
     * we don't get time to broadcast this, it is not a problem.
     *
     * See {@link Gossiper#markAsShutdown(InetAddress)}
     */
    private void shutdownClientServers()
    {
<span class="fc" id="L493">        setRpcReady(false);</span>
<span class="fc" id="L494">        stopRPCServer();</span>
<span class="fc" id="L495">        stopNativeTransport();</span>
<span class="fc" id="L496">    }</span>

    public void stopClient()
    {
<span class="nc" id="L500">        Gossiper.instance.unregister(this);</span>
<span class="nc" id="L501">        Gossiper.instance.stop();</span>
<span class="nc" id="L502">        MessagingService.instance().shutdown();</span>
        // give it a second so that task accepted before the MessagingService shutdown gets submitted to the stage (to avoid RejectedExecutionException)
<span class="nc" id="L504">        Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);</span>
<span class="nc" id="L505">        StageManager.shutdownNow();</span>
<span class="nc" id="L506">    }</span>

    public boolean isInitialized()
    {
<span class="fc" id="L510">        return initialized;</span>
    }

    public boolean isGossipActive()
    {
<span class="fc" id="L515">        return gossipActive;</span>
    }

    public boolean isDaemonSetupCompleted()
    {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        return daemon == null</span>
               ? false
<span class="nc" id="L522">               : daemon.setupCompleted();</span>
    }

    public void stopDaemon()
    {
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (daemon == null)</span>
<span class="nc" id="L528">            throw new IllegalStateException(&quot;No configured daemon&quot;);</span>
<span class="nc" id="L529">        daemon.deactivate();</span>
<span class="nc" id="L530">    }</span>

    private synchronized UUID prepareForReplacement() throws ConfigurationException
    {
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (SystemKeyspace.bootstrapComplete())</span>
<span class="nc" id="L535">            throw new RuntimeException(&quot;Cannot replace address with a node that is already bootstrapped&quot;);</span>

<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (!joinRing)</span>
<span class="nc" id="L538">            throw new ConfigurationException(&quot;Cannot set both join_ring=false and attempt to replace a node&quot;);</span>

<span class="nc bnc" id="L540" title="All 4 branches missed.">        if (!DatabaseDescriptor.isAutoBootstrap() &amp;&amp; !Boolean.getBoolean(&quot;cassandra.allow_unsafe_replace&quot;))</span>
<span class="nc" id="L541">            throw new RuntimeException(&quot;Replacing a node without bootstrapping risks invalidating consistency &quot; +</span>
                                       &quot;guarantees as the expected data may not be present until repair is run. &quot; +
                                       &quot;To perform this operation, please restart with &quot; +
                                       &quot;-Dcassandra.allow_unsafe_replace=true&quot;);

<span class="nc" id="L546">        InetAddress replaceAddress = DatabaseDescriptor.getReplaceAddress();</span>
<span class="nc" id="L547">        logger.info(&quot;Gathering node replacement information for {}&quot;, replaceAddress);</span>
<span class="nc" id="L548">        Map&lt;InetAddress, EndpointState&gt; epStates = Gossiper.instance.doShadowRound();</span>
        // as we've completed the shadow round of gossip, we should be able to find the node we're replacing
<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (epStates.get(replaceAddress) == null)</span>
<span class="nc" id="L551">            throw new RuntimeException(String.format(&quot;Cannot replace_address %s because it doesn't exist in gossip&quot;, replaceAddress));</span>

        try
        {
<span class="nc" id="L555">            VersionedValue tokensVersionedValue = epStates.get(replaceAddress).getApplicationState(ApplicationState.TOKENS);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if (tokensVersionedValue == null)</span>
<span class="nc" id="L557">                throw new RuntimeException(String.format(&quot;Could not find tokens for %s to replace&quot;, replaceAddress));</span>

<span class="nc" id="L559">            bootstrapTokens = TokenSerializer.deserialize(tokenMetadata.partitioner, new DataInputStream(new ByteArrayInputStream(tokensVersionedValue.toBytes())));</span>
        }
<span class="nc" id="L561">        catch (IOException e)</span>
        {
<span class="nc" id="L563">            throw new RuntimeException(e);</span>
<span class="nc" id="L564">        }</span>

<span class="nc" id="L566">        UUID localHostId = SystemKeyspace.getLocalHostId();</span>

<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (isReplacingSameAddress())</span>
        {
<span class="nc" id="L570">            localHostId = Gossiper.instance.getHostId(replaceAddress, epStates);</span>
<span class="nc" id="L571">            SystemKeyspace.setLocalHostId(localHostId); // use the replacee's host Id as our own so we receive hints, etc</span>
        }

<span class="nc" id="L574">        return localHostId;</span>
    }

    private synchronized void checkForEndpointCollision(UUID localHostId, Set&lt;InetAddress&gt; peers) throws ConfigurationException
    {
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        if (Boolean.getBoolean(&quot;cassandra.allow_unsafe_join&quot;))</span>
        {
<span class="nc" id="L581">            logger.warn(&quot;Skipping endpoint collision check as cassandra.allow_unsafe_join=true&quot;);</span>
<span class="nc" id="L582">            return;</span>
        }

<span class="fc" id="L585">        logger.debug(&quot;Starting shadow gossip round to check for endpoint collision&quot;);</span>
<span class="fc" id="L586">        Map&lt;InetAddress, EndpointState&gt; epStates = Gossiper.instance.doShadowRound(peers);</span>

<span class="pc bpc" id="L588" title="1 of 4 branches missed.">        if (epStates.isEmpty() &amp;&amp; DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddress()))</span>
<span class="fc" id="L589">            logger.info(&quot;Unable to gossip with any peers but continuing anyway since node is in its own seed list&quot;);</span>

        // If bootstrapping, check whether any previously known status for the endpoint makes it unsafe to do so.
        // If not bootstrapping, compare the host id for this endpoint learned from gossip (if any) with the local
        // one, which was either read from system.local or generated at startup. If a learned id is present &amp;
        // doesn't match the local, then the node needs replacing
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (!Gossiper.instance.isSafeForStartup(FBUtilities.getBroadcastAddress(), localHostId, shouldBootstrap(), epStates))</span>
        {
<span class="nc" id="L597">            throw new RuntimeException(String.format(&quot;A node with address %s already exists, cancelling join. &quot; +</span>
                                                     &quot;Use cassandra.replace_address if you want to replace this node.&quot;,
<span class="nc" id="L599">                                                     FBUtilities.getBroadcastAddress()));</span>
        }

<span class="pc bpc" id="L602" title="5 of 6 branches missed.">        if (shouldBootstrap() &amp;&amp; useStrictConsistency &amp;&amp; !allowSimultaneousMoves())</span>
        {
<span class="nc bnc" id="L604" title="All 2 branches missed.">            for (Map.Entry&lt;InetAddress, EndpointState&gt; entry : epStates.entrySet())</span>
            {
                // ignore local node or empty status
<span class="nc bnc" id="L607" title="All 4 branches missed.">                if (entry.getKey().equals(FBUtilities.getBroadcastAddress()) || entry.getValue().getApplicationState(ApplicationState.STATUS) == null)</span>
<span class="nc" id="L608">                    continue;</span>
<span class="nc" id="L609">                String[] pieces = splitValue(entry.getValue().getApplicationState(ApplicationState.STATUS));</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">                assert (pieces.length &gt; 0);</span>
<span class="nc" id="L611">                String state = pieces[0];</span>
<span class="nc bnc" id="L612" title="All 6 branches missed.">                if (state.equals(VersionedValue.STATUS_BOOTSTRAPPING) || state.equals(VersionedValue.STATUS_LEAVING) || state.equals(VersionedValue.STATUS_MOVING))</span>
<span class="nc" id="L613">                    throw new UnsupportedOperationException(&quot;Other bootstrapping/leaving/moving nodes detected, cannot bootstrap while cassandra.consistent.rangemovement is true&quot;);</span>
<span class="nc" id="L614">            }</span>
        }
<span class="fc" id="L616">    }</span>

    private boolean allowSimultaneousMoves()
    {
<span class="nc bnc" id="L620" title="All 4 branches missed.">        return allowSimultaneousMoves &amp;&amp; DatabaseDescriptor.getNumTokens() == 1;</span>
    }

    // for testing only
    public void unsafeInitialize() throws ConfigurationException
    {
<span class="nc" id="L626">        initialized = true;</span>
<span class="nc" id="L627">        gossipActive = true;</span>
<span class="nc" id="L628">        Gossiper.instance.register(this);</span>
<span class="nc" id="L629">        Gossiper.instance.start((int) (System.currentTimeMillis() / 1000)); // needed for node-ring gathering.</span>
<span class="nc" id="L630">        Gossiper.instance.addLocalApplicationState(ApplicationState.NET_VERSION, valueFactory.networkVersion());</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (!MessagingService.instance().isListening())</span>
<span class="nc" id="L632">            MessagingService.instance().listen();</span>
<span class="nc" id="L633">    }</span>

    public void populateTokenMetadata()
    {
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">        if (Boolean.parseBoolean(System.getProperty(&quot;cassandra.load_ring_state&quot;, &quot;true&quot;)))</span>
        {
<span class="fc" id="L639">            logger.info(&quot;Populating token metadata from system tables&quot;);</span>
<span class="fc" id="L640">            Multimap&lt;InetAddress, Token&gt; loadedTokens = SystemKeyspace.loadTokens();</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">            if (!shouldBootstrap()) // if we have not completed bootstrapping, we should not add ourselves as a normal token</span>
<span class="fc" id="L642">                loadedTokens.putAll(FBUtilities.getBroadcastAddress(), SystemKeyspace.getSavedTokens());</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">            for (InetAddress ep : loadedTokens.keySet())</span>
<span class="nc" id="L644">                tokenMetadata.updateNormalTokens(loadedTokens.get(ep), ep);</span>

<span class="fc" id="L646">            logger.info(&quot;Token metadata: {}&quot;, tokenMetadata);</span>
        }
<span class="fc" id="L648">    }</span>

    public synchronized void initServer() throws ConfigurationException
    {
<span class="fc" id="L652">        initServer(RING_DELAY);</span>
<span class="fc" id="L653">    }</span>

    public synchronized void initServer(int delay) throws ConfigurationException
    {
<span class="fc" id="L657">        logger.info(&quot;Cassandra version: {}&quot;, FBUtilities.getReleaseVersionString());</span>
<span class="fc" id="L658">        logger.info(&quot;Thrift API version: {}&quot;, cassandraConstants.VERSION);</span>
<span class="fc" id="L659">        logger.info(&quot;CQL supported versions: {} (default: {})&quot;,</span>
<span class="fc" id="L660">                StringUtils.join(ClientState.getCQLSupportedVersion(), &quot;, &quot;), ClientState.DEFAULT_CQL_VERSION);</span>
<span class="fc" id="L661">        logger.info(&quot;Native protocol supported versions: {} (default: {})&quot;,</span>
<span class="fc" id="L662">                    StringUtils.join(ProtocolVersion.supportedVersions(), &quot;, &quot;), ProtocolVersion.CURRENT);</span>

        try
        {
            // Ensure StorageProxy is initialized on start-up; see CASSANDRA-3797.
<span class="fc" id="L667">            Class.forName(&quot;org.apache.cassandra.service.StorageProxy&quot;);</span>
            // also IndexSummaryManager, which is otherwise unreferenced
<span class="fc" id="L669">            Class.forName(&quot;org.apache.cassandra.io.sstable.IndexSummaryManager&quot;);</span>
        }
<span class="nc" id="L671">        catch (ClassNotFoundException e)</span>
        {
<span class="nc" id="L673">            throw new AssertionError(e);</span>
<span class="fc" id="L674">        }</span>

        // daemon threads, like our executors', continue to run while shutdown hooks are invoked
<span class="fc" id="L677">        drainOnShutdown = NamedThreadFactory.createThread(new WrappedRunnable()</span>
<span class="fc" id="L678">        {</span>
            @Override
            public void runMayThrow() throws InterruptedException, ExecutionException, IOException
            {
<span class="nc" id="L682">                drain(true);</span>

<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (FBUtilities.isWindows)</span>
<span class="nc" id="L685">                    WindowsTimer.endTimerPeriod(DatabaseDescriptor.getWindowsTimerInterval());</span>

<span class="nc" id="L687">                LoggingSupportFactory.getLoggingSupport().onShutdown();</span>
<span class="nc" id="L688">            }</span>
        }, &quot;StorageServiceShutdownHook&quot;);
<span class="fc" id="L690">        Runtime.getRuntime().addShutdownHook(drainOnShutdown);</span>

<span class="fc" id="L692">        replacing = isReplacing();</span>

<span class="pc bpc" id="L694" title="1 of 2 branches missed.">        if (!Boolean.parseBoolean(System.getProperty(&quot;cassandra.start_gossip&quot;, &quot;true&quot;)))</span>
        {
<span class="nc" id="L696">            logger.info(&quot;Not starting gossip as requested.&quot;);</span>
            // load ring state in preparation for starting gossip later
<span class="nc" id="L698">            loadRingState();</span>
<span class="nc" id="L699">            initialized = true;</span>
<span class="nc" id="L700">            return;</span>
        }

<span class="fc" id="L703">        prepareToJoin();</span>

        // Has to be called after the host id has potentially changed in prepareToJoin().
        try
        {
<span class="fc" id="L708">            CacheService.instance.counterCache.loadSavedAsync().get();</span>
        }
<span class="nc" id="L710">        catch (Throwable t)</span>
        {
<span class="nc" id="L712">            JVMStabilityInspector.inspectThrowable(t);</span>
<span class="nc" id="L713">            logger.warn(&quot;Error loading counter cache&quot;, t);</span>
<span class="fc" id="L714">        }</span>

<span class="pc bpc" id="L716" title="1 of 2 branches missed.">        if (joinRing)</span>
        {
<span class="fc" id="L718">            joinTokenRing(delay);</span>
        }
        else
        {
<span class="nc" id="L722">            Collection&lt;Token&gt; tokens = SystemKeyspace.getSavedTokens();</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (!tokens.isEmpty())</span>
            {
<span class="nc" id="L725">                tokenMetadata.updateNormalTokens(tokens, FBUtilities.getBroadcastAddress());</span>
                // order is important here, the gossiper can fire in between adding these two states.  It's ok to send TOKENS without STATUS, but *not* vice versa.
<span class="nc" id="L727">                List&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt; states = new ArrayList&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt;();</span>
<span class="nc" id="L728">                states.add(Pair.create(ApplicationState.TOKENS, valueFactory.tokens(tokens)));</span>
<span class="nc" id="L729">                states.add(Pair.create(ApplicationState.STATUS, valueFactory.hibernate(true)));</span>
<span class="nc" id="L730">                Gossiper.instance.addLocalApplicationStates(states);</span>
            }
<span class="nc" id="L732">            doAuthSetup(true);</span>
<span class="nc" id="L733">            logger.info(&quot;Not joining ring as requested. Use JMX (StorageService-&gt;joinRing()) to initiate ring joining&quot;);</span>
        }

<span class="fc" id="L736">        initialized = true;</span>
<span class="fc" id="L737">    }</span>

    private void loadRingState()
    {
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        if (Boolean.parseBoolean(System.getProperty(&quot;cassandra.load_ring_state&quot;, &quot;true&quot;)))</span>
        {
<span class="fc" id="L743">            logger.info(&quot;Loading persisted ring state&quot;);</span>
<span class="fc" id="L744">            Multimap&lt;InetAddress, Token&gt; loadedTokens = SystemKeyspace.loadTokens();</span>
<span class="fc" id="L745">            Map&lt;InetAddress, UUID&gt; loadedHostIds = SystemKeyspace.loadHostIds();</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">            for (InetAddress ep : loadedTokens.keySet())</span>
            {
<span class="nc bnc" id="L748" title="All 2 branches missed.">                if (ep.equals(FBUtilities.getBroadcastAddress()))</span>
                {
                    // entry has been mistakenly added, delete it
<span class="nc" id="L751">                    SystemKeyspace.removeEndpoint(ep);</span>
                }
                else
                {
<span class="nc bnc" id="L755" title="All 2 branches missed.">                    if (loadedHostIds.containsKey(ep))</span>
<span class="nc" id="L756">                        tokenMetadata.updateHostId(loadedHostIds.get(ep), ep);</span>
<span class="nc" id="L757">                    Gossiper.runInGossipStageBlocking(() -&gt; Gossiper.instance.addSavedEndpoint(ep));</span>
                }
<span class="nc" id="L759">            }</span>
        }
<span class="fc" id="L761">    }</span>

    private boolean isReplacing()
    {
<span class="pc bpc" id="L765" title="3 of 4 branches missed.">        if (System.getProperty(&quot;cassandra.replace_address_first_boot&quot;, null) != null &amp;&amp; SystemKeyspace.bootstrapComplete())</span>
        {
<span class="nc" id="L767">            logger.info(&quot;Replace address on first boot requested; this node is already bootstrapped&quot;);</span>
<span class="nc" id="L768">            return false;</span>
        }
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">        return DatabaseDescriptor.getReplaceAddress() != null;</span>
    }

    /**
     * In the event of forceful termination we need to remove the shutdown hook to prevent hanging (OOM for instance)
     */
    public void removeShutdownHook()
    {
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (drainOnShutdown != null)</span>
<span class="nc" id="L779">            Runtime.getRuntime().removeShutdownHook(drainOnShutdown);</span>

<span class="nc bnc" id="L781" title="All 2 branches missed.">        if (FBUtilities.isWindows)</span>
<span class="nc" id="L782">            WindowsTimer.endTimerPeriod(DatabaseDescriptor.getWindowsTimerInterval());</span>
<span class="nc" id="L783">    }</span>

    private boolean shouldBootstrap()
    {
<span class="pc bpc" id="L787" title="5 of 6 branches missed.">        return DatabaseDescriptor.isAutoBootstrap() &amp;&amp; !SystemKeyspace.bootstrapComplete() &amp;&amp; !isSeed();</span>
    }

    public static boolean isSeed()
    {
<span class="nc" id="L792">        return DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddress());</span>
    }

    @VisibleForTesting
    public void prepareToJoin() throws ConfigurationException
    {
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">        if (!joined)</span>
        {
<span class="fc" id="L800">            Map&lt;ApplicationState, VersionedValue&gt; appStates = new EnumMap&lt;&gt;(ApplicationState.class);</span>

<span class="pc bpc" id="L802" title="1 of 2 branches missed.">            if (SystemKeyspace.wasDecommissioned())</span>
            {
<span class="nc bnc" id="L804" title="All 2 branches missed.">                if (Boolean.getBoolean(&quot;cassandra.override_decommission&quot;))</span>
                {
<span class="nc" id="L806">                    logger.warn(&quot;This node was decommissioned, but overriding by operator request.&quot;);</span>
<span class="nc" id="L807">                    SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.COMPLETED);</span>
                }
                else
<span class="nc" id="L810">                    throw new ConfigurationException(&quot;This node was decommissioned and will not rejoin the ring unless cassandra.override_decommission=true has been set, or all existing data is removed and the node is bootstrapped again&quot;);</span>
            }

<span class="pc bpc" id="L813" title="2 of 4 branches missed.">            if (DatabaseDescriptor.getReplaceTokens().size() &gt; 0 || DatabaseDescriptor.getReplaceNode() != null)</span>
<span class="nc" id="L814">                throw new RuntimeException(&quot;Replace method removed; use cassandra.replace_address instead&quot;);</span>

<span class="pc bpc" id="L816" title="1 of 2 branches missed.">            if (!MessagingService.instance().isListening())</span>
<span class="fc" id="L817">                MessagingService.instance().listen();</span>

<span class="fc" id="L819">            UUID localHostId = SystemKeyspace.getLocalHostId();</span>

<span class="pc bpc" id="L821" title="1 of 2 branches missed.">            if (replacing)</span>
            {
<span class="nc" id="L823">                localHostId = prepareForReplacement();</span>
<span class="nc" id="L824">                appStates.put(ApplicationState.TOKENS, valueFactory.tokens(bootstrapTokens));</span>

<span class="nc bnc" id="L826" title="All 2 branches missed.">                if (!DatabaseDescriptor.isAutoBootstrap())</span>
                {
                    // Will not do replace procedure, persist the tokens we're taking over locally
                    // so that they don't get clobbered with auto generated ones in joinTokenRing
<span class="nc" id="L830">                    SystemKeyspace.updateTokens(bootstrapTokens);</span>
                }
<span class="nc bnc" id="L832" title="All 2 branches missed.">                else if (isReplacingSameAddress())</span>
                {
                    //only go into hibernate state if replacing the same address (CASSANDRA-8523)
<span class="nc" id="L835">                    logger.warn(&quot;Writes will not be forwarded to this node during replacement because it has the same address as &quot; +</span>
                                &quot;the node to be replaced ({}). If the previous node has been down for longer than max_hint_window_in_ms, &quot; +
                                &quot;repair must be run after the replacement process in order to make this node consistent.&quot;,
<span class="nc" id="L838">                                DatabaseDescriptor.getReplaceAddress());</span>
<span class="nc" id="L839">                    appStates.put(ApplicationState.STATUS, valueFactory.hibernate(true));</span>
                }
            }
            else
            {
<span class="fc" id="L844">                checkForEndpointCollision(localHostId, SystemKeyspace.loadHostIds().keySet());</span>
<span class="pc bpc" id="L845" title="1 of 2 branches missed.">                if (SystemKeyspace.bootstrapComplete())</span>
                {
<span class="nc bnc" id="L847" title="All 2 branches missed.">                    Preconditions.checkState(!Config.isClientMode());</span>
                    // tokens are only ever saved to system.local after bootstrap has completed and we're joining the ring,
                    // or when token update operations (move, decom) are completed
<span class="nc" id="L850">                    Collection&lt;Token&gt; savedTokens = SystemKeyspace.getSavedTokens();</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">                    if (!savedTokens.isEmpty())</span>
<span class="nc" id="L852">                        appStates.put(ApplicationState.TOKENS, valueFactory.tokens(savedTokens));</span>
                }
            }

            // have to start the gossip service before we can see any info on other nodes.  this is necessary
            // for bootstrap to get the load info it needs.
            // (we won't be part of the storage ring though until we add a counterId to our state, below.)
            // Seed the host ID-to-endpoint map with our own ID.
<span class="fc" id="L860">            getTokenMetadata().updateHostId(localHostId, FBUtilities.getBroadcastAddress());</span>
<span class="fc" id="L861">            appStates.put(ApplicationState.NET_VERSION, valueFactory.networkVersion());</span>
<span class="fc" id="L862">            appStates.put(ApplicationState.HOST_ID, valueFactory.hostId(localHostId));</span>
<span class="fc" id="L863">            appStates.put(ApplicationState.RPC_ADDRESS, valueFactory.rpcaddress(FBUtilities.getBroadcastRpcAddress()));</span>
<span class="fc" id="L864">            appStates.put(ApplicationState.RELEASE_VERSION, valueFactory.releaseVersion());</span>

            // load the persisted ring state. This used to be done earlier in the init process,
            // but now we always perform a shadow round when preparing to join and we have to
            // clear endpoint states after doing that.
<span class="fc" id="L869">            loadRingState();</span>

<span class="fc" id="L871">            logger.info(&quot;Starting up server gossip&quot;);</span>
<span class="fc" id="L872">            Gossiper.instance.register(this);</span>
<span class="fc" id="L873">            Gossiper.instance.start(SystemKeyspace.incrementAndGetGeneration(), appStates); // needed for node-ring gathering.</span>
<span class="fc" id="L874">            gossipActive = true;</span>
            // gossip snitch infos (local DC and rack)
<span class="fc" id="L876">            gossipSnitchInfo();</span>
            // gossip Schema.emptyVersion forcing immediate check for schema updates (see MigrationManager#maybeScheduleSchemaPull)
<span class="fc" id="L878">            Schema.instance.updateVersionAndAnnounce(); // Ensure we know our own actual Schema UUID in preparation for updates</span>
<span class="fc" id="L879">            LoadBroadcaster.instance.startBroadcasting();</span>
<span class="fc" id="L880">            HintsService.instance.startDispatch();</span>
<span class="fc" id="L881">            BatchlogManager.instance.start();</span>
        }
<span class="fc" id="L883">    }</span>

    public void waitForSchema(int delay)
    {
        // first sleep the delay to make sure we see all our peers
<span class="nc bnc" id="L888" title="All 2 branches missed.">        for (int i = 0; i &lt; delay; i += 1000)</span>
        {
            // if we see schema, we can proceed to the next check directly
<span class="nc bnc" id="L891" title="All 2 branches missed.">            if (!Schema.instance.getVersion().equals(SchemaConstants.emptyVersion))</span>
            {
<span class="nc" id="L893">                logger.debug(&quot;got schema: {}&quot;, Schema.instance.getVersion());</span>
<span class="nc" id="L894">                break;</span>
            }
<span class="nc" id="L896">            Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);</span>
        }
        // if our schema hasn't matched yet, wait until it has
        // we do this by waiting for all in-flight migration requests and responses to complete
        // (post CASSANDRA-1391 we don't expect this to be necessary very often, but it doesn't hurt to be careful)
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (!MigrationManager.isReadyForBootstrap())</span>
        {
<span class="nc" id="L903">            setMode(Mode.JOINING, &quot;waiting for schema information to complete&quot;, true);</span>
<span class="nc" id="L904">            MigrationManager.waitUntilReadyForBootstrap();</span>
        }
<span class="nc" id="L906">    }</span>

    @VisibleForTesting
    public void joinTokenRing(int delay) throws ConfigurationException
{
<span class="fc" id="L911">        joined = true;</span>

        // We bootstrap if we haven't successfully bootstrapped before, as long as we are not a seed.
        // If we are a seed, or if the user manually sets auto_bootstrap to false,
        // we'll skip streaming data from other nodes and jump directly into the ring.
        //
        // The seed check allows us to skip the RING_DELAY sleep for the single-node cluster case,
        // which is useful for both new users and testing.
        //
        // We attempted to replace this with a schema-presence check, but you need a meaningful sleep
        // to get schema info from gossip which defeats the purpose.  See CASSANDRA-4427 for the gory details.
<span class="fc" id="L922">        Set&lt;InetAddress&gt; current = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
        {
<span class="fc" id="L925">            logger.debug(&quot;Bootstrap variables: {} {} {} {}&quot;,</span>
<span class="fc" id="L926">                         DatabaseDescriptor.isAutoBootstrap(),</span>
<span class="fc" id="L927">                         SystemKeyspace.bootstrapInProgress(),</span>
<span class="fc" id="L928">                         SystemKeyspace.bootstrapComplete(),</span>
<span class="fc" id="L929">                         DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddress()));</span>
        }
<span class="pc bpc" id="L931" title="5 of 6 branches missed.">        if (DatabaseDescriptor.isAutoBootstrap() &amp;&amp; !SystemKeyspace.bootstrapComplete() &amp;&amp; DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddress()))</span>
        {
<span class="nc" id="L933">            logger.info(&quot;This node will not auto bootstrap because it is configured to be a seed node.&quot;);</span>
        }

<span class="fc" id="L936">        boolean dataAvailable = true; // make this to false when bootstrap streaming failed</span>
<span class="fc" id="L937">        boolean bootstrap = shouldBootstrap();</span>
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        if (bootstrap)</span>
        {
<span class="nc bnc" id="L940" title="All 2 branches missed.">            if (SystemKeyspace.bootstrapInProgress())</span>
<span class="nc" id="L941">                logger.warn(&quot;Detected previous bootstrap failure; retrying&quot;);</span>
            else
<span class="nc" id="L943">                SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.IN_PROGRESS);</span>
<span class="nc" id="L944">            setMode(Mode.JOINING, &quot;waiting for ring information&quot;, true);</span>
<span class="nc" id="L945">            waitForSchema(delay);</span>
<span class="nc" id="L946">            setMode(Mode.JOINING, &quot;schema complete, ready to bootstrap&quot;, true);</span>
<span class="nc" id="L947">            setMode(Mode.JOINING, &quot;waiting for pending range calculation&quot;, true);</span>
<span class="nc" id="L948">            PendingRangeCalculatorService.instance.blockUntilFinished();</span>
<span class="nc" id="L949">            setMode(Mode.JOINING, &quot;calculation complete, ready to bootstrap&quot;, true);</span>

<span class="nc" id="L951">            logger.debug(&quot;... got ring + schema info&quot;);</span>

<span class="nc bnc" id="L953" title="All 4 branches missed.">            if (useStrictConsistency &amp;&amp; !allowSimultaneousMoves() &amp;&amp;</span>
                    (
<span class="nc bnc" id="L955" title="All 2 branches missed.">                        tokenMetadata.getBootstrapTokens().valueSet().size() &gt; 0 ||</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">                        tokenMetadata.getLeavingEndpoints().size() &gt; 0 ||</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">                        tokenMetadata.getMovingEndpoints().size() &gt; 0</span>
                    ))
            {
<span class="nc" id="L960">                String bootstrapTokens = StringUtils.join(tokenMetadata.getBootstrapTokens().valueSet(), ',');</span>
<span class="nc" id="L961">                String leavingTokens = StringUtils.join(tokenMetadata.getLeavingEndpoints(), ',');</span>
<span class="nc" id="L962">                String movingTokens = StringUtils.join(tokenMetadata.getMovingEndpoints().stream().map(e -&gt; e.right).toArray(), ',');</span>
<span class="nc" id="L963">                throw new UnsupportedOperationException(String.format(&quot;Other bootstrapping/leaving/moving nodes detected, cannot bootstrap while cassandra.consistent.rangemovement is true. Nodes detected, bootstrapping: %s; leaving: %s; moving: %s;&quot;, bootstrapTokens, leavingTokens, movingTokens));</span>
            }

            // get bootstrap tokens
<span class="nc bnc" id="L967" title="All 2 branches missed.">            if (!replacing)</span>
            {
<span class="nc bnc" id="L969" title="All 2 branches missed.">                if (tokenMetadata.isMember(FBUtilities.getBroadcastAddress()))</span>
                {
<span class="nc" id="L971">                    String s = &quot;This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)&quot;;</span>
<span class="nc" id="L972">                    throw new UnsupportedOperationException(s);</span>
                }
<span class="nc" id="L974">                setMode(Mode.JOINING, &quot;getting bootstrap token&quot;, true);</span>
<span class="nc" id="L975">                bootstrapTokens = BootStrapper.getBootstrapTokens(tokenMetadata, FBUtilities.getBroadcastAddress(), delay);</span>
            }
            else
            {
<span class="nc bnc" id="L979" title="All 2 branches missed.">                if (!isReplacingSameAddress())</span>
                {
                    try
                    {
                        // Sleep additionally to make sure that the server actually is not alive
                        // and giving it more time to gossip if alive.
<span class="nc" id="L985">                        Thread.sleep(LoadBroadcaster.BROADCAST_INTERVAL);</span>
                    }
<span class="nc" id="L987">                    catch (InterruptedException e)</span>
                    {
<span class="nc" id="L989">                        throw new AssertionError(e);</span>
<span class="nc" id="L990">                    }</span>

                    // check for operator errors...
<span class="nc bnc" id="L993" title="All 2 branches missed.">                    for (Token token : bootstrapTokens)</span>
                    {
<span class="nc" id="L995">                        InetAddress existing = tokenMetadata.getEndpoint(token);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">                        if (existing != null)</span>
                        {
<span class="nc" id="L998">                            long nanoDelay = delay * 1000000L;</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">                            if (Gossiper.instance.getEndpointStateForEndpoint(existing).getUpdateTimestamp() &gt; (System.nanoTime() - nanoDelay))</span>
<span class="nc" id="L1000">                                throw new UnsupportedOperationException(&quot;Cannot replace a live node... &quot;);</span>
<span class="nc" id="L1001">                            current.add(existing);</span>
<span class="nc" id="L1002">                        }</span>
                        else
                        {
<span class="nc" id="L1005">                            throw new UnsupportedOperationException(&quot;Cannot replace token &quot; + token + &quot; which does not exist!&quot;);</span>
                        }
<span class="nc" id="L1007">                    }</span>
                }
                else
                {
                    try
                    {
<span class="nc" id="L1013">                        Thread.sleep(RING_DELAY);</span>
                    }
<span class="nc" id="L1015">                    catch (InterruptedException e)</span>
                    {
<span class="nc" id="L1017">                        throw new AssertionError(e);</span>
<span class="nc" id="L1018">                    }</span>

                }
<span class="nc" id="L1021">                setMode(Mode.JOINING, &quot;Replacing a node with token(s): &quot; + bootstrapTokens, true);</span>
            }

<span class="nc" id="L1024">            dataAvailable = bootstrap(bootstrapTokens);</span>
        }
        else
        {
<span class="fc" id="L1028">            bootstrapTokens = SystemKeyspace.getSavedTokens();</span>
<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">            if (bootstrapTokens.isEmpty())</span>
            {
<span class="fc" id="L1031">                bootstrapTokens = BootStrapper.getBootstrapTokens(tokenMetadata, FBUtilities.getBroadcastAddress(), delay);</span>
            }
            else
            {
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                if (bootstrapTokens.size() != DatabaseDescriptor.getNumTokens())</span>
<span class="nc" id="L1036">                    throw new ConfigurationException(&quot;Cannot change the number of tokens from &quot; + bootstrapTokens.size() + &quot; to &quot; + DatabaseDescriptor.getNumTokens());</span>
                else
<span class="nc" id="L1038">                    logger.info(&quot;Using saved tokens {}&quot;, bootstrapTokens);</span>
            }
        }

<span class="fc" id="L1042">        setUpDistributedSystemKeyspaces();</span>

<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        if (!isSurveyMode)</span>
        {
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">            if (dataAvailable)</span>
            {
<span class="fc" id="L1048">                finishJoiningRing(bootstrap, bootstrapTokens);</span>
                // remove the existing info about the replaced node.
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">                if (!current.isEmpty())</span>
                {
<span class="nc" id="L1052">                    Gossiper.runInGossipStageBlocking(() -&gt; {</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                        for (InetAddress existing : current)</span>
<span class="nc" id="L1054">                            Gossiper.instance.replacedEndpoint(existing);</span>
<span class="nc" id="L1055">                    });</span>
                }
            }
            else
            {
<span class="nc" id="L1060">                logger.warn(&quot;Some data streaming failed. Use nodetool to check bootstrap state and resume. For more, see `nodetool help bootstrap`. {}&quot;, SystemKeyspace.getBootstrapState());</span>
            }
        }
        else
        {
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            if (dataAvailable)</span>
<span class="nc" id="L1066">                logger.info(&quot;Startup complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService-&gt;joinRing()) to finalize ring joining.&quot;);</span>
            else
<span class="nc" id="L1068">                logger.warn(&quot;Some data streaming failed. Use nodetool to check bootstrap state and resume. For more, see `nodetool help bootstrap`. {}&quot;, SystemKeyspace.getBootstrapState());</span>
        }
<span class="fc" id="L1070">    }</span>

    @VisibleForTesting
    public void ensureTraceKeyspace()
    {
<span class="nc" id="L1075">        evolveSystemKeyspace(TraceKeyspace.metadata(), TraceKeyspace.GENERATION).ifPresent(MigrationManager::announceGlobally);</span>
<span class="nc" id="L1076">    }</span>

    public static boolean isReplacingSameAddress()
    {
<span class="nc" id="L1080">        InetAddress replaceAddress = DatabaseDescriptor.getReplaceAddress();</span>
<span class="nc bnc" id="L1081" title="All 4 branches missed.">        return replaceAddress != null &amp;&amp; replaceAddress.equals(FBUtilities.getBroadcastAddress());</span>
    }

    public void gossipSnitchInfo()
    {
<span class="fc" id="L1086">        IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();</span>
<span class="fc" id="L1087">        String dc = snitch.getDatacenter(FBUtilities.getBroadcastAddress());</span>
<span class="fc" id="L1088">        String rack = snitch.getRack(FBUtilities.getBroadcastAddress());</span>
<span class="fc" id="L1089">        Gossiper.instance.addLocalApplicationState(ApplicationState.DC, StorageService.instance.valueFactory.datacenter(dc));</span>
<span class="fc" id="L1090">        Gossiper.instance.addLocalApplicationState(ApplicationState.RACK, StorageService.instance.valueFactory.rack(rack));</span>
<span class="fc" id="L1091">    }</span>

    public void joinRing() throws IOException
    {
<span class="nc" id="L1095">        SystemKeyspace.BootstrapState state = SystemKeyspace.getBootstrapState();</span>
<span class="nc" id="L1096">        joinRing(state.equals(SystemKeyspace.BootstrapState.IN_PROGRESS));</span>
<span class="nc" id="L1097">    }</span>

    private synchronized void joinRing(boolean resumedBootstrap) throws IOException
    {
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (!joined)</span>
        {
<span class="nc" id="L1103">            logger.info(&quot;Joining ring by operator request&quot;);</span>
            try
            {
<span class="nc" id="L1106">                joinTokenRing(0);</span>
            }
<span class="nc" id="L1108">            catch (ConfigurationException e)</span>
            {
<span class="nc" id="L1110">                throw new IOException(e.getMessage());</span>
<span class="nc" id="L1111">            }</span>
        }
<span class="nc bnc" id="L1113" title="All 2 branches missed.">        else if (isSurveyMode)</span>
        {
            // if isSurveyMode is on then verify isBootstrapMode
            // node can join the ring even if isBootstrapMode is true which should not happen
<span class="nc bnc" id="L1117" title="All 2 branches missed.">            if (!isBootstrapMode())</span>
            {
<span class="nc" id="L1119">                isSurveyMode = false;</span>
<span class="nc" id="L1120">                logger.info(&quot;Leaving write survey mode and joining ring at operator request&quot;);</span>
<span class="nc" id="L1121">                finishJoiningRing(resumedBootstrap, SystemKeyspace.getSavedTokens());</span>
<span class="nc" id="L1122">                daemon.start();</span>
            }
            else
            {
<span class="nc" id="L1126">                logger.warn(&quot;Can't join the ring because in write_survey mode and bootstrap hasn't completed&quot;);</span>
            }
        }
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        else if (isBootstrapMode())</span>
        {
            // bootstrap is not complete hence node cannot join the ring
<span class="nc" id="L1132">            logger.warn(&quot;Can't join the ring because bootstrap hasn't completed.&quot;);</span>
        }
<span class="nc" id="L1134">    }</span>

    private void executePreJoinTasks(boolean bootstrap)
    {
<span class="fc" id="L1138">        StreamSupport.stream(ColumnFamilyStore.all().spliterator(), false)</span>
<span class="fc" id="L1139">                .filter(cfs -&gt; Schema.instance.getUserKeyspaces().contains(cfs.keyspace.getName()))</span>
<span class="pc" id="L1140">                .forEach(cfs -&gt; cfs.indexManager.executePreJoinTasksBlocking(bootstrap));</span>
<span class="fc" id="L1141">    }</span>

    private void finishJoiningRing(boolean didBootstrap, Collection&lt;Token&gt; tokens)
    {
        // start participating in the ring.
<span class="fc" id="L1146">        setMode(Mode.JOINING, &quot;Finish joining ring&quot;, true);</span>
<span class="fc" id="L1147">        SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.COMPLETED);</span>
<span class="fc" id="L1148">        executePreJoinTasks(didBootstrap);</span>
<span class="fc" id="L1149">        setTokens(tokens);</span>

<span class="pc bpc" id="L1151" title="2 of 4 branches missed.">        assert tokenMetadata.sortedTokens().size() &gt; 0;</span>
<span class="fc" id="L1152">        doAuthSetup(false);</span>
<span class="fc" id="L1153">    }</span>

    private void doAuthSetup(boolean setUpSchema)
    {
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">        if (!authSetupCalled.getAndSet(true))</span>
        {
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">            if (setUpSchema)</span>
<span class="nc" id="L1160">                evolveSystemKeyspace(AuthKeyspace.metadata(), AuthKeyspace.GENERATION).ifPresent(MigrationManager::announceGlobally);</span>

<span class="fc" id="L1162">            DatabaseDescriptor.getRoleManager().setup();</span>
<span class="fc" id="L1163">            DatabaseDescriptor.getAuthenticator().setup();</span>
<span class="fc" id="L1164">            DatabaseDescriptor.getAuthorizer().setup();</span>
<span class="fc" id="L1165">            MigrationManager.instance.register(new AuthMigrationListener());</span>
<span class="fc" id="L1166">            authSetupComplete = true;</span>
        }
<span class="fc" id="L1168">    }</span>

    public boolean isAuthSetupComplete()
    {
<span class="nc" id="L1172">        return authSetupComplete;</span>
    }

    private void setUpDistributedSystemKeyspaces()
    {
<span class="fc" id="L1177">        Collection&lt;Mutation&gt; changes = new ArrayList&lt;&gt;(3);</span>

<span class="fc" id="L1179">        evolveSystemKeyspace(            TraceKeyspace.metadata(),             TraceKeyspace.GENERATION).ifPresent(changes::add);</span>
<span class="fc" id="L1180">        evolveSystemKeyspace(SystemDistributedKeyspace.metadata(), SystemDistributedKeyspace.GENERATION).ifPresent(changes::add);</span>
<span class="fc" id="L1181">        evolveSystemKeyspace(             AuthKeyspace.metadata(),              AuthKeyspace.GENERATION).ifPresent(changes::add);</span>

<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">        if (!changes.isEmpty())</span>
<span class="fc" id="L1184">            MigrationManager.announceGlobally(changes);</span>
<span class="fc" id="L1185">    }</span>

    public boolean isJoined()
    {
<span class="pc bpc" id="L1189" title="2 of 4 branches missed.">        return tokenMetadata.isMember(FBUtilities.getBroadcastAddress()) &amp;&amp; !isSurveyMode;</span>
    }

    public void rebuild(String sourceDc)
    {
<span class="nc" id="L1194">        rebuild(sourceDc, null, null, null);</span>
<span class="nc" id="L1195">    }</span>

    public void rebuild(String sourceDc, String keyspace, String tokens, String specificSources)
    {
        // check ongoing rebuild
<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (!isRebuilding.compareAndSet(false, true))</span>
        {
<span class="nc" id="L1202">            throw new IllegalStateException(&quot;Node is still rebuilding. Check nodetool netstats.&quot;);</span>
        }

        // check the arguments
<span class="nc bnc" id="L1206" title="All 4 branches missed.">        if (keyspace == null &amp;&amp; tokens != null)</span>
        {
<span class="nc" id="L1208">            throw new IllegalArgumentException(&quot;Cannot specify tokens without keyspace.&quot;);</span>
        }

<span class="nc bnc" id="L1211" title="All 6 branches missed.">        logger.info(&quot;rebuild from dc: {}, {}, {}&quot;, sourceDc == null ? &quot;(any dc)&quot; : sourceDc,</span>
                    keyspace == null ? &quot;(All keyspaces)&quot; : keyspace,
                    tokens == null ? &quot;(All tokens)&quot; : tokens);

        try
        {
<span class="nc" id="L1217">            RangeStreamer streamer = new RangeStreamer(tokenMetadata,</span>
                                                       null,
<span class="nc bnc" id="L1219" title="All 4 branches missed.">                                                       FBUtilities.getBroadcastAddress(),</span>
                                                       &quot;Rebuild&quot;,
                                                       useStrictConsistency &amp;&amp; !replacing,
<span class="nc" id="L1222">                                                       DatabaseDescriptor.getEndpointSnitch(),</span>
                                                       streamStateStore,
                                                       false);
<span class="nc" id="L1225">            streamer.addSourceFilter(new RangeStreamer.FailureDetectorSourceFilter(FailureDetector.instance));</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">            if (sourceDc != null)</span>
<span class="nc" id="L1227">                streamer.addSourceFilter(new RangeStreamer.SingleDatacenterFilter(DatabaseDescriptor.getEndpointSnitch(), sourceDc));</span>

<span class="nc bnc" id="L1229" title="All 2 branches missed.">            if (keyspace == null)</span>
            {
<span class="nc bnc" id="L1231" title="All 2 branches missed.">                for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())</span>
<span class="nc" id="L1232">                    streamer.addRanges(keyspaceName, getLocalRanges(keyspaceName));</span>
            }
<span class="nc bnc" id="L1234" title="All 2 branches missed.">            else if (tokens == null)</span>
            {
<span class="nc" id="L1236">                streamer.addRanges(keyspace, getLocalRanges(keyspace));</span>
            }
            else
            {
<span class="nc" id="L1240">                Token.TokenFactory factory = getTokenFactory();</span>
<span class="nc" id="L1241">                List&lt;Range&lt;Token&gt;&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1242">                Pattern rangePattern = Pattern.compile(&quot;\\(\\s*(-?\\w+)\\s*,\\s*(-?\\w+)\\s*\\]&quot;);</span>
<span class="nc" id="L1243">                try (Scanner tokenScanner = new Scanner(tokens))</span>
                {
<span class="nc bnc" id="L1245" title="All 2 branches missed.">                    while (tokenScanner.findInLine(rangePattern) != null)</span>
                    {
<span class="nc" id="L1247">                        MatchResult range = tokenScanner.match();</span>
<span class="nc" id="L1248">                        Token startToken = factory.fromString(range.group(1));</span>
<span class="nc" id="L1249">                        Token endToken = factory.fromString(range.group(2));</span>
<span class="nc" id="L1250">                        logger.info(&quot;adding range: ({},{}]&quot;, startToken, endToken);</span>
<span class="nc" id="L1251">                        ranges.add(new Range&lt;&gt;(startToken, endToken));</span>
<span class="nc" id="L1252">                    }</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">                    if (tokenScanner.hasNext())</span>
<span class="nc" id="L1254">                        throw new IllegalArgumentException(&quot;Unexpected string: &quot; + tokenScanner.next());</span>
                }

                // Ensure all specified ranges are actually ranges owned by this host
<span class="nc" id="L1258">                Collection&lt;Range&lt;Token&gt;&gt; localRanges = getLocalRanges(keyspace);</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                for (Range&lt;Token&gt; specifiedRange : ranges)</span>
                {
<span class="nc" id="L1261">                    boolean foundParentRange = false;</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">                    for (Range&lt;Token&gt; localRange : localRanges)</span>
                    {
<span class="nc bnc" id="L1264" title="All 2 branches missed.">                        if (localRange.contains(specifiedRange))</span>
                        {
<span class="nc" id="L1266">                            foundParentRange = true;</span>
<span class="nc" id="L1267">                            break;</span>
                        }
<span class="nc" id="L1269">                    }</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">                    if (!foundParentRange)</span>
                    {
<span class="nc" id="L1272">                        throw new IllegalArgumentException(String.format(&quot;The specified range %s is not a range that is owned by this node. Please ensure that all token ranges specified to be rebuilt belong to this node.&quot;, specifiedRange.toString()));</span>
                    }
<span class="nc" id="L1274">                }</span>

<span class="nc bnc" id="L1276" title="All 2 branches missed.">                if (specificSources != null)</span>
                {
<span class="nc" id="L1278">                    String[] stringHosts = specificSources.split(&quot;,&quot;);</span>
<span class="nc" id="L1279">                    Set&lt;InetAddress&gt; sources = new HashSet&lt;&gt;(stringHosts.length);</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">                    for (String stringHost : stringHosts)</span>
                    {
                        try
                        {
<span class="nc" id="L1284">                            InetAddress endpoint = InetAddress.getByName(stringHost);</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">                            if (FBUtilities.getBroadcastAddress().equals(endpoint))</span>
                            {
<span class="nc" id="L1287">                                throw new IllegalArgumentException(&quot;This host was specified as a source for rebuilding. Sources for a rebuild can only be other nodes in the cluster.&quot;);</span>
                            }
<span class="nc" id="L1289">                            sources.add(endpoint);</span>
                        }
<span class="nc" id="L1291">                        catch (UnknownHostException ex)</span>
                        {
<span class="nc" id="L1293">                            throw new IllegalArgumentException(&quot;Unknown host specified &quot; + stringHost, ex);</span>
<span class="nc" id="L1294">                        }</span>
                    }
<span class="nc" id="L1296">                    streamer.addSourceFilter(new RangeStreamer.WhitelistedSourcesFilter(sources));</span>
                }

<span class="nc" id="L1299">                streamer.addRanges(keyspace, ranges);</span>
            }

<span class="nc" id="L1302">            StreamResultFuture resultFuture = streamer.fetchAsync();</span>
            // wait for result
<span class="nc" id="L1304">            resultFuture.get();</span>
        }
<span class="nc" id="L1306">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L1308">            throw new RuntimeException(&quot;Interrupted while waiting on rebuild streaming&quot;);</span>
        }
<span class="nc" id="L1310">        catch (ExecutionException e)</span>
        {
            // This is used exclusively through JMX, so log the full trace but only throw a simple RTE
<span class="nc" id="L1313">            logger.error(&quot;Error while rebuilding node&quot;, e.getCause());</span>
<span class="nc" id="L1314">            throw new RuntimeException(&quot;Error while rebuilding node: &quot; + e.getCause().getMessage());</span>
        }
        finally
        {
            // rebuild is done (successfully or not)
<span class="nc" id="L1319">            isRebuilding.set(false);</span>
        }
<span class="nc" id="L1321">    }</span>

    public void setRpcTimeout(long value)
    {
<span class="nc" id="L1325">        DatabaseDescriptor.setRpcTimeout(value);</span>
<span class="nc" id="L1326">        logger.info(&quot;set rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1327">    }</span>

    public long getRpcTimeout()
    {
<span class="nc" id="L1331">        return DatabaseDescriptor.getRpcTimeout();</span>
    }

    public void setReadRpcTimeout(long value)
    {
<span class="nc" id="L1336">        DatabaseDescriptor.setReadRpcTimeout(value);</span>
<span class="nc" id="L1337">        logger.info(&quot;set read rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1338">    }</span>

    public long getReadRpcTimeout()
    {
<span class="nc" id="L1342">        return DatabaseDescriptor.getReadRpcTimeout();</span>
    }

    public void setRangeRpcTimeout(long value)
    {
<span class="nc" id="L1347">        DatabaseDescriptor.setRangeRpcTimeout(value);</span>
<span class="nc" id="L1348">        logger.info(&quot;set range rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1349">    }</span>

    public long getRangeRpcTimeout()
    {
<span class="nc" id="L1353">        return DatabaseDescriptor.getRangeRpcTimeout();</span>
    }

    public void setWriteRpcTimeout(long value)
    {
<span class="nc" id="L1358">        DatabaseDescriptor.setWriteRpcTimeout(value);</span>
<span class="nc" id="L1359">        logger.info(&quot;set write rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1360">    }</span>

    public long getWriteRpcTimeout()
    {
<span class="nc" id="L1364">        return DatabaseDescriptor.getWriteRpcTimeout();</span>
    }

    public void setCounterWriteRpcTimeout(long value)
    {
<span class="nc" id="L1369">        DatabaseDescriptor.setCounterWriteRpcTimeout(value);</span>
<span class="nc" id="L1370">        logger.info(&quot;set counter write rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1371">    }</span>

    public long getCounterWriteRpcTimeout()
    {
<span class="nc" id="L1375">        return DatabaseDescriptor.getCounterWriteRpcTimeout();</span>
    }

    public void setCasContentionTimeout(long value)
    {
<span class="nc" id="L1380">        DatabaseDescriptor.setCasContentionTimeout(value);</span>
<span class="nc" id="L1381">        logger.info(&quot;set cas contention rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1382">    }</span>

    public long getCasContentionTimeout()
    {
<span class="nc" id="L1386">        return DatabaseDescriptor.getCasContentionTimeout();</span>
    }

    public void setTruncateRpcTimeout(long value)
    {
<span class="nc" id="L1391">        DatabaseDescriptor.setTruncateRpcTimeout(value);</span>
<span class="nc" id="L1392">        logger.info(&quot;set truncate rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1393">    }</span>

    public long getTruncateRpcTimeout()
    {
<span class="nc" id="L1397">        return DatabaseDescriptor.getTruncateRpcTimeout();</span>
    }

    public void setStreamingSocketTimeout(int value)
    {
<span class="nc" id="L1402">        DatabaseDescriptor.setStreamingSocketTimeout(value);</span>
<span class="nc" id="L1403">        logger.info(&quot;set streaming socket timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1404">    }</span>

    public int getStreamingSocketTimeout()
    {
<span class="nc" id="L1408">        return DatabaseDescriptor.getStreamingSocketTimeout();</span>
    }

    public void setStreamThroughputMbPerSec(int value)
    {
<span class="nc" id="L1413">        DatabaseDescriptor.setStreamThroughputOutboundMegabitsPerSec(value);</span>
<span class="nc" id="L1414">        logger.info(&quot;setstreamthroughput: throttle set to {}&quot;, value);</span>
<span class="nc" id="L1415">    }</span>

    public int getStreamThroughputMbPerSec()
    {
<span class="nc" id="L1419">        return DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec();</span>
    }

    public void setInterDCStreamThroughputMbPerSec(int value)
    {
<span class="nc" id="L1424">        DatabaseDescriptor.setInterDCStreamThroughputOutboundMegabitsPerSec(value);</span>
<span class="nc" id="L1425">        logger.info(&quot;setinterdcstreamthroughput: throttle set to {}&quot;, value);</span>
<span class="nc" id="L1426">    }</span>

    public int getInterDCStreamThroughputMbPerSec()
    {
<span class="nc" id="L1430">        return DatabaseDescriptor.getInterDCStreamThroughputOutboundMegabitsPerSec();</span>
    }


    public int getCompactionThroughputMbPerSec()
    {
<span class="nc" id="L1436">        return DatabaseDescriptor.getCompactionThroughputMbPerSec();</span>
    }

    public void setCompactionThroughputMbPerSec(int value)
    {
<span class="nc" id="L1441">        DatabaseDescriptor.setCompactionThroughputMbPerSec(value);</span>
<span class="nc" id="L1442">        CompactionManager.instance.setRate(value);</span>
<span class="nc" id="L1443">    }</span>

    public int getConcurrentCompactors()
    {
<span class="nc" id="L1447">        return DatabaseDescriptor.getConcurrentCompactors();</span>
    }

    public void setConcurrentCompactors(int value)
    {
<span class="nc bnc" id="L1452" title="All 2 branches missed.">        if (value &lt;= 0)</span>
<span class="nc" id="L1453">            throw new IllegalArgumentException(&quot;Number of concurrent compactors should be greater than 0.&quot;);</span>
<span class="nc" id="L1454">        DatabaseDescriptor.setConcurrentCompactors(value);</span>
<span class="nc" id="L1455">        CompactionManager.instance.setConcurrentCompactors(value);</span>
<span class="nc" id="L1456">    }</span>

    public boolean isIncrementalBackupsEnabled()
    {
<span class="nc" id="L1460">        return DatabaseDescriptor.isIncrementalBackupsEnabled();</span>
    }

    public void setIncrementalBackupsEnabled(boolean value)
    {
<span class="nc" id="L1465">        DatabaseDescriptor.setIncrementalBackupsEnabled(value);</span>
<span class="nc" id="L1466">    }</span>

    private void setMode(Mode m, boolean log)
    {
<span class="fc" id="L1470">        setMode(m, null, log);</span>
<span class="fc" id="L1471">    }</span>

    private void setMode(Mode m, String msg, boolean log)
    {
<span class="fc" id="L1475">        operationMode = m;</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        String logMsg = msg == null ? m.toString() : String.format(&quot;%s: %s&quot;, m, msg);</span>
<span class="fc bfc" id="L1477" title="All 2 branches covered.">        if (log)</span>
<span class="fc" id="L1478">            logger.info(logMsg);</span>
        else
<span class="fc" id="L1480">            logger.debug(logMsg);</span>
<span class="fc" id="L1481">    }</span>

    /**
     * Bootstrap node by fetching data from other nodes.
     * If node is bootstrapping as a new node, then this also announces bootstrapping to the cluster.
     *
     * This blocks until streaming is done.
     *
     * @param tokens bootstrapping tokens
     * @return true if bootstrap succeeds.
     */
    private boolean bootstrap(final Collection&lt;Token&gt; tokens)
    {
<span class="nc" id="L1494">        isBootstrapMode = true;</span>
<span class="nc" id="L1495">        SystemKeyspace.updateTokens(tokens); // DON'T use setToken, that makes us part of the ring locally which is incorrect until we are done bootstrapping</span>

<span class="nc bnc" id="L1497" title="All 4 branches missed.">        if (!replacing || !isReplacingSameAddress())</span>
        {
            // if not an existing token then bootstrap
<span class="nc" id="L1500">            List&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt; states = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1501">            states.add(Pair.create(ApplicationState.TOKENS, valueFactory.tokens(tokens)));</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">            states.add(Pair.create(ApplicationState.STATUS, replacing?</span>
<span class="nc" id="L1503">                                                            valueFactory.bootReplacing(DatabaseDescriptor.getReplaceAddress()) :</span>
<span class="nc" id="L1504">                                                            valueFactory.bootstrapping(tokens)));</span>
<span class="nc" id="L1505">            Gossiper.instance.addLocalApplicationStates(states);</span>
<span class="nc" id="L1506">            setMode(Mode.JOINING, &quot;sleeping &quot; + RING_DELAY + &quot; ms for pending range setup&quot;, true);</span>
<span class="nc" id="L1507">            Uninterruptibles.sleepUninterruptibly(RING_DELAY, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L1508">        }</span>
        else
        {
            // Dont set any state for the node which is bootstrapping the existing token...
<span class="nc" id="L1512">            tokenMetadata.updateNormalTokens(tokens, FBUtilities.getBroadcastAddress());</span>
<span class="nc" id="L1513">            SystemKeyspace.removeEndpoint(DatabaseDescriptor.getReplaceAddress());</span>
        }
<span class="nc bnc" id="L1515" title="All 2 branches missed.">        if (!Gossiper.instance.seenAnySeed())</span>
<span class="nc" id="L1516">            throw new IllegalStateException(&quot;Unable to contact any seeds!&quot;);</span>

<span class="nc bnc" id="L1518" title="All 2 branches missed.">        if (Boolean.getBoolean(&quot;cassandra.reset_bootstrap_progress&quot;))</span>
        {
<span class="nc" id="L1520">            logger.info(&quot;Resetting bootstrap progress to start fresh&quot;);</span>
<span class="nc" id="L1521">            SystemKeyspace.resetAvailableRanges();</span>
        }

        // Force disk boundary invalidation now that local tokens are set
<span class="nc" id="L1525">        invalidateDiskBoundaries();</span>

<span class="nc" id="L1527">        setMode(Mode.JOINING, &quot;Starting to bootstrap...&quot;, true);</span>
<span class="nc" id="L1528">        BootStrapper bootstrapper = new BootStrapper(FBUtilities.getBroadcastAddress(), tokens, tokenMetadata);</span>
<span class="nc" id="L1529">        bootstrapper.addProgressListener(progressSupport);</span>
<span class="nc bnc" id="L1530" title="All 4 branches missed.">        ListenableFuture&lt;StreamState&gt; bootstrapStream = bootstrapper.bootstrap(streamStateStore, useStrictConsistency &amp;&amp; !replacing); // handles token update</span>
        try
        {
<span class="nc" id="L1533">            bootstrapStream.get();</span>
<span class="nc" id="L1534">            bootstrapFinished();</span>
<span class="nc" id="L1535">            logger.info(&quot;Bootstrap completed for tokens {}&quot;, tokens);</span>
<span class="nc" id="L1536">            return true;</span>
        }
<span class="nc" id="L1538">        catch (Throwable e)</span>
        {
<span class="nc" id="L1540">            logger.error(&quot;Error while waiting on bootstrap to complete. Bootstrap will have to be restarted.&quot;, e);</span>
<span class="nc" id="L1541">            return false;</span>
        }
    }

    private void invalidateDiskBoundaries()
    {
<span class="nc bnc" id="L1547" title="All 2 branches missed.">        for (Keyspace keyspace : Keyspace.all())</span>
        {
<span class="nc bnc" id="L1549" title="All 2 branches missed.">            for (ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())</span>
            {
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                for (final ColumnFamilyStore store : cfs.concatWithIndexes())</span>
                {
<span class="nc" id="L1553">                    store.invalidateDiskBoundaries();</span>
<span class="nc" id="L1554">                }</span>
<span class="nc" id="L1555">            }</span>
<span class="nc" id="L1556">        }</span>
<span class="nc" id="L1557">    }</span>

    /**
     * All MVs have been created during bootstrap, so mark them as built
     */
    private void markViewsAsBuilt() {
<span class="nc bnc" id="L1563" title="All 2 branches missed.">        for (String keyspace : Schema.instance.getUserKeyspaces())</span>
        {
<span class="nc bnc" id="L1565" title="All 2 branches missed.">            for (ViewDefinition view: Schema.instance.getKSMetaData(keyspace).views)</span>
<span class="nc" id="L1566">                SystemKeyspace.finishViewBuildStatus(view.ksName, view.viewName);</span>
<span class="nc" id="L1567">        }</span>
<span class="nc" id="L1568">    }</span>

    /**
     * Called when bootstrap did finish successfully
     */
    private void bootstrapFinished() {
<span class="nc" id="L1574">        markViewsAsBuilt();</span>
<span class="nc" id="L1575">        isBootstrapMode = false;</span>
<span class="nc" id="L1576">    }</span>

    public boolean resumeBootstrap()
    {
<span class="nc bnc" id="L1580" title="All 4 branches missed.">        if (isBootstrapMode &amp;&amp; SystemKeyspace.bootstrapInProgress())</span>
        {
<span class="nc" id="L1582">            logger.info(&quot;Resuming bootstrap...&quot;);</span>

            // get bootstrap tokens saved in system keyspace
<span class="nc" id="L1585">            final Collection&lt;Token&gt; tokens = SystemKeyspace.getSavedTokens();</span>
            // already bootstrapped ranges are filtered during bootstrap
<span class="nc" id="L1587">            BootStrapper bootstrapper = new BootStrapper(FBUtilities.getBroadcastAddress(), tokens, tokenMetadata);</span>
<span class="nc" id="L1588">            bootstrapper.addProgressListener(progressSupport);</span>
<span class="nc bnc" id="L1589" title="All 4 branches missed.">            ListenableFuture&lt;StreamState&gt; bootstrapStream = bootstrapper.bootstrap(streamStateStore, useStrictConsistency &amp;&amp; !replacing); // handles token update</span>
<span class="nc" id="L1590">            Futures.addCallback(bootstrapStream, new FutureCallback&lt;StreamState&gt;()</span>
<span class="nc" id="L1591">            {</span>
                @Override
                public void onSuccess(StreamState streamState)
                {
<span class="nc" id="L1595">                    bootstrapFinished();</span>
                    // start participating in the ring.
                    // pretend we are in survey mode so we can use joinRing() here
<span class="nc bnc" id="L1598" title="All 2 branches missed.">                    if (isSurveyMode)</span>
                    {
<span class="nc" id="L1600">                        logger.info(&quot;Startup complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService-&gt;joinRing()) to finalize ring joining.&quot;);</span>
                    }
                    else
                    {
<span class="nc" id="L1604">                        isSurveyMode = false;</span>
<span class="nc" id="L1605">                        progressSupport.progress(&quot;bootstrap&quot;, ProgressEvent.createNotification(&quot;Joining ring...&quot;));</span>
<span class="nc" id="L1606">                        finishJoiningRing(true, bootstrapTokens);</span>
                    }
<span class="nc" id="L1608">                    progressSupport.progress(&quot;bootstrap&quot;, new ProgressEvent(ProgressEventType.COMPLETE, 1, 1, &quot;Resume bootstrap complete&quot;));</span>
<span class="nc" id="L1609">                    daemon.start();</span>
<span class="nc" id="L1610">                    logger.info(&quot;Resume complete&quot;);</span>
<span class="nc" id="L1611">                }</span>

                @Override
                public void onFailure(Throwable e)
                {
<span class="nc" id="L1616">                    String message = &quot;Error during bootstrap: &quot;;</span>
<span class="nc bnc" id="L1617" title="All 4 branches missed.">                    if (e instanceof ExecutionException &amp;&amp; e.getCause() != null)</span>
                    {
<span class="nc" id="L1619">                        message += e.getCause().getMessage();</span>
                    }
                    else
                    {
<span class="nc" id="L1623">                        message += e.getMessage();</span>
                    }
<span class="nc" id="L1625">                    logger.error(message, e);</span>
<span class="nc" id="L1626">                    progressSupport.progress(&quot;bootstrap&quot;, new ProgressEvent(ProgressEventType.ERROR, 1, 1, message));</span>
<span class="nc" id="L1627">                    progressSupport.progress(&quot;bootstrap&quot;, new ProgressEvent(ProgressEventType.COMPLETE, 1, 1, &quot;Resume bootstrap complete&quot;));</span>
<span class="nc" id="L1628">                }</span>
            });
<span class="nc" id="L1630">            return true;</span>
        }
        else
        {
<span class="nc" id="L1634">            logger.info(&quot;Resuming bootstrap is requested, but the node is already bootstrapped.&quot;);</span>
<span class="nc" id="L1635">            return false;</span>
        }
    }

    public boolean isBootstrapMode()
    {
<span class="fc" id="L1641">        return isBootstrapMode;</span>
    }

    public TokenMetadata getTokenMetadata()
    {
<span class="fc" id="L1646">        return tokenMetadata;</span>
    }

    /**
     * for a keyspace, return the ranges and corresponding listen addresses.
     * @param keyspace
     * @return the endpoint map
     */
    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getRangeToEndpointMap(String keyspace)
    {
        /* All the ranges for the tokens */
<span class="nc" id="L1657">        Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1658" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;,List&lt;InetAddress&gt;&gt; entry : getRangeToAddressMap(keyspace).entrySet())</span>
        {
<span class="nc" id="L1660">            map.put(entry.getKey().asList(), stringify(entry.getValue()));</span>
<span class="nc" id="L1661">        }</span>
<span class="nc" id="L1662">        return map;</span>
    }

    /**
     * Return the rpc address associated with an endpoint as a string.
     * @param endpoint The endpoint to get rpc address for
     * @return the rpc address
     */
    public String getRpcaddress(InetAddress endpoint)
    {
<span class="fc bfc" id="L1672" title="All 2 branches covered.">        if (endpoint.equals(FBUtilities.getBroadcastAddress()))</span>
<span class="fc" id="L1673">            return FBUtilities.getBroadcastRpcAddress().getHostAddress();</span>
<span class="pc bpc" id="L1674" title="1 of 2 branches missed.">        else if (Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.RPC_ADDRESS) == null)</span>
<span class="nc" id="L1675">            return endpoint.getHostAddress();</span>
        else
<span class="fc" id="L1677">            return Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.RPC_ADDRESS).value;</span>
    }

    /**
     * for a keyspace, return the ranges and corresponding RPC addresses for a given keyspace.
     * @param keyspace
     * @return the endpoint map
     */
    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getRangeToRpcaddressMap(String keyspace)
    {
        /* All the ranges for the tokens */
<span class="nc" id="L1688">        Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; entry : getRangeToAddressMap(keyspace).entrySet())</span>
        {
<span class="nc" id="L1691">            List&lt;String&gt; rpcaddrs = new ArrayList&lt;&gt;(entry.getValue().size());</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">            for (InetAddress endpoint: entry.getValue())</span>
            {
<span class="nc" id="L1694">                rpcaddrs.add(getRpcaddress(endpoint));</span>
<span class="nc" id="L1695">            }</span>
<span class="nc" id="L1696">            map.put(entry.getKey().asList(), rpcaddrs);</span>
<span class="nc" id="L1697">        }</span>
<span class="nc" id="L1698">        return map;</span>
    }

    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getPendingRangeToEndpointMap(String keyspace)
    {
        // some people just want to get a visual representation of things. Allow null and set it to the first
        // non-system keyspace.
<span class="nc bnc" id="L1705" title="All 2 branches missed.">        if (keyspace == null)</span>
<span class="nc" id="L1706">            keyspace = Schema.instance.getNonLocalStrategyKeyspaces().get(0);</span>

<span class="nc" id="L1708">        Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;, Collection&lt;InetAddress&gt;&gt; entry : tokenMetadata.getPendingRangesMM(keyspace).asMap().entrySet())</span>
        {
<span class="nc" id="L1711">            List&lt;InetAddress&gt; l = new ArrayList&lt;&gt;(entry.getValue());</span>
<span class="nc" id="L1712">            map.put(entry.getKey().asList(), stringify(l));</span>
<span class="nc" id="L1713">        }</span>
<span class="nc" id="L1714">        return map;</span>
    }

    public Map&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; getRangeToAddressMap(String keyspace)
    {
<span class="nc" id="L1719">        return getRangeToAddressMap(keyspace, tokenMetadata.sortedTokens());</span>
    }

    public Map&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; getRangeToAddressMapInLocalDC(String keyspace)
    {
<span class="nc" id="L1724">        Predicate&lt;InetAddress&gt; isLocalDC = new Predicate&lt;InetAddress&gt;()</span>
<span class="nc" id="L1725">        {</span>
            public boolean apply(InetAddress address)
            {
<span class="nc" id="L1728">                return isLocalDC(address);</span>
            }
        };

<span class="nc" id="L1732">        Map&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; origMap = getRangeToAddressMap(keyspace, getTokensInLocalDC());</span>
<span class="nc" id="L1733">        Map&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; filteredMap = Maps.newHashMap();</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; entry : origMap.entrySet())</span>
        {
<span class="nc" id="L1736">            List&lt;InetAddress&gt; endpointsInLocalDC = Lists.newArrayList(Collections2.filter(entry.getValue(), isLocalDC));</span>
<span class="nc" id="L1737">            filteredMap.put(entry.getKey(), endpointsInLocalDC);</span>
<span class="nc" id="L1738">        }</span>

<span class="nc" id="L1740">        return filteredMap;</span>
    }

    private List&lt;Token&gt; getTokensInLocalDC()
    {
<span class="nc" id="L1745">        List&lt;Token&gt; filteredTokens = Lists.newArrayList();</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">        for (Token token : tokenMetadata.sortedTokens())</span>
        {
<span class="nc" id="L1748">            InetAddress endpoint = tokenMetadata.getEndpoint(token);</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">            if (isLocalDC(endpoint))</span>
<span class="nc" id="L1750">                filteredTokens.add(token);</span>
<span class="nc" id="L1751">        }</span>
<span class="nc" id="L1752">        return filteredTokens;</span>
    }

    private boolean isLocalDC(InetAddress targetHost)
    {
<span class="nc" id="L1757">        String remoteDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(targetHost);</span>
<span class="nc" id="L1758">        String localDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());</span>
<span class="nc" id="L1759">        return remoteDC.equals(localDC);</span>
    }

    private Map&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; getRangeToAddressMap(String keyspace, List&lt;Token&gt; sortedTokens)
    {
        // some people just want to get a visual representation of things. Allow null and set it to the first
        // non-system keyspace.
<span class="nc bnc" id="L1766" title="All 2 branches missed.">        if (keyspace == null)</span>
<span class="nc" id="L1767">            keyspace = Schema.instance.getNonLocalStrategyKeyspaces().get(0);</span>

<span class="nc" id="L1769">        List&lt;Range&lt;Token&gt;&gt; ranges = getAllRanges(sortedTokens);</span>
<span class="nc" id="L1770">        return constructRangeToEndpointMap(keyspace, ranges);</span>
    }


    /**
     * The same as {@code describeRing(String)} but converts TokenRange to the String for JMX compatibility
     *
     * @param keyspace The keyspace to fetch information about
     *
     * @return a List of TokenRange(s) converted to String for the given keyspace
     */
    public List&lt;String&gt; describeRingJMX(String keyspace) throws IOException
    {
        List&lt;TokenRange&gt; tokenRanges;
        try
        {
<span class="nc" id="L1786">            tokenRanges = describeRing(keyspace);</span>
        }
<span class="nc" id="L1788">        catch (InvalidRequestException e)</span>
        {
<span class="nc" id="L1790">            throw new IOException(e.getMessage());</span>
<span class="nc" id="L1791">        }</span>
<span class="nc" id="L1792">        List&lt;String&gt; result = new ArrayList&lt;&gt;(tokenRanges.size());</span>

<span class="nc bnc" id="L1794" title="All 2 branches missed.">        for (TokenRange tokenRange : tokenRanges)</span>
<span class="nc" id="L1795">            result.add(tokenRange.toString());</span>

<span class="nc" id="L1797">        return result;</span>
    }

    /**
     * The TokenRange for a given keyspace.
     *
     * @param keyspace The keyspace to fetch information about
     *
     * @return a List of TokenRange(s) for the given keyspace
     *
     * @throws InvalidRequestException if there is no ring information available about keyspace
     */
    public List&lt;TokenRange&gt; describeRing(String keyspace) throws InvalidRequestException
    {
<span class="nc" id="L1811">        return describeRing(keyspace, false);</span>
    }

    /**
     * The same as {@code describeRing(String)} but considers only the part of the ring formed by nodes in the local DC.
     */
    public List&lt;TokenRange&gt; describeLocalRing(String keyspace) throws InvalidRequestException
    {
<span class="nc" id="L1819">        return describeRing(keyspace, true);</span>
    }

    private List&lt;TokenRange&gt; describeRing(String keyspace, boolean includeOnlyLocalDC) throws InvalidRequestException
    {
<span class="nc bnc" id="L1824" title="All 2 branches missed.">        if (!Schema.instance.getKeyspaces().contains(keyspace))</span>
<span class="nc" id="L1825">            throw new InvalidRequestException(&quot;No such keyspace: &quot; + keyspace);</span>

<span class="nc bnc" id="L1827" title="All 4 branches missed.">        if (keyspace == null || Keyspace.open(keyspace).getReplicationStrategy() instanceof LocalStrategy)</span>
<span class="nc" id="L1828">            throw new InvalidRequestException(&quot;There is no ring for the keyspace: &quot; + keyspace);</span>

<span class="nc" id="L1830">        List&lt;TokenRange&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1831">        Token.TokenFactory tf = getTokenFactory();</span>

<span class="nc bnc" id="L1833" title="All 2 branches missed.">        Map&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; rangeToAddressMap =</span>
                includeOnlyLocalDC
<span class="nc" id="L1835">                        ? getRangeToAddressMapInLocalDC(keyspace)</span>
<span class="nc" id="L1836">                        : getRangeToAddressMap(keyspace);</span>

<span class="nc bnc" id="L1838" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; entry : rangeToAddressMap.entrySet())</span>
        {
<span class="nc" id="L1840">            Range&lt;Token&gt; range = entry.getKey();</span>
<span class="nc" id="L1841">            List&lt;InetAddress&gt; addresses = entry.getValue();</span>
<span class="nc" id="L1842">            List&lt;String&gt; endpoints = new ArrayList&lt;&gt;(addresses.size());</span>
<span class="nc" id="L1843">            List&lt;String&gt; rpc_endpoints = new ArrayList&lt;&gt;(addresses.size());</span>
<span class="nc" id="L1844">            List&lt;EndpointDetails&gt; epDetails = new ArrayList&lt;&gt;(addresses.size());</span>

<span class="nc bnc" id="L1846" title="All 2 branches missed.">            for (InetAddress endpoint : addresses)</span>
            {
<span class="nc" id="L1848">                EndpointDetails details = new EndpointDetails();</span>
<span class="nc" id="L1849">                details.host = endpoint.getHostAddress();</span>
<span class="nc" id="L1850">                details.datacenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);</span>
<span class="nc" id="L1851">                details.rack = DatabaseDescriptor.getEndpointSnitch().getRack(endpoint);</span>

<span class="nc" id="L1853">                endpoints.add(details.host);</span>
<span class="nc" id="L1854">                rpc_endpoints.add(getRpcaddress(endpoint));</span>

<span class="nc" id="L1856">                epDetails.add(details);</span>
<span class="nc" id="L1857">            }</span>

<span class="nc" id="L1859">            TokenRange tr = new TokenRange(tf.toString(range.left.getToken()), tf.toString(range.right.getToken()), endpoints)</span>
<span class="nc" id="L1860">                                    .setEndpoint_details(epDetails)</span>
<span class="nc" id="L1861">                                    .setRpc_endpoints(rpc_endpoints);</span>

<span class="nc" id="L1863">            ranges.add(tr);</span>
<span class="nc" id="L1864">        }</span>

<span class="nc" id="L1866">        return ranges;</span>
    }

    public Map&lt;String, String&gt; getTokenToEndpointMap()
    {
<span class="nc" id="L1871">        Map&lt;Token, InetAddress&gt; mapInetAddress = tokenMetadata.getNormalAndBootstrappingTokenToEndpointMap();</span>
        // in order to preserve tokens in ascending order, we use LinkedHashMap here
<span class="nc" id="L1873">        Map&lt;String, String&gt; mapString = new LinkedHashMap&lt;&gt;(mapInetAddress.size());</span>
<span class="nc" id="L1874">        List&lt;Token&gt; tokens = new ArrayList&lt;&gt;(mapInetAddress.keySet());</span>
<span class="nc" id="L1875">        Collections.sort(tokens);</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">        for (Token token : tokens)</span>
        {
<span class="nc" id="L1878">            mapString.put(token.toString(), mapInetAddress.get(token).getHostAddress());</span>
<span class="nc" id="L1879">        }</span>
<span class="nc" id="L1880">        return mapString;</span>
    }

    public String getLocalHostId()
    {
<span class="nc" id="L1885">        return getTokenMetadata().getHostId(FBUtilities.getBroadcastAddress()).toString();</span>
    }

    public UUID getLocalHostUUID()
    {
<span class="nc" id="L1890">        return getTokenMetadata().getHostId(FBUtilities.getBroadcastAddress());</span>
    }

    public Map&lt;String, String&gt; getHostIdMap()
    {
<span class="nc" id="L1895">        return getEndpointToHostId();</span>
    }

    public Map&lt;String, String&gt; getEndpointToHostId()
    {
<span class="nc" id="L1900">        Map&lt;String, String&gt; mapOut = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddress, UUID&gt; entry : getTokenMetadata().getEndpointToHostIdMapForReading().entrySet())</span>
<span class="nc" id="L1902">            mapOut.put(entry.getKey().getHostAddress(), entry.getValue().toString());</span>
<span class="nc" id="L1903">        return mapOut;</span>
    }

    public Map&lt;String, String&gt; getHostIdToEndpoint()
    {
<span class="nc" id="L1908">        Map&lt;String, String&gt; mapOut = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddress, UUID&gt; entry : getTokenMetadata().getEndpointToHostIdMapForReading().entrySet())</span>
<span class="nc" id="L1910">            mapOut.put(entry.getValue().toString(), entry.getKey().getHostAddress());</span>
<span class="nc" id="L1911">        return mapOut;</span>
    }

    /**
     * Construct the range to endpoint mapping based on the true view
     * of the world.
     * @param ranges
     * @return mapping of ranges to the replicas responsible for them.
    */
    private Map&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; constructRangeToEndpointMap(String keyspace, List&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="nc" id="L1922">        Map&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; rangeToEndpointMap = new HashMap&lt;&gt;(ranges.size());</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">        for (Range&lt;Token&gt; range : ranges)</span>
        {
<span class="nc" id="L1925">            rangeToEndpointMap.put(range, Keyspace.open(keyspace).getReplicationStrategy().getNaturalEndpoints(range.right));</span>
<span class="nc" id="L1926">        }</span>
<span class="nc" id="L1927">        return rangeToEndpointMap;</span>
    }

    public void beforeChange(InetAddress endpoint, EndpointState currentState, ApplicationState newStateKey, VersionedValue newValue)
    {
        // no-op
<span class="fc" id="L1933">    }</span>

    /*
     * Handle the reception of a new particular ApplicationState for a particular endpoint. Note that the value of the
     * ApplicationState has not necessarily &quot;changed&quot; since the last known value, if we already received the same update
     * from somewhere else.
     *
     * onChange only ever sees one ApplicationState piece change at a time (even if many ApplicationState updates were
     * received at the same time), so we perform a kind of state machine here. We are concerned with two events: knowing
     * the token associated with an endpoint, and knowing its operation mode. Nodes can start in either bootstrap or
     * normal mode, and from bootstrap mode can change mode to normal. A node in bootstrap mode needs to have
     * pendingranges set in TokenMetadata; a node in normal mode should instead be part of the token ring.
     *
     * Normal progression of ApplicationState.STATUS values for a node should be like this:
     * STATUS_BOOTSTRAPPING,token
     *   if bootstrapping. stays this way until all files are received.
     * STATUS_NORMAL,token
     *   ready to serve reads and writes.
     * STATUS_LEAVING,token
     *   get ready to leave the cluster as part of a decommission
     * STATUS_LEFT,token
     *   set after decommission is completed.
     *
     * Other STATUS values that may be seen (possibly anywhere in the normal progression):
     * STATUS_MOVING,newtoken
     *   set if node is currently moving to a new token in the ring
     * REMOVING_TOKEN,deadtoken
     *   set if the node is dead and is being removed by its REMOVAL_COORDINATOR
     * REMOVED_TOKEN,deadtoken
     *   set if the node is dead and has been removed by its REMOVAL_COORDINATOR
     *
     * Note: Any time a node state changes from STATUS_NORMAL, it will not be visible to new nodes. So it follows that
     * you should never bootstrap a new node during a removenode, decommission or move.
     */
    public void onChange(InetAddress endpoint, ApplicationState state, VersionedValue value)
    {
<span class="fc bfc" id="L1969" title="All 2 branches covered.">        if (state == ApplicationState.STATUS)</span>
        {
<span class="fc" id="L1971">            String[] pieces = splitValue(value);</span>
<span class="pc bpc" id="L1972" title="2 of 4 branches missed.">            assert (pieces.length &gt; 0);</span>

<span class="fc" id="L1974">            String moveName = pieces[0];</span>

<span class="pc bpc" id="L1976" title="7 of 9 branches missed.">            switch (moveName)</span>
            {
                case VersionedValue.STATUS_BOOTSTRAPPING_REPLACE:
<span class="nc" id="L1979">                    handleStateBootreplacing(endpoint, pieces);</span>
<span class="nc" id="L1980">                    break;</span>
                case VersionedValue.STATUS_BOOTSTRAPPING:
<span class="nc" id="L1982">                    handleStateBootstrap(endpoint);</span>
<span class="nc" id="L1983">                    break;</span>
                case VersionedValue.STATUS_NORMAL:
<span class="fc" id="L1985">                    handleStateNormal(endpoint, VersionedValue.STATUS_NORMAL);</span>
<span class="fc" id="L1986">                    break;</span>
                case VersionedValue.SHUTDOWN:
<span class="fc" id="L1988">                    handleStateNormal(endpoint, VersionedValue.SHUTDOWN);</span>
<span class="fc" id="L1989">                    break;</span>
                case VersionedValue.REMOVING_TOKEN:
                case VersionedValue.REMOVED_TOKEN:
<span class="nc" id="L1992">                    handleStateRemoving(endpoint, pieces);</span>
<span class="nc" id="L1993">                    break;</span>
                case VersionedValue.STATUS_LEAVING:
<span class="nc" id="L1995">                    handleStateLeaving(endpoint);</span>
<span class="nc" id="L1996">                    break;</span>
                case VersionedValue.STATUS_LEFT:
<span class="nc" id="L1998">                    handleStateLeft(endpoint, pieces);</span>
<span class="nc" id="L1999">                    break;</span>
                case VersionedValue.STATUS_MOVING:
<span class="nc" id="L2001">                    handleStateMoving(endpoint, pieces);</span>
                    break;
            }
<span class="fc" id="L2004">        }</span>
        else
        {
<span class="fc" id="L2007">            EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="pc bpc" id="L2008" title="2 of 4 branches missed.">            if (epState == null || Gossiper.instance.isDeadState(epState))</span>
            {
<span class="nc" id="L2010">                logger.debug(&quot;Ignoring state change for dead or unknown endpoint: {}&quot;, endpoint);</span>
<span class="nc" id="L2011">                return;</span>
            }

<span class="fc bfc" id="L2014" title="All 2 branches covered.">            if (getTokenMetadata().isMember(endpoint))</span>
            {
<span class="fc" id="L2016">                final ExecutorService executor = StageManager.getStage(Stage.MUTATION);</span>
<span class="fc bfc" id="L2017" title="All 9 branches covered.">                switch (state)</span>
                {
                    case RELEASE_VERSION:
<span class="fc" id="L2020">                        SystemKeyspace.updatePeerReleaseVersion(endpoint, value.value, this::refreshMaxNativeProtocolVersion, executor);</span>
<span class="fc" id="L2021">                        break;</span>
                    case DC:
<span class="fc" id="L2023">                        updateTopology(endpoint);</span>
<span class="fc" id="L2024">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;data_center&quot;, value.value, executor);</span>
<span class="fc" id="L2025">                        break;</span>
                    case RACK:
<span class="fc" id="L2027">                        updateTopology(endpoint);</span>
<span class="fc" id="L2028">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;rack&quot;, value.value, executor);</span>
<span class="fc" id="L2029">                        break;</span>
                    case RPC_ADDRESS:
                        try
                        {
<span class="fc" id="L2033">                            SystemKeyspace.updatePeerInfo(endpoint, &quot;rpc_address&quot;, InetAddress.getByName(value.value), executor);</span>
                        }
<span class="nc" id="L2035">                        catch (UnknownHostException e)</span>
                        {
<span class="nc" id="L2037">                            throw new RuntimeException(e);</span>
<span class="fc" id="L2038">                        }</span>
                        break;
                    case SCHEMA:
<span class="fc" id="L2041">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;schema_version&quot;, UUID.fromString(value.value), executor);</span>
<span class="fc" id="L2042">                        MigrationManager.instance.scheduleSchemaPull(endpoint, epState);</span>
<span class="fc" id="L2043">                        break;</span>
                    case HOST_ID:
<span class="fc" id="L2045">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;host_id&quot;, UUID.fromString(value.value), executor);</span>
<span class="fc" id="L2046">                        break;</span>
                    case RPC_READY:
<span class="fc" id="L2048">                        notifyRpcChange(endpoint, epState.isRpcReady());</span>
<span class="fc" id="L2049">                        break;</span>
                    case NET_VERSION:
<span class="fc" id="L2051">                        updateNetVersion(endpoint, value);</span>
                        break;
                }
            }
        }
<span class="fc" id="L2056">    }</span>

    private static String[] splitValue(VersionedValue value)
    {
<span class="fc" id="L2060">        return value.value.split(VersionedValue.DELIMITER_STR, -1);</span>
    }

    private void updateNetVersion(InetAddress endpoint, VersionedValue value)
    {
        try
        {
<span class="fc" id="L2067">            MessagingService.instance().setVersion(endpoint, Integer.parseInt(value.value));</span>
        }
<span class="nc" id="L2069">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L2071">            throw new AssertionError(&quot;Got invalid value for NET_VERSION application state: &quot; + value.value);</span>
<span class="fc" id="L2072">        }</span>
<span class="fc" id="L2073">    }</span>

    public void updateTopology(InetAddress endpoint)
    {
<span class="pc bpc" id="L2077" title="1 of 2 branches missed.">        if (getTokenMetadata().isMember(endpoint))</span>
        {
<span class="fc" id="L2079">            getTokenMetadata().updateTopology(endpoint);</span>
        }
<span class="fc" id="L2081">    }</span>

    public void updateTopology()
    {
<span class="nc" id="L2085">        getTokenMetadata().updateTopology();</span>
<span class="nc" id="L2086">    }</span>

    private void updatePeerInfo(InetAddress endpoint)
    {
<span class="fc" id="L2090">        EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="fc" id="L2091">        final ExecutorService executor = StageManager.getStage(Stage.MUTATION);</span>
<span class="fc bfc" id="L2092" title="All 2 branches covered.">        for (Map.Entry&lt;ApplicationState, VersionedValue&gt; entry : epState.states())</span>
        {
<span class="fc bfc" id="L2094" title="All 7 branches covered.">            switch (entry.getKey())</span>
            {
                case RELEASE_VERSION:
<span class="fc" id="L2097">                    SystemKeyspace.updatePeerReleaseVersion(endpoint, entry.getValue().value, this::refreshMaxNativeProtocolVersion, executor);</span>
<span class="fc" id="L2098">                    break;</span>
                case DC:
<span class="fc" id="L2100">                    SystemKeyspace.updatePeerInfo(endpoint, &quot;data_center&quot;, entry.getValue().value, executor);</span>
<span class="fc" id="L2101">                    break;</span>
                case RACK:
<span class="fc" id="L2103">                    SystemKeyspace.updatePeerInfo(endpoint, &quot;rack&quot;, entry.getValue().value, executor);</span>
<span class="fc" id="L2104">                    break;</span>
                case RPC_ADDRESS:
                    try
                    {
<span class="fc" id="L2108">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;rpc_address&quot;, InetAddress.getByName(entry.getValue().value), executor);</span>
                    }
<span class="nc" id="L2110">                    catch (UnknownHostException e)</span>
                    {
<span class="nc" id="L2112">                        throw new RuntimeException(e);</span>
<span class="fc" id="L2113">                    }</span>
                    break;
                case SCHEMA:
<span class="fc" id="L2116">                    SystemKeyspace.updatePeerInfo(endpoint, &quot;schema_version&quot;, UUID.fromString(entry.getValue().value), executor);</span>
<span class="fc" id="L2117">                    break;</span>
                case HOST_ID:
<span class="fc" id="L2119">                    SystemKeyspace.updatePeerInfo(endpoint, &quot;host_id&quot;, UUID.fromString(entry.getValue().value), executor);</span>
                    break;
            }
<span class="fc" id="L2122">        }</span>
<span class="fc" id="L2123">    }</span>

    private void notifyRpcChange(InetAddress endpoint, boolean ready)
    {
<span class="fc bfc" id="L2127" title="All 2 branches covered.">        if (ready)</span>
<span class="fc" id="L2128">            notifyUp(endpoint);</span>
        else
<span class="fc" id="L2130">            notifyDown(endpoint);</span>
<span class="fc" id="L2131">    }</span>

    private void notifyUp(InetAddress endpoint)
    {
<span class="fc bfc" id="L2135" title="All 4 branches covered.">        if (!isRpcReady(endpoint) || !Gossiper.instance.isAlive(endpoint))</span>
<span class="fc" id="L2136">            return;</span>

<span class="fc bfc" id="L2138" title="All 2 branches covered.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="fc" id="L2139">            subscriber.onUp(endpoint);</span>
<span class="fc" id="L2140">    }</span>

    private void notifyDown(InetAddress endpoint)
    {
<span class="fc bfc" id="L2144" title="All 2 branches covered.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="fc" id="L2145">            subscriber.onDown(endpoint);</span>
<span class="fc" id="L2146">    }</span>

    private void notifyJoined(InetAddress endpoint)
    {
<span class="pc bpc" id="L2150" title="1 of 2 branches missed.">        if (!isStatus(endpoint, VersionedValue.STATUS_NORMAL))</span>
<span class="nc" id="L2151">            return;</span>

<span class="fc bfc" id="L2153" title="All 2 branches covered.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="fc" id="L2154">            subscriber.onJoinCluster(endpoint);</span>
<span class="fc" id="L2155">    }</span>

    private void notifyMoved(InetAddress endpoint)
    {
<span class="nc bnc" id="L2159" title="All 2 branches missed.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="nc" id="L2160">            subscriber.onMove(endpoint);</span>
<span class="nc" id="L2161">    }</span>

    private void notifyLeft(InetAddress endpoint)
    {
<span class="nc bnc" id="L2165" title="All 2 branches missed.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="nc" id="L2166">            subscriber.onLeaveCluster(endpoint);</span>
<span class="nc" id="L2167">    }</span>

    private boolean isStatus(InetAddress endpoint, String status)
    {
<span class="fc" id="L2171">        EndpointState state = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="pc bpc" id="L2172" title="2 of 4 branches missed.">        return state != null &amp;&amp; state.getStatus().equals(status);</span>
    }

    public boolean isRpcReady(InetAddress endpoint)
    {
<span class="pc bpc" id="L2177" title="1 of 2 branches missed.">        if (MessagingService.instance().getVersion(endpoint) &lt; MessagingService.VERSION_22)</span>
<span class="nc" id="L2178">            return true;</span>
<span class="fc" id="L2179">        EndpointState state = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="pc bpc" id="L2180" title="1 of 4 branches missed.">        return state != null &amp;&amp; state.isRpcReady();</span>
    }

    /**
     * Set the RPC status. Because when draining a node we need to set the RPC
     * status to not ready, and drain is called by the shutdown hook, it may be that value is false
     * and there is no local endpoint state. In this case it's OK to just do nothing. Therefore,
     * we assert that the local endpoint state is not null only when value is true.
     *
     * @param value - true indicates that RPC is ready, false indicates the opposite.
     */
    public void setRpcReady(boolean value)
    {
<span class="fc" id="L2193">        EndpointState state = Gossiper.instance.getEndpointStateForEndpoint(FBUtilities.getBroadcastAddress());</span>
        // if value is false we're OK with a null state, if it is true we are not.
<span class="pc bpc" id="L2195" title="2 of 6 branches missed.">        assert !value || state != null;</span>

<span class="pc bpc" id="L2197" title="1 of 2 branches missed.">        if (state != null)</span>
<span class="fc" id="L2198">            Gossiper.instance.addLocalApplicationState(ApplicationState.RPC_READY, valueFactory.rpcReady(value));</span>
<span class="fc" id="L2199">    }</span>

    private Collection&lt;Token&gt; getTokensFor(InetAddress endpoint)
    {
        try
        {
<span class="fc" id="L2205">            EndpointState state = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">            if (state == null)</span>
<span class="nc" id="L2207">                return Collections.emptyList();</span>

<span class="fc" id="L2209">            VersionedValue versionedValue = state.getApplicationState(ApplicationState.TOKENS);</span>
<span class="pc bpc" id="L2210" title="1 of 2 branches missed.">            if (versionedValue == null)</span>
<span class="nc" id="L2211">                return Collections.emptyList();</span>

<span class="fc" id="L2213">            return TokenSerializer.deserialize(tokenMetadata.partitioner, new DataInputStream(new ByteArrayInputStream(versionedValue.toBytes())));</span>
        }
<span class="nc" id="L2215">        catch (IOException e)</span>
        {
<span class="nc" id="L2217">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Handle node bootstrap
     *
     * @param endpoint bootstrapping node
     */
    private void handleStateBootstrap(InetAddress endpoint)
    {
        Collection&lt;Token&gt; tokens;
        // explicitly check for TOKENS, because a bootstrapping node might be bootstrapping in legacy mode; that is, not using vnodes and no token specified
<span class="nc" id="L2230">        tokens = getTokensFor(endpoint);</span>

<span class="nc bnc" id="L2232" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L2233">            logger.debug(&quot;Node {} state bootstrapping, token {}&quot;, endpoint, tokens);</span>

        // if this node is present in token metadata, either we have missed intermediate states
        // or the node had crashed. Print warning if needed, clear obsolete stuff and
        // continue.
<span class="nc bnc" id="L2238" title="All 2 branches missed.">        if (tokenMetadata.isMember(endpoint))</span>
        {
            // If isLeaving is false, we have missed both LEAVING and LEFT. However, if
            // isLeaving is true, we have only missed LEFT. Waiting time between completing
            // leave operation and rebootstrapping is relatively short, so the latter is quite
            // common (not enough time for gossip to spread). Therefore we report only the
            // former in the log.
<span class="nc bnc" id="L2245" title="All 2 branches missed.">            if (!tokenMetadata.isLeaving(endpoint))</span>
<span class="nc" id="L2246">                logger.info(&quot;Node {} state jump to bootstrap&quot;, endpoint);</span>
<span class="nc" id="L2247">            tokenMetadata.removeEndpoint(endpoint);</span>
        }

<span class="nc" id="L2250">        tokenMetadata.addBootstrapTokens(tokens, endpoint);</span>
<span class="nc" id="L2251">        PendingRangeCalculatorService.instance.update();</span>

<span class="nc" id="L2253">        tokenMetadata.updateHostId(Gossiper.instance.getHostId(endpoint), endpoint);</span>
<span class="nc" id="L2254">    }</span>

    private void handleStateBootreplacing(InetAddress newNode, String[] pieces)
    {
        InetAddress oldNode;
        try
        {
<span class="nc" id="L2261">            oldNode = InetAddress.getByName(pieces[1]);</span>
        }
<span class="nc" id="L2263">        catch (Exception e)</span>
        {
<span class="nc" id="L2265">            logger.error(&quot;Node {} tried to replace malformed endpoint {}.&quot;, newNode, pieces[1], e);</span>
<span class="nc" id="L2266">            return;</span>
<span class="nc" id="L2267">        }</span>

<span class="nc bnc" id="L2269" title="All 2 branches missed.">        if (FailureDetector.instance.isAlive(oldNode))</span>
        {
<span class="nc" id="L2271">            throw new RuntimeException(String.format(&quot;Node %s is trying to replace alive node %s.&quot;, newNode, oldNode));</span>
        }

<span class="nc" id="L2274">        Optional&lt;InetAddress&gt; replacingNode = tokenMetadata.getReplacingNode(newNode);</span>
<span class="nc bnc" id="L2275" title="All 4 branches missed.">        if (replacingNode.isPresent() &amp;&amp; !replacingNode.get().equals(oldNode))</span>
        {
<span class="nc" id="L2277">            throw new RuntimeException(String.format(&quot;Node %s is already replacing %s but is trying to replace %s.&quot;,</span>
<span class="nc" id="L2278">                                                     newNode, replacingNode.get(), oldNode));</span>
        }

<span class="nc" id="L2281">        Collection&lt;Token&gt; tokens = getTokensFor(newNode);</span>

<span class="nc bnc" id="L2283" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L2284">            logger.debug(&quot;Node {} is replacing {}, tokens {}&quot;, newNode, oldNode, tokens);</span>

<span class="nc" id="L2286">        tokenMetadata.addReplaceTokens(tokens, newNode, oldNode);</span>
<span class="nc" id="L2287">        PendingRangeCalculatorService.instance.update();</span>

<span class="nc" id="L2289">        tokenMetadata.updateHostId(Gossiper.instance.getHostId(newNode), newNode);</span>
<span class="nc" id="L2290">    }</span>

    private void ensureUpToDateTokenMetadata(String status, InetAddress endpoint)
    {
<span class="nc" id="L2294">        Set&lt;Token&gt; tokens = new TreeSet&lt;&gt;(getTokensFor(endpoint));</span>

<span class="nc bnc" id="L2296" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L2297">            logger.debug(&quot;Node {} state {}, tokens {}&quot;, endpoint, status, tokens);</span>

        // If the node is previously unknown or tokens do not match, update tokenmetadata to
        // have this node as 'normal' (it must have been using this token before the
        // leave). This way we'll get pending ranges right.
<span class="nc bnc" id="L2302" title="All 2 branches missed.">        if (!tokenMetadata.isMember(endpoint))</span>
        {
<span class="nc" id="L2304">            logger.info(&quot;Node {} state jump to {}&quot;, endpoint, status);</span>
<span class="nc" id="L2305">            updateTokenMetadata(endpoint, tokens);</span>
        }
<span class="nc bnc" id="L2307" title="All 2 branches missed.">        else if (!tokens.equals(new TreeSet&lt;&gt;(tokenMetadata.getTokens(endpoint))))</span>
        {
<span class="nc" id="L2309">            logger.warn(&quot;Node {} '{}' token mismatch. Long network partition?&quot;, endpoint, status);</span>
<span class="nc" id="L2310">            updateTokenMetadata(endpoint, tokens);</span>
        }
<span class="nc" id="L2312">    }</span>

    private void updateTokenMetadata(InetAddress endpoint, Iterable&lt;Token&gt; tokens)
    {
<span class="nc" id="L2316">        updateTokenMetadata(endpoint, tokens, new HashSet&lt;&gt;());</span>
<span class="nc" id="L2317">    }</span>

    private void updateTokenMetadata(InetAddress endpoint, Iterable&lt;Token&gt; tokens, Set&lt;InetAddress&gt; endpointsToRemove)
    {
<span class="fc" id="L2321">        Set&lt;Token&gt; tokensToUpdateInMetadata = new HashSet&lt;&gt;();</span>
<span class="fc" id="L2322">        Set&lt;Token&gt; tokensToUpdateInSystemKeyspace = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L2324" title="All 2 branches covered.">        for (final Token token : tokens)</span>
        {
            // we don't want to update if this node is responsible for the token and it has a later startup time than endpoint.
<span class="fc" id="L2327">            InetAddress currentOwner = tokenMetadata.getEndpoint(token);</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">            if (currentOwner == null)</span>
            {
<span class="fc" id="L2330">                logger.debug(&quot;New node {} at token {}&quot;, endpoint, token);</span>
<span class="fc" id="L2331">                tokensToUpdateInMetadata.add(token);</span>
<span class="fc" id="L2332">                tokensToUpdateInSystemKeyspace.add(token);</span>
            }
<span class="pc bpc" id="L2334" title="1 of 2 branches missed.">            else if (endpoint.equals(currentOwner))</span>
            {
                // set state back to normal, since the node may have tried to leave, but failed and is now back up
<span class="fc" id="L2337">                tokensToUpdateInMetadata.add(token);</span>
<span class="fc" id="L2338">                tokensToUpdateInSystemKeyspace.add(token);</span>
            }
<span class="nc bnc" id="L2340" title="All 2 branches missed.">            else if (Gossiper.instance.compareEndpointStartup(endpoint, currentOwner) &gt; 0)</span>
            {
<span class="nc" id="L2342">                tokensToUpdateInMetadata.add(token);</span>
<span class="nc" id="L2343">                tokensToUpdateInSystemKeyspace.add(token);</span>

                // currentOwner is no longer current, endpoint is.  Keep track of these moves, because when
                // a host no longer has any tokens, we'll want to remove it.
<span class="nc" id="L2347">                Multimap&lt;InetAddress, Token&gt; epToTokenCopy = getTokenMetadata().getEndpointToTokenMapForReading();</span>
<span class="nc" id="L2348">                epToTokenCopy.get(currentOwner).remove(token);</span>
<span class="nc bnc" id="L2349" title="All 2 branches missed.">                if (epToTokenCopy.get(currentOwner).isEmpty())</span>
<span class="nc" id="L2350">                    endpointsToRemove.add(currentOwner);</span>

<span class="nc" id="L2352">                logger.info(&quot;Nodes {} and {} have the same token {}. {} is the new owner&quot;, endpoint, currentOwner, token, endpoint);</span>
<span class="nc" id="L2353">            }</span>
            else
            {
<span class="nc" id="L2356">                logger.info(&quot;Nodes () and {} have the same token {}.  Ignoring {}&quot;, endpoint, currentOwner, token, endpoint);</span>
            }
<span class="fc" id="L2358">        }</span>

<span class="fc" id="L2360">        tokenMetadata.updateNormalTokens(tokensToUpdateInMetadata, endpoint);</span>
<span class="pc bpc" id="L2361" title="1 of 2 branches missed.">        for (InetAddress ep : endpointsToRemove)</span>
        {
<span class="nc" id="L2363">            removeEndpoint(ep);</span>
<span class="nc bnc" id="L2364" title="All 4 branches missed.">            if (replacing &amp;&amp; ep.equals(DatabaseDescriptor.getReplaceAddress()))</span>
<span class="nc" id="L2365">                Gossiper.instance.replacementQuarantine(ep); // quarantine locally longer than normally; see CASSANDRA-8260</span>
<span class="nc" id="L2366">        }</span>
<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">        if (!tokensToUpdateInSystemKeyspace.isEmpty())</span>
<span class="fc" id="L2368">            SystemKeyspace.updateTokens(endpoint, tokensToUpdateInSystemKeyspace, StageManager.getStage(Stage.MUTATION));</span>
<span class="fc" id="L2369">    }</span>

    /**
     * Handle node move to normal state. That is, node is entering token ring and participating
     * in reads.
     *
     * @param endpoint node
     */
    private void handleStateNormal(final InetAddress endpoint, final String status)
    {
<span class="fc" id="L2379">        Collection&lt;Token&gt; tokens = getTokensFor(endpoint);</span>
<span class="fc" id="L2380">        Set&lt;InetAddress&gt; endpointsToRemove = new HashSet&lt;&gt;();</span>

<span class="pc bpc" id="L2382" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L2383">            logger.debug(&quot;Node {} state {}, token {}&quot;, endpoint, status, tokens);</span>

<span class="fc bfc" id="L2385" title="All 2 branches covered.">        if (tokenMetadata.isMember(endpoint))</span>
<span class="fc" id="L2386">            logger.info(&quot;Node {} state jump to {}&quot;, endpoint, status);</span>

<span class="pc bpc" id="L2388" title="3 of 4 branches missed.">        if (tokens.isEmpty() &amp;&amp; status.equals(VersionedValue.STATUS_NORMAL))</span>
<span class="nc" id="L2389">            logger.error(&quot;Node {} is in state normal but it has no tokens, state: {}&quot;,</span>
                         endpoint,
<span class="nc" id="L2391">                         Gossiper.instance.getEndpointStateForEndpoint(endpoint));</span>

<span class="fc" id="L2393">        Optional&lt;InetAddress&gt; replacingNode = tokenMetadata.getReplacingNode(endpoint);</span>
<span class="pc bpc" id="L2394" title="1 of 2 branches missed.">        if (replacingNode.isPresent())</span>
        {
<span class="nc bnc" id="L2396" title="All 4 branches missed.">            assert !endpoint.equals(replacingNode.get()) : &quot;Pending replacement endpoint with same address is not supported&quot;;</span>
<span class="nc" id="L2397">            logger.info(&quot;Node {} will complete replacement of {} for tokens {}&quot;, endpoint, replacingNode.get(), tokens);</span>
<span class="nc bnc" id="L2398" title="All 2 branches missed.">            if (FailureDetector.instance.isAlive(replacingNode.get()))</span>
            {
<span class="nc" id="L2400">                logger.error(&quot;Node {} cannot complete replacement of alive node {}.&quot;, endpoint, replacingNode.get());</span>
<span class="nc" id="L2401">                return;</span>
            }
<span class="nc" id="L2403">            endpointsToRemove.add(replacingNode.get());</span>
        }

<span class="fc" id="L2406">        Optional&lt;InetAddress&gt; replacementNode = tokenMetadata.getReplacementNode(endpoint);</span>
<span class="pc bpc" id="L2407" title="1 of 2 branches missed.">        if (replacementNode.isPresent())</span>
        {
<span class="nc" id="L2409">            logger.warn(&quot;Node {} is currently being replaced by node {}.&quot;, endpoint, replacementNode.get());</span>
        }

<span class="fc" id="L2412">        updatePeerInfo(endpoint);</span>
        // Order Matters, TM.updateHostID() should be called before TM.updateNormalToken(), (see CASSANDRA-4300).
<span class="fc" id="L2414">        UUID hostId = Gossiper.instance.getHostId(endpoint);</span>
<span class="fc" id="L2415">        InetAddress existing = tokenMetadata.getEndpointForHostId(hostId);</span>
<span class="pc bpc" id="L2416" title="5 of 6 branches missed.">        if (replacing &amp;&amp; isReplacingSameAddress() &amp;&amp; Gossiper.instance.getEndpointStateForEndpoint(DatabaseDescriptor.getReplaceAddress()) != null</span>
<span class="nc bnc" id="L2417" title="All 2 branches missed.">            &amp;&amp; (hostId.equals(Gossiper.instance.getHostId(DatabaseDescriptor.getReplaceAddress()))))</span>
<span class="nc" id="L2418">            logger.warn(&quot;Not updating token metadata for {} because I am replacing it&quot;, endpoint);</span>
        else
        {
<span class="pc bpc" id="L2421" title="1 of 4 branches missed.">            if (existing != null &amp;&amp; !existing.equals(endpoint))</span>
            {
<span class="nc bnc" id="L2423" title="All 2 branches missed.">                if (existing.equals(FBUtilities.getBroadcastAddress()))</span>
                {
<span class="nc" id="L2425">                    logger.warn(&quot;Not updating host ID {} for {} because it's mine&quot;, hostId, endpoint);</span>
<span class="nc" id="L2426">                    tokenMetadata.removeEndpoint(endpoint);</span>
<span class="nc" id="L2427">                    endpointsToRemove.add(endpoint);</span>
                }
<span class="nc bnc" id="L2429" title="All 2 branches missed.">                else if (Gossiper.instance.compareEndpointStartup(endpoint, existing) &gt; 0)</span>
                {
<span class="nc" id="L2431">                    logger.warn(&quot;Host ID collision for {} between {} and {}; {} is the new owner&quot;, hostId, existing, endpoint, endpoint);</span>
<span class="nc" id="L2432">                    tokenMetadata.removeEndpoint(existing);</span>
<span class="nc" id="L2433">                    endpointsToRemove.add(existing);</span>
<span class="nc" id="L2434">                    tokenMetadata.updateHostId(hostId, endpoint);</span>
                }
                else
                {
<span class="nc" id="L2438">                    logger.warn(&quot;Host ID collision for {} between {} and {}; ignored {}&quot;, hostId, existing, endpoint, endpoint);</span>
<span class="nc" id="L2439">                    tokenMetadata.removeEndpoint(endpoint);</span>
<span class="nc" id="L2440">                    endpointsToRemove.add(endpoint);</span>
                }
            }
            else
<span class="fc" id="L2444">                tokenMetadata.updateHostId(hostId, endpoint);</span>
        }

        // capture because updateNormalTokens clears moving and member status
<span class="fc" id="L2448">        boolean isMember = tokenMetadata.isMember(endpoint);</span>
<span class="fc" id="L2449">        boolean isMoving = tokenMetadata.isMoving(endpoint);</span>

<span class="fc" id="L2451">        updateTokenMetadata(endpoint, tokens, endpointsToRemove);</span>

<span class="pc bpc" id="L2453" title="2 of 4 branches missed.">        if (isMoving || operationMode == Mode.MOVING)</span>
        {
<span class="nc" id="L2455">            tokenMetadata.removeFromMoving(endpoint);</span>
<span class="nc" id="L2456">            notifyMoved(endpoint);</span>
        }
<span class="fc bfc" id="L2458" title="All 2 branches covered.">        else if (!isMember) // prior to this, the node was not a member</span>
        {
<span class="fc" id="L2460">            notifyJoined(endpoint);</span>
        }

<span class="fc" id="L2463">        PendingRangeCalculatorService.instance.update();</span>
<span class="fc" id="L2464">    }</span>

    /**
     * Handle node preparing to leave the ring
     *
     * @param endpoint node
     */
    private void handleStateLeaving(InetAddress endpoint)
    {
        // If the node is previously unknown or tokens do not match, update tokenmetadata to
        // have this node as 'normal' (it must have been using this token before the
        // leave). This way we'll get pending ranges right.

<span class="nc" id="L2477">        ensureUpToDateTokenMetadata(VersionedValue.STATUS_LEAVING, endpoint);</span>

        // at this point the endpoint is certainly a member with this token, so let's proceed
        // normally
<span class="nc" id="L2481">        tokenMetadata.addLeavingEndpoint(endpoint);</span>
<span class="nc" id="L2482">        PendingRangeCalculatorService.instance.update();</span>
<span class="nc" id="L2483">    }</span>

    /**
     * Handle node leaving the ring. This will happen when a node is decommissioned
     *
     * @param endpoint If reason for leaving is decommission, endpoint is the leaving node.
     * @param pieces STATE_LEFT,token
     */
    private void handleStateLeft(InetAddress endpoint, String[] pieces)
    {
<span class="nc bnc" id="L2493" title="All 4 branches missed.">        assert pieces.length &gt;= 2;</span>
<span class="nc" id="L2494">        Collection&lt;Token&gt; tokens = getTokensFor(endpoint);</span>

<span class="nc bnc" id="L2496" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L2497">            logger.debug(&quot;Node {} state left, tokens {}&quot;, endpoint, tokens);</span>

<span class="nc" id="L2499">        excise(tokens, endpoint, extractExpireTime(pieces));</span>
<span class="nc" id="L2500">    }</span>

    /**
     * Handle node moving inside the ring.
     *
     * @param endpoint moving endpoint address
     * @param pieces STATE_MOVING, token
     */
    private void handleStateMoving(InetAddress endpoint, String[] pieces)
    {
<span class="nc" id="L2510">        ensureUpToDateTokenMetadata(VersionedValue.STATUS_MOVING, endpoint);</span>

<span class="nc bnc" id="L2512" title="All 4 branches missed.">        assert pieces.length &gt;= 2;</span>
<span class="nc" id="L2513">        Token token = getTokenFactory().fromString(pieces[1]);</span>

<span class="nc bnc" id="L2515" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L2516">            logger.debug(&quot;Node {} state moving, new token {}&quot;, endpoint, token);</span>

<span class="nc" id="L2518">        tokenMetadata.addMovingEndpoint(token, endpoint);</span>

<span class="nc" id="L2520">        PendingRangeCalculatorService.instance.update();</span>
<span class="nc" id="L2521">    }</span>

    /**
     * Handle notification that a node being actively removed from the ring via 'removenode'
     *
     * @param endpoint node
     * @param pieces either REMOVED_TOKEN (node is gone) or REMOVING_TOKEN (replicas need to be restored)
     */
    private void handleStateRemoving(InetAddress endpoint, String[] pieces)
    {
<span class="nc bnc" id="L2531" title="All 4 branches missed.">        assert (pieces.length &gt; 0);</span>

<span class="nc bnc" id="L2533" title="All 2 branches missed.">        if (endpoint.equals(FBUtilities.getBroadcastAddress()))</span>
        {
<span class="nc" id="L2535">            logger.info(&quot;Received removenode gossip about myself. Is this node rejoining after an explicit removenode?&quot;);</span>
            try
            {
<span class="nc" id="L2538">                drain();</span>
            }
<span class="nc" id="L2540">            catch (Exception e)</span>
            {
<span class="nc" id="L2542">                throw new RuntimeException(e);</span>
<span class="nc" id="L2543">            }</span>
<span class="nc" id="L2544">            return;</span>
        }
<span class="nc bnc" id="L2546" title="All 2 branches missed.">        if (tokenMetadata.isMember(endpoint))</span>
        {
<span class="nc" id="L2548">            String state = pieces[0];</span>
<span class="nc" id="L2549">            Collection&lt;Token&gt; removeTokens = tokenMetadata.getTokens(endpoint);</span>

<span class="nc bnc" id="L2551" title="All 2 branches missed.">            if (VersionedValue.REMOVED_TOKEN.equals(state))</span>
            {
<span class="nc" id="L2553">                excise(removeTokens, endpoint, extractExpireTime(pieces));</span>
            }
<span class="nc bnc" id="L2555" title="All 2 branches missed.">            else if (VersionedValue.REMOVING_TOKEN.equals(state))</span>
            {
<span class="nc" id="L2557">                ensureUpToDateTokenMetadata(state, endpoint);</span>

<span class="nc bnc" id="L2559" title="All 2 branches missed.">                if (logger.isDebugEnabled())</span>
<span class="nc" id="L2560">                    logger.debug(&quot;Tokens {} removed manually (endpoint was {})&quot;, removeTokens, endpoint);</span>

                // Note that the endpoint is being removed
<span class="nc" id="L2563">                tokenMetadata.addLeavingEndpoint(endpoint);</span>
<span class="nc" id="L2564">                PendingRangeCalculatorService.instance.update();</span>

                // find the endpoint coordinating this removal that we need to notify when we're done
<span class="nc" id="L2567">                String[] coordinator = splitValue(Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.REMOVAL_COORDINATOR));</span>
<span class="nc" id="L2568">                UUID hostId = UUID.fromString(coordinator[1]);</span>
                // grab any data we are now responsible for and notify responsible node
<span class="nc" id="L2570">                restoreReplicaCount(endpoint, tokenMetadata.getEndpointForHostId(hostId));</span>
            }
<span class="nc" id="L2572">        }</span>
        else // now that the gossiper has told us about this nonexistent member, notify the gossiper to remove it
        {
<span class="nc bnc" id="L2575" title="All 2 branches missed.">            if (VersionedValue.REMOVED_TOKEN.equals(pieces[0]))</span>
<span class="nc" id="L2576">                addExpireTimeIfFound(endpoint, extractExpireTime(pieces));</span>
<span class="nc" id="L2577">            removeEndpoint(endpoint);</span>
        }
<span class="nc" id="L2579">    }</span>

    private void excise(Collection&lt;Token&gt; tokens, InetAddress endpoint)
    {
<span class="nc" id="L2583">        logger.info(&quot;Removing tokens {} for {}&quot;, tokens, endpoint);</span>

<span class="nc" id="L2585">        UUID hostId = tokenMetadata.getHostId(endpoint);</span>
<span class="nc bnc" id="L2586" title="All 4 branches missed.">        if (hostId != null &amp;&amp; tokenMetadata.isMember(endpoint))</span>
        {
            // enough time for writes to expire and MessagingService timeout reporter callback to fire, which is where
            // hints are mostly written from - using getMinRpcTimeout() / 2 for the interval.
<span class="nc" id="L2590">            long delay = DatabaseDescriptor.getMinRpcTimeout() + DatabaseDescriptor.getWriteRpcTimeout();</span>
<span class="nc" id="L2591">            ScheduledExecutors.optionalTasks.schedule(() -&gt; HintsService.instance.excise(hostId), delay, TimeUnit.MILLISECONDS);</span>
        }

<span class="nc" id="L2594">        removeEndpoint(endpoint);</span>
<span class="nc" id="L2595">        tokenMetadata.removeEndpoint(endpoint);</span>
<span class="nc bnc" id="L2596" title="All 2 branches missed.">        if (!tokens.isEmpty())</span>
<span class="nc" id="L2597">            tokenMetadata.removeBootstrapTokens(tokens);</span>
<span class="nc" id="L2598">        notifyLeft(endpoint);</span>
<span class="nc" id="L2599">        PendingRangeCalculatorService.instance.update();</span>
<span class="nc" id="L2600">    }</span>

    private void excise(Collection&lt;Token&gt; tokens, InetAddress endpoint, long expireTime)
    {
<span class="nc" id="L2604">        addExpireTimeIfFound(endpoint, expireTime);</span>
<span class="nc" id="L2605">        excise(tokens, endpoint);</span>
<span class="nc" id="L2606">    }</span>

    /** unlike excise we just need this endpoint gone without going through any notifications **/
    private void removeEndpoint(InetAddress endpoint)
    {
<span class="nc" id="L2611">        Gossiper.runInGossipStageBlocking(() -&gt; Gossiper.instance.removeEndpoint(endpoint));</span>
<span class="nc" id="L2612">        SystemKeyspace.removeEndpoint(endpoint);</span>
<span class="nc" id="L2613">    }</span>

    protected void addExpireTimeIfFound(InetAddress endpoint, long expireTime)
    {
<span class="nc bnc" id="L2617" title="All 2 branches missed.">        if (expireTime != 0L)</span>
        {
<span class="nc" id="L2619">            Gossiper.instance.addExpireTimeForEndpoint(endpoint, expireTime);</span>
        }
<span class="nc" id="L2621">    }</span>

    protected long extractExpireTime(String[] pieces)
    {
<span class="nc" id="L2625">        return Long.parseLong(pieces[2]);</span>
    }

    /**
     * Finds living endpoints responsible for the given ranges
     *
     * @param keyspaceName the keyspace ranges belong to
     * @param ranges the ranges to find sources for
     * @return multimap of addresses to ranges the address is responsible for
     */
    private Multimap&lt;InetAddress, Range&lt;Token&gt;&gt; getNewSourceRanges(String keyspaceName, Set&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="nc" id="L2637">        InetAddress myAddress = FBUtilities.getBroadcastAddress();</span>
<span class="nc" id="L2638">        Multimap&lt;Range&lt;Token&gt;, InetAddress&gt; rangeAddresses = Keyspace.open(keyspaceName).getReplicationStrategy().getRangeAddresses(tokenMetadata.cloneOnlyTokenMap());</span>
<span class="nc" id="L2639">        Multimap&lt;InetAddress, Range&lt;Token&gt;&gt; sourceRanges = HashMultimap.create();</span>
<span class="nc" id="L2640">        IFailureDetector failureDetector = FailureDetector.instance;</span>

        // find alive sources for our new ranges
<span class="nc bnc" id="L2643" title="All 2 branches missed.">        for (Range&lt;Token&gt; range : ranges)</span>
        {
<span class="nc" id="L2645">            Collection&lt;InetAddress&gt; possibleRanges = rangeAddresses.get(range);</span>
<span class="nc" id="L2646">            IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();</span>
<span class="nc" id="L2647">            List&lt;InetAddress&gt; sources = snitch.getSortedListByProximity(myAddress, possibleRanges);</span>

<span class="nc bnc" id="L2649" title="All 4 branches missed.">            assert (!sources.contains(myAddress));</span>

<span class="nc bnc" id="L2651" title="All 2 branches missed.">            for (InetAddress source : sources)</span>
            {
<span class="nc bnc" id="L2653" title="All 2 branches missed.">                if (failureDetector.isAlive(source))</span>
                {
<span class="nc" id="L2655">                    sourceRanges.put(source, range);</span>
<span class="nc" id="L2656">                    break;</span>
                }
<span class="nc" id="L2658">            }</span>
<span class="nc" id="L2659">        }</span>
<span class="nc" id="L2660">        return sourceRanges;</span>
    }

    /**
     * Sends a notification to a node indicating we have finished replicating data.
     *
     * @param remote node to send notification to
     */
    private void sendReplicationNotification(InetAddress remote)
    {
        // notify the remote token
<span class="nc" id="L2671">        MessageOut msg = new MessageOut(MessagingService.Verb.REPLICATION_FINISHED);</span>
<span class="nc" id="L2672">        IFailureDetector failureDetector = FailureDetector.instance;</span>
<span class="nc bnc" id="L2673" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L2674">            logger.debug(&quot;Notifying {} of replication completion\n&quot;, remote);</span>
<span class="nc bnc" id="L2675" title="All 2 branches missed.">        while (failureDetector.isAlive(remote))</span>
        {
<span class="nc" id="L2677">            AsyncOneResponse iar = MessagingService.instance().sendRR(msg, remote);</span>
            try
            {
<span class="nc" id="L2680">                iar.get(DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L2681">                return; // done</span>
            }
<span class="nc" id="L2683">            catch(TimeoutException e)</span>
            {
                // try again
            }
<span class="nc" id="L2687">        }</span>
<span class="nc" id="L2688">    }</span>

    /**
     * Called when an endpoint is removed from the ring. This function checks
     * whether this node becomes responsible for new ranges as a
     * consequence and streams data if needed.
     *
     * This is rather ineffective, but it does not matter so much
     * since this is called very seldom
     *
     * @param endpoint the node that left
     */
    private void restoreReplicaCount(InetAddress endpoint, final InetAddress notifyEndpoint)
    {
<span class="nc" id="L2702">        Multimap&lt;String, Map.Entry&lt;InetAddress, Collection&lt;Range&lt;Token&gt;&gt;&gt;&gt; rangesToFetch = HashMultimap.create();</span>

<span class="nc" id="L2704">        InetAddress myAddress = FBUtilities.getBroadcastAddress();</span>

<span class="nc bnc" id="L2706" title="All 2 branches missed.">        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())</span>
        {
<span class="nc" id="L2708">            Multimap&lt;Range&lt;Token&gt;, InetAddress&gt; changedRanges = getChangedRangesForLeaving(keyspaceName, endpoint);</span>
<span class="nc" id="L2709">            Set&lt;Range&lt;Token&gt;&gt; myNewRanges = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2710" title="All 2 branches missed.">            for (Map.Entry&lt;Range&lt;Token&gt;, InetAddress&gt; entry : changedRanges.entries())</span>
            {
<span class="nc bnc" id="L2712" title="All 2 branches missed.">                if (entry.getValue().equals(myAddress))</span>
<span class="nc" id="L2713">                    myNewRanges.add(entry.getKey());</span>
<span class="nc" id="L2714">            }</span>
<span class="nc" id="L2715">            Multimap&lt;InetAddress, Range&lt;Token&gt;&gt; sourceRanges = getNewSourceRanges(keyspaceName, myNewRanges);</span>
<span class="nc bnc" id="L2716" title="All 2 branches missed.">            for (Map.Entry&lt;InetAddress, Collection&lt;Range&lt;Token&gt;&gt;&gt; entry : sourceRanges.asMap().entrySet())</span>
            {
<span class="nc" id="L2718">                rangesToFetch.put(keyspaceName, entry);</span>
<span class="nc" id="L2719">            }</span>
<span class="nc" id="L2720">        }</span>

<span class="nc" id="L2722">        StreamPlan stream = new StreamPlan(&quot;Restore replica count&quot;);</span>
<span class="nc bnc" id="L2723" title="All 2 branches missed.">        for (String keyspaceName : rangesToFetch.keySet())</span>
        {
<span class="nc bnc" id="L2725" title="All 2 branches missed.">            for (Map.Entry&lt;InetAddress, Collection&lt;Range&lt;Token&gt;&gt;&gt; entry : rangesToFetch.get(keyspaceName))</span>
            {
<span class="nc" id="L2727">                InetAddress source = entry.getKey();</span>
<span class="nc" id="L2728">                InetAddress preferred = SystemKeyspace.getPreferredIP(source);</span>
<span class="nc" id="L2729">                Collection&lt;Range&lt;Token&gt;&gt; ranges = entry.getValue();</span>
<span class="nc bnc" id="L2730" title="All 2 branches missed.">                if (logger.isDebugEnabled())</span>
<span class="nc" id="L2731">                    logger.debug(&quot;Requesting from {} ranges {}&quot;, source, StringUtils.join(ranges, &quot;, &quot;));</span>
<span class="nc" id="L2732">                stream.requestRanges(source, preferred, keyspaceName, ranges);</span>
<span class="nc" id="L2733">            }</span>
<span class="nc" id="L2734">        }</span>
<span class="nc" id="L2735">        StreamResultFuture future = stream.execute();</span>
<span class="nc" id="L2736">        Futures.addCallback(future, new FutureCallback&lt;StreamState&gt;()</span>
<span class="nc" id="L2737">        {</span>
            public void onSuccess(StreamState finalState)
            {
<span class="nc" id="L2740">                sendReplicationNotification(notifyEndpoint);</span>
<span class="nc" id="L2741">            }</span>

            public void onFailure(Throwable t)
            {
<span class="nc" id="L2745">                logger.warn(&quot;Streaming to restore replica count failed&quot;, t);</span>
                // We still want to send the notification
<span class="nc" id="L2747">                sendReplicationNotification(notifyEndpoint);</span>
<span class="nc" id="L2748">            }</span>
        });
<span class="nc" id="L2750">    }</span>

    // needs to be modified to accept either a keyspace or ARS.
    private Multimap&lt;Range&lt;Token&gt;, InetAddress&gt; getChangedRangesForLeaving(String keyspaceName, InetAddress endpoint)
    {
        // First get all ranges the leaving endpoint is responsible for
<span class="nc" id="L2756">        Collection&lt;Range&lt;Token&gt;&gt; ranges = getRangesForEndpoint(keyspaceName, endpoint);</span>

<span class="nc bnc" id="L2758" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L2759">            logger.debug(&quot;Node {} ranges [{}]&quot;, endpoint, StringUtils.join(ranges, &quot;, &quot;));</span>

<span class="nc" id="L2761">        Map&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; currentReplicaEndpoints = new HashMap&lt;&gt;(ranges.size());</span>

        // Find (for each range) all nodes that store replicas for these ranges as well
<span class="nc" id="L2764">        TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap(); // don't do this in the loop! #7758</span>
<span class="nc bnc" id="L2765" title="All 2 branches missed.">        for (Range&lt;Token&gt; range : ranges)</span>
<span class="nc" id="L2766">            currentReplicaEndpoints.put(range, Keyspace.open(keyspaceName).getReplicationStrategy().calculateNaturalEndpoints(range.right, metadata));</span>

<span class="nc" id="L2768">        TokenMetadata temp = tokenMetadata.cloneAfterAllLeft();</span>

        // endpoint might or might not be 'leaving'. If it was not leaving (that is, removenode
        // command was used), it is still present in temp and must be removed.
<span class="nc bnc" id="L2772" title="All 2 branches missed.">        if (temp.isMember(endpoint))</span>
<span class="nc" id="L2773">            temp.removeEndpoint(endpoint);</span>

<span class="nc" id="L2775">        Multimap&lt;Range&lt;Token&gt;, InetAddress&gt; changedRanges = HashMultimap.create();</span>

        // Go through the ranges and for each range check who will be
        // storing replicas for these ranges when the leaving endpoint
        // is gone. Whoever is present in newReplicaEndpoints list, but
        // not in the currentReplicaEndpoints list, will be needing the
        // range.
<span class="nc bnc" id="L2782" title="All 2 branches missed.">        for (Range&lt;Token&gt; range : ranges)</span>
        {
<span class="nc" id="L2784">            Collection&lt;InetAddress&gt; newReplicaEndpoints = Keyspace.open(keyspaceName).getReplicationStrategy().calculateNaturalEndpoints(range.right, temp);</span>
<span class="nc" id="L2785">            newReplicaEndpoints.removeAll(currentReplicaEndpoints.get(range));</span>
<span class="nc bnc" id="L2786" title="All 2 branches missed.">            if (logger.isDebugEnabled())</span>
<span class="nc bnc" id="L2787" title="All 2 branches missed.">                if (newReplicaEndpoints.isEmpty())</span>
<span class="nc" id="L2788">                    logger.debug(&quot;Range {} already in all replicas&quot;, range);</span>
                else
<span class="nc" id="L2790">                    logger.debug(&quot;Range {} will be responsibility of {}&quot;, range, StringUtils.join(newReplicaEndpoints, &quot;, &quot;));</span>
<span class="nc" id="L2791">            changedRanges.putAll(range, newReplicaEndpoints);</span>
<span class="nc" id="L2792">        }</span>

<span class="nc" id="L2794">        return changedRanges;</span>
    }

    public void onJoin(InetAddress endpoint, EndpointState epState)
    {
<span class="fc bfc" id="L2799" title="All 2 branches covered.">        for (Map.Entry&lt;ApplicationState, VersionedValue&gt; entry : epState.states())</span>
        {
<span class="fc" id="L2801">            onChange(endpoint, entry.getKey(), entry.getValue());</span>
<span class="fc" id="L2802">        }</span>
<span class="fc" id="L2803">        MigrationManager.instance.scheduleSchemaPull(endpoint, epState);</span>
<span class="fc" id="L2804">    }</span>

    public void onAlive(InetAddress endpoint, EndpointState state)
    {
<span class="fc" id="L2808">        MigrationManager.instance.scheduleSchemaPull(endpoint, state);</span>

<span class="pc bpc" id="L2810" title="1 of 2 branches missed.">        if (tokenMetadata.isMember(endpoint))</span>
<span class="fc" id="L2811">            notifyUp(endpoint);</span>
<span class="fc" id="L2812">    }</span>

    public void onRemove(InetAddress endpoint)
    {
<span class="nc" id="L2816">        tokenMetadata.removeEndpoint(endpoint);</span>
<span class="nc" id="L2817">        PendingRangeCalculatorService.instance.update();</span>
<span class="nc" id="L2818">    }</span>

    public void onDead(InetAddress endpoint, EndpointState state)
    {
<span class="fc" id="L2822">        MessagingService.instance().convict(endpoint);</span>
<span class="fc" id="L2823">        notifyDown(endpoint);</span>
<span class="fc" id="L2824">    }</span>

    public void onRestart(InetAddress endpoint, EndpointState state)
    {
        // If we have restarted before the node was even marked down, we need to reset the connection pool
<span class="nc bnc" id="L2829" title="All 2 branches missed.">        if (state.isAlive())</span>
<span class="nc" id="L2830">            onDead(endpoint, state);</span>

        // Then, the node may have been upgraded and changed its messaging protocol version. If so, we
        // want to update that before we mark the node live again to avoid problems like CASSANDRA-11128.
<span class="nc" id="L2834">        VersionedValue netVersion = state.getApplicationState(ApplicationState.NET_VERSION);</span>
<span class="nc bnc" id="L2835" title="All 2 branches missed.">        if (netVersion != null)</span>
<span class="nc" id="L2836">            updateNetVersion(endpoint, netVersion);</span>
<span class="nc" id="L2837">    }</span>


    public String getLoadString()
    {
<span class="nc" id="L2842">        return FileUtils.stringifyFileSize(StorageMetrics.load.getCount());</span>
    }

    public Map&lt;String, String&gt; getLoadMap()
    {
<span class="nc" id="L2847">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2848" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddress,Double&gt; entry : LoadBroadcaster.instance.getLoadInfo().entrySet())</span>
        {
<span class="nc" id="L2850">            map.put(entry.getKey().getHostAddress(), FileUtils.stringifyFileSize(entry.getValue()));</span>
<span class="nc" id="L2851">        }</span>
        // gossiper doesn't see its own updates, so we need to special-case the local node
<span class="nc" id="L2853">        map.put(FBUtilities.getBroadcastAddress().getHostAddress(), getLoadString());</span>
<span class="nc" id="L2854">        return map;</span>
    }

    // TODO
    public final void deliverHints(String host)
    {
<span class="nc" id="L2860">        throw new UnsupportedOperationException();</span>
    }

    public Collection&lt;Token&gt; getLocalTokens()
    {
<span class="fc" id="L2865">        Collection&lt;Token&gt; tokens = SystemKeyspace.getSavedTokens();</span>
<span class="pc bpc" id="L2866" title="3 of 6 branches missed.">        assert tokens != null &amp;&amp; !tokens.isEmpty(); // should not be called before initServer sets this</span>
<span class="fc" id="L2867">        return tokens;</span>
    }

    @Nullable
    public InetAddress getEndpointForHostId(UUID hostId)
    {
<span class="nc" id="L2873">        return tokenMetadata.getEndpointForHostId(hostId);</span>
    }

    @Nullable
    public UUID getHostIdForEndpoint(InetAddress address)
    {
<span class="nc" id="L2879">        return tokenMetadata.getHostId(address);</span>
    }

    /* These methods belong to the MBean interface */

    public List&lt;String&gt; getTokens()
    {
<span class="nc" id="L2886">        return getTokens(FBUtilities.getBroadcastAddress());</span>
    }

    public List&lt;String&gt; getTokens(String endpoint) throws UnknownHostException
    {
<span class="nc" id="L2891">        return getTokens(InetAddress.getByName(endpoint));</span>
    }

    private List&lt;String&gt; getTokens(InetAddress endpoint)
    {
<span class="nc" id="L2896">        List&lt;String&gt; strTokens = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2897" title="All 2 branches missed.">        for (Token tok : getTokenMetadata().getTokens(endpoint))</span>
<span class="nc" id="L2898">            strTokens.add(tok.toString());</span>
<span class="nc" id="L2899">        return strTokens;</span>
    }

    public String getReleaseVersion()
    {
<span class="nc" id="L2904">        return FBUtilities.getReleaseVersionString();</span>
    }

    public String getSchemaVersion()
    {
<span class="nc" id="L2909">        return Schema.instance.getVersion().toString();</span>
    }

    public List&lt;String&gt; getLeavingNodes()
    {
<span class="nc" id="L2914">        return stringify(tokenMetadata.getLeavingEndpoints());</span>
    }

    public List&lt;String&gt; getMovingNodes()
    {
<span class="nc" id="L2919">        List&lt;String&gt; endpoints = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L2921" title="All 2 branches missed.">        for (Pair&lt;Token, InetAddress&gt; node : tokenMetadata.getMovingEndpoints())</span>
        {
<span class="nc" id="L2923">            endpoints.add(node.right.getHostAddress());</span>
<span class="nc" id="L2924">        }</span>

<span class="nc" id="L2926">        return endpoints;</span>
    }

    public List&lt;String&gt; getJoiningNodes()
    {
<span class="nc" id="L2931">        return stringify(tokenMetadata.getBootstrapTokens().valueSet());</span>
    }

    public List&lt;String&gt; getLiveNodes()
    {
<span class="nc" id="L2936">        return stringify(Gossiper.instance.getLiveMembers());</span>
    }

    public Set&lt;InetAddress&gt; getLiveRingMembers()
    {
<span class="nc" id="L2941">        return getLiveRingMembers(false);</span>
    }

    public Set&lt;InetAddress&gt; getLiveRingMembers(boolean excludeDeadStates)
    {
<span class="nc" id="L2946">        Set&lt;InetAddress&gt; ret = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2947" title="All 2 branches missed.">        for (InetAddress ep : Gossiper.instance.getLiveMembers())</span>
        {
<span class="nc bnc" id="L2949" title="All 2 branches missed.">            if (excludeDeadStates)</span>
            {
<span class="nc" id="L2951">                EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(ep);</span>
<span class="nc bnc" id="L2952" title="All 4 branches missed.">                if (epState == null || Gossiper.instance.isDeadState(epState))</span>
<span class="nc" id="L2953">                    continue;</span>
            }

<span class="nc bnc" id="L2956" title="All 2 branches missed.">            if (tokenMetadata.isMember(ep))</span>
<span class="nc" id="L2957">                ret.add(ep);</span>
<span class="nc" id="L2958">        }</span>
<span class="nc" id="L2959">        return ret;</span>
    }


    public List&lt;String&gt; getUnreachableNodes()
    {
<span class="nc" id="L2965">        return stringify(Gossiper.instance.getUnreachableMembers());</span>
    }

    public String[] getAllDataFileLocations()
    {
<span class="nc" id="L2970">        String[] locations = DatabaseDescriptor.getAllDataFileLocations();</span>
<span class="nc bnc" id="L2971" title="All 2 branches missed.">        for (int i = 0; i &lt; locations.length; i++)</span>
<span class="nc" id="L2972">            locations[i] = FileUtils.getCanonicalPath(locations[i]);</span>
<span class="nc" id="L2973">        return locations;</span>
    }

    public String getCommitLogLocation()
    {
<span class="nc" id="L2978">        return FileUtils.getCanonicalPath(DatabaseDescriptor.getCommitLogLocation());</span>
    }

    public String getSavedCachesLocation()
    {
<span class="nc" id="L2983">        return FileUtils.getCanonicalPath(DatabaseDescriptor.getSavedCachesLocation());</span>
    }

    private List&lt;String&gt; stringify(Iterable&lt;InetAddress&gt; endpoints)
    {
<span class="nc" id="L2988">        List&lt;String&gt; stringEndpoints = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">        for (InetAddress ep : endpoints)</span>
        {
<span class="nc" id="L2991">            stringEndpoints.add(ep.getHostAddress());</span>
<span class="nc" id="L2992">        }</span>
<span class="nc" id="L2993">        return stringEndpoints;</span>
    }

    public int getCurrentGenerationNumber()
    {
<span class="nc" id="L2998">        return Gossiper.instance.getCurrentGenerationNumber(FBUtilities.getBroadcastAddress());</span>
    }

    public int forceKeyspaceCleanup(String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3003">        return forceKeyspaceCleanup(0, keyspaceName, tables);</span>
    }

    public int forceKeyspaceCleanup(int jobs, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc bnc" id="L3008" title="All 2 branches missed.">        if (SchemaConstants.isLocalSystemKeyspace(keyspaceName))</span>
<span class="nc" id="L3009">            throw new RuntimeException(&quot;Cleanup of the system keyspace is neither necessary nor wise&quot;);</span>

<span class="nc" id="L3011">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="nc bnc" id="L3012" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(false, false, keyspaceName, tables))</span>
        {
<span class="nc" id="L3014">            CompactionManager.AllSSTableOpStatus oneStatus = cfStore.forceCleanup(jobs);</span>
<span class="nc bnc" id="L3015" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L3016">                status = oneStatus;</span>
<span class="nc" id="L3017">        }</span>
<span class="nc" id="L3018">        return status.statusCode;</span>
    }

    public int scrub(boolean disableSnapshot, boolean skipCorrupted, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3023">        return scrub(disableSnapshot, skipCorrupted, true, 0, keyspaceName, tables);</span>
    }

    public int scrub(boolean disableSnapshot, boolean skipCorrupted, boolean checkData, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3028">        return scrub(disableSnapshot, skipCorrupted, checkData, 0, keyspaceName, tables);</span>
    }

    public int scrub(boolean disableSnapshot, boolean skipCorrupted, boolean checkData, int jobs, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3033">        return scrub(disableSnapshot, skipCorrupted, checkData, false, jobs, keyspaceName, tables);</span>
    }

    public int scrub(boolean disableSnapshot, boolean skipCorrupted, boolean checkData, boolean reinsertOverflowedTTL, int jobs, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3038">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="nc bnc" id="L3039" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tables))</span>
        {
<span class="nc" id="L3041">            CompactionManager.AllSSTableOpStatus oneStatus = cfStore.scrub(disableSnapshot, skipCorrupted, reinsertOverflowedTTL, checkData, jobs);</span>
<span class="nc bnc" id="L3042" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L3043">                status = oneStatus;</span>
<span class="nc" id="L3044">        }</span>
<span class="nc" id="L3045">        return status.statusCode;</span>
    }

    public int verify(boolean extendedVerify, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3050">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="nc bnc" id="L3051" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(false, false, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L3053">            CompactionManager.AllSSTableOpStatus oneStatus = cfStore.verify(extendedVerify);</span>
<span class="nc bnc" id="L3054" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L3055">                status = oneStatus;</span>
<span class="nc" id="L3056">        }</span>
<span class="nc" id="L3057">        return status.statusCode;</span>
    }

    public int upgradeSSTables(String keyspaceName, boolean excludeCurrentVersion, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3062">        return upgradeSSTables(keyspaceName, excludeCurrentVersion, 0, tableNames);</span>
    }

    public int upgradeSSTables(String keyspaceName, boolean excludeCurrentVersion, int jobs, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3067">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="nc bnc" id="L3068" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, true, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L3070">            CompactionManager.AllSSTableOpStatus oneStatus = cfStore.sstablesRewrite(excludeCurrentVersion, jobs);</span>
<span class="nc bnc" id="L3071" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L3072">                status = oneStatus;</span>
<span class="nc" id="L3073">        }</span>
<span class="nc" id="L3074">        return status.statusCode;</span>
    }

    public void forceKeyspaceCompaction(boolean splitOutput, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc bnc" id="L3079" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L3081">            cfStore.forceMajorCompaction(splitOutput);</span>
<span class="nc" id="L3082">        }</span>
<span class="nc" id="L3083">    }</span>

    public int relocateSSTables(String keyspaceName, String ... columnFamilies) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3087">        return relocateSSTables(0, keyspaceName, columnFamilies);</span>
    }

    public int relocateSSTables(int jobs, String keyspaceName, String ... columnFamilies) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3092">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="nc bnc" id="L3093" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : getValidColumnFamilies(false, false, keyspaceName, columnFamilies))</span>
        {
<span class="nc" id="L3095">            CompactionManager.AllSSTableOpStatus oneStatus = cfs.relocateSSTables(jobs);</span>
<span class="nc bnc" id="L3096" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L3097">                status = oneStatus;</span>
<span class="nc" id="L3098">        }</span>
<span class="nc" id="L3099">        return status.statusCode;</span>
    }

    public int garbageCollect(String tombstoneOptionString, int jobs, String keyspaceName, String ... columnFamilies) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3104">        TombstoneOption tombstoneOption = TombstoneOption.valueOf(tombstoneOptionString);</span>
<span class="nc" id="L3105">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="nc bnc" id="L3106" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : getValidColumnFamilies(false, false, keyspaceName, columnFamilies))</span>
        {
<span class="nc" id="L3108">            CompactionManager.AllSSTableOpStatus oneStatus = cfs.garbageCollect(tombstoneOption, jobs);</span>
<span class="nc bnc" id="L3109" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L3110">                status = oneStatus;</span>
<span class="nc" id="L3111">        }</span>
<span class="nc" id="L3112">        return status.statusCode;</span>
    }

    /**
     * Takes the snapshot of a multiple column family from different keyspaces. A snapshot name must be specified.
     *
     * @param tag
     *            the tag given to the snapshot; may not be null or empty
     * @param options
     *            Map of options (skipFlush is the only supported option for now)
     * @param entities
     *            list of keyspaces / tables in the form of empty | ks1 ks2 ... | ks1.cf1,ks2.cf2,...
     */
    @Override
    public void takeSnapshot(String tag, Map&lt;String, String&gt; options, String... entities) throws IOException
    {
<span class="nc" id="L3128">        boolean skipFlush = Boolean.parseBoolean(options.getOrDefault(&quot;skipFlush&quot;, &quot;false&quot;));</span>

<span class="nc bnc" id="L3130" title="All 6 branches missed.">        if (entities != null &amp;&amp; entities.length &gt; 0 &amp;&amp; entities[0].contains(&quot;.&quot;))</span>
        {
<span class="nc" id="L3132">            takeMultipleTableSnapshot(tag, skipFlush, entities);</span>
        }
        else
        {
<span class="nc" id="L3136">            takeSnapshot(tag, skipFlush, entities);</span>
        }
<span class="nc" id="L3138">    }</span>

    /**
     * Takes the snapshot of a specific table. A snapshot name must be
     * specified.
     *
     * @param keyspaceName
     *            the keyspace which holds the specified table
     * @param tableName
     *            the table to snapshot
     * @param tag
     *            the tag given to the snapshot; may not be null or empty
     */
    public void takeTableSnapshot(String keyspaceName, String tableName, String tag)
            throws IOException
    {
<span class="nc" id="L3154">        takeMultipleTableSnapshot(tag, false, keyspaceName + &quot;.&quot; + tableName);</span>
<span class="nc" id="L3155">    }</span>

    public void forceKeyspaceCompactionForTokenRange(String keyspaceName, String startToken, String endToken, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L3159">        Collection&lt;Range&lt;Token&gt;&gt; tokenRanges = createRepairRangeFrom(startToken, endToken);</span>

<span class="nc bnc" id="L3161" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L3163">            cfStore.forceCompactionForTokenRange(tokenRanges);</span>
<span class="nc" id="L3164">        }</span>
<span class="nc" id="L3165">    }</span>

    /**
     * Takes the snapshot for the given keyspaces. A snapshot name must be specified.
     *
     * @param tag the tag given to the snapshot; may not be null or empty
     * @param keyspaceNames the names of the keyspaces to snapshot; empty means &quot;all.&quot;
     */
    public void takeSnapshot(String tag, String... keyspaceNames) throws IOException
    {
<span class="nc" id="L3175">        takeSnapshot(tag, false, keyspaceNames);</span>
<span class="nc" id="L3176">    }</span>

    /**
     * Takes the snapshot of a multiple column family from different keyspaces. A snapshot name must be specified.
     *
     * @param tag
     *            the tag given to the snapshot; may not be null or empty
     * @param tableList
     *            list of tables from different keyspace in the form of ks1.cf1 ks2.cf2
     */
    public void takeMultipleTableSnapshot(String tag, String... tableList)
            throws IOException
    {
<span class="nc" id="L3189">        takeMultipleTableSnapshot(tag, false, tableList);</span>
<span class="nc" id="L3190">    }</span>

    /**
     * Takes the snapshot for the given keyspaces. A snapshot name must be specified.
     *
     * @param tag the tag given to the snapshot; may not be null or empty
     * @param skipFlush Skip blocking flush of memtable
     * @param keyspaceNames the names of the keyspaces to snapshot; empty means &quot;all.&quot;
     */
    private void takeSnapshot(String tag, boolean skipFlush, String... keyspaceNames) throws IOException
    {
<span class="nc bnc" id="L3201" title="All 2 branches missed.">        if (operationMode == Mode.JOINING)</span>
<span class="nc" id="L3202">            throw new IOException(&quot;Cannot snapshot until bootstrap completes&quot;);</span>
<span class="nc bnc" id="L3203" title="All 4 branches missed.">        if (tag == null || tag.equals(&quot;&quot;))</span>
<span class="nc" id="L3204">            throw new IOException(&quot;You must supply a snapshot name.&quot;);</span>

        Iterable&lt;Keyspace&gt; keyspaces;
<span class="nc bnc" id="L3207" title="All 2 branches missed.">        if (keyspaceNames.length == 0)</span>
        {
<span class="nc" id="L3209">            keyspaces = Keyspace.all();</span>
        }
        else
        {
<span class="nc" id="L3213">            ArrayList&lt;Keyspace&gt; t = new ArrayList&lt;&gt;(keyspaceNames.length);</span>
<span class="nc bnc" id="L3214" title="All 2 branches missed.">            for (String keyspaceName : keyspaceNames)</span>
<span class="nc" id="L3215">                t.add(getValidKeyspace(keyspaceName));</span>
<span class="nc" id="L3216">            keyspaces = t;</span>
        }

        // Do a check to see if this snapshot exists before we actually snapshot
<span class="nc bnc" id="L3220" title="All 2 branches missed.">        for (Keyspace keyspace : keyspaces)</span>
<span class="nc bnc" id="L3221" title="All 2 branches missed.">            if (keyspace.snapshotExists(tag))</span>
<span class="nc" id="L3222">                throw new IOException(&quot;Snapshot &quot; + tag + &quot; already exists.&quot;);</span>


<span class="nc bnc" id="L3225" title="All 2 branches missed.">        for (Keyspace keyspace : keyspaces)</span>
<span class="nc" id="L3226">            keyspace.snapshot(tag, null, skipFlush);</span>
<span class="nc" id="L3227">    }</span>

    /**
     * Takes the snapshot of a multiple column family from different keyspaces. A snapshot name must be specified.
     *
     *
     * @param tag
     *            the tag given to the snapshot; may not be null or empty
     * @param skipFlush
     *            Skip blocking flush of memtable
     * @param tableList
     *            list of tables from different keyspace in the form of ks1.cf1 ks2.cf2
     */
    private void takeMultipleTableSnapshot(String tag, boolean skipFlush, String... tableList)
            throws IOException
    {
<span class="nc" id="L3243">        Map&lt;Keyspace, List&lt;String&gt;&gt; keyspaceColumnfamily = new HashMap&lt;Keyspace, List&lt;String&gt;&gt;();</span>
<span class="nc bnc" id="L3244" title="All 2 branches missed.">        for (String table : tableList)</span>
        {
<span class="nc" id="L3246">            String splittedString[] = StringUtils.split(table, '.');</span>
<span class="nc bnc" id="L3247" title="All 2 branches missed.">            if (splittedString.length == 2)</span>
            {
<span class="nc" id="L3249">                String keyspaceName = splittedString[0];</span>
<span class="nc" id="L3250">                String tableName = splittedString[1];</span>

<span class="nc bnc" id="L3252" title="All 2 branches missed.">                if (keyspaceName == null)</span>
<span class="nc" id="L3253">                    throw new IOException(&quot;You must supply a keyspace name&quot;);</span>
<span class="nc bnc" id="L3254" title="All 2 branches missed.">                if (operationMode.equals(Mode.JOINING))</span>
<span class="nc" id="L3255">                    throw new IOException(&quot;Cannot snapshot until bootstrap completes&quot;);</span>

<span class="nc bnc" id="L3257" title="All 2 branches missed.">                if (tableName == null)</span>
<span class="nc" id="L3258">                    throw new IOException(&quot;You must supply a table name&quot;);</span>
<span class="nc bnc" id="L3259" title="All 4 branches missed.">                if (tag == null || tag.equals(&quot;&quot;))</span>
<span class="nc" id="L3260">                    throw new IOException(&quot;You must supply a snapshot name.&quot;);</span>

<span class="nc" id="L3262">                Keyspace keyspace = getValidKeyspace(keyspaceName);</span>
<span class="nc" id="L3263">                ColumnFamilyStore columnFamilyStore = keyspace.getColumnFamilyStore(tableName);</span>
                // As there can be multiple column family from same keyspace check if snapshot exist for that specific
                // columnfamily and not for whole keyspace

<span class="nc bnc" id="L3267" title="All 2 branches missed.">                if (columnFamilyStore.snapshotExists(tag))</span>
<span class="nc" id="L3268">                    throw new IOException(&quot;Snapshot &quot; + tag + &quot; already exists.&quot;);</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">                if (!keyspaceColumnfamily.containsKey(keyspace))</span>
                {
<span class="nc" id="L3271">                    keyspaceColumnfamily.put(keyspace, new ArrayList&lt;String&gt;());</span>
                }

                // Add Keyspace columnfamily to map in order to support atomicity for snapshot process.
                // So no snapshot should happen if any one of the above conditions fail for any keyspace or columnfamily
<span class="nc" id="L3276">                keyspaceColumnfamily.get(keyspace).add(tableName);</span>

<span class="nc" id="L3278">            }</span>
            else
            {
<span class="nc" id="L3281">                throw new IllegalArgumentException(</span>
                        &quot;Cannot take a snapshot on secondary index or invalid column family name. You must supply a column family name in the form of keyspace.columnfamily&quot;);
            }
        }

<span class="nc bnc" id="L3286" title="All 2 branches missed.">        for (Entry&lt;Keyspace, List&lt;String&gt;&gt; entry : keyspaceColumnfamily.entrySet())</span>
        {
<span class="nc bnc" id="L3288" title="All 2 branches missed.">            for (String table : entry.getValue())</span>
<span class="nc" id="L3289">                entry.getKey().snapshot(tag, table, skipFlush);</span>
<span class="nc" id="L3290">        }</span>

<span class="nc" id="L3292">    }</span>

    private Keyspace getValidKeyspace(String keyspaceName) throws IOException
    {
<span class="nc bnc" id="L3296" title="All 2 branches missed.">        if (!Schema.instance.getKeyspaces().contains(keyspaceName))</span>
        {
<span class="nc" id="L3298">            throw new IOException(&quot;Keyspace &quot; + keyspaceName + &quot; does not exist&quot;);</span>
        }
<span class="nc" id="L3300">        return Keyspace.open(keyspaceName);</span>
    }

    /**
     * Remove the snapshot with the given name from the given keyspaces.
     * If no tag is specified we will remove all snapshots.
     */
    public void clearSnapshot(String tag, String... keyspaceNames) throws IOException
    {
<span class="nc bnc" id="L3309" title="All 2 branches missed.">        if(tag == null)</span>
<span class="nc" id="L3310">            tag = &quot;&quot;;</span>

<span class="nc" id="L3312">        Set&lt;String&gt; keyspaces = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3313" title="All 2 branches missed.">        for (String dataDir : DatabaseDescriptor.getAllDataFileLocations())</span>
        {
<span class="nc bnc" id="L3315" title="All 2 branches missed.">            for(String keyspaceDir : new File(dataDir).list())</span>
            {
                // Only add a ks if it has been specified as a param, assuming params were actually provided.
<span class="nc bnc" id="L3318" title="All 4 branches missed.">                if (keyspaceNames.length &gt; 0 &amp;&amp; !Arrays.asList(keyspaceNames).contains(keyspaceDir))</span>
<span class="nc" id="L3319">                    continue;</span>
<span class="nc" id="L3320">                keyspaces.add(keyspaceDir);</span>
            }
        }

<span class="nc bnc" id="L3324" title="All 2 branches missed.">        for (String keyspace : keyspaces)</span>
<span class="nc" id="L3325">            Keyspace.clearSnapshot(tag, keyspace);</span>

<span class="nc bnc" id="L3327" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L3328">            logger.debug(&quot;Cleared out snapshot directories&quot;);</span>
<span class="nc" id="L3329">    }</span>

    public Map&lt;String, TabularData&gt; getSnapshotDetails()
    {
<span class="nc" id="L3333">        Map&lt;String, TabularData&gt; snapshotMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L3334" title="All 2 branches missed.">        for (Keyspace keyspace : Keyspace.all())</span>
        {
<span class="nc bnc" id="L3336" title="All 2 branches missed.">            if (SchemaConstants.isLocalSystemKeyspace(keyspace.getName()))</span>
<span class="nc" id="L3337">                continue;</span>

<span class="nc bnc" id="L3339" title="All 2 branches missed.">            for (ColumnFamilyStore cfStore : keyspace.getColumnFamilyStores())</span>
            {
<span class="nc bnc" id="L3341" title="All 2 branches missed.">                for (Map.Entry&lt;String, Pair&lt;Long,Long&gt;&gt; snapshotDetail : cfStore.getSnapshotDetails().entrySet())</span>
                {
<span class="nc" id="L3343">                    TabularDataSupport data = (TabularDataSupport)snapshotMap.get(snapshotDetail.getKey());</span>
<span class="nc bnc" id="L3344" title="All 2 branches missed.">                    if (data == null)</span>
                    {
<span class="nc" id="L3346">                        data = new TabularDataSupport(SnapshotDetailsTabularData.TABULAR_TYPE);</span>
<span class="nc" id="L3347">                        snapshotMap.put(snapshotDetail.getKey(), data);</span>
                    }

<span class="nc" id="L3350">                    SnapshotDetailsTabularData.from(snapshotDetail.getKey(), keyspace.getName(), cfStore.getColumnFamilyName(), snapshotDetail, data);</span>
<span class="nc" id="L3351">                }</span>
<span class="nc" id="L3352">            }</span>
<span class="nc" id="L3353">        }</span>
<span class="nc" id="L3354">        return snapshotMap;</span>
    }

    public long trueSnapshotsSize()
    {
<span class="nc" id="L3359">        long total = 0;</span>
<span class="nc bnc" id="L3360" title="All 2 branches missed.">        for (Keyspace keyspace : Keyspace.all())</span>
        {
<span class="nc bnc" id="L3362" title="All 2 branches missed.">            if (SchemaConstants.isLocalSystemKeyspace(keyspace.getName()))</span>
<span class="nc" id="L3363">                continue;</span>

<span class="nc bnc" id="L3365" title="All 2 branches missed.">            for (ColumnFamilyStore cfStore : keyspace.getColumnFamilyStores())</span>
            {
<span class="nc" id="L3367">                total += cfStore.trueSnapshotsSize();</span>
<span class="nc" id="L3368">            }</span>
<span class="nc" id="L3369">        }</span>

<span class="nc" id="L3371">        return total;</span>
    }

    public void refreshSizeEstimates() throws ExecutionException
    {
<span class="nc" id="L3376">        cleanupSizeEstimates();</span>
<span class="nc" id="L3377">        FBUtilities.waitOnFuture(ScheduledExecutors.optionalTasks.submit(SizeEstimatesRecorder.instance));</span>
<span class="nc" id="L3378">    }</span>

    public void cleanupSizeEstimates()
    {
<span class="fc" id="L3382">        SetMultimap&lt;String, String&gt; sizeEstimates = SystemKeyspace.getTablesWithSizeEstimates();</span>

<span class="pc bpc" id="L3384" title="1 of 2 branches missed.">        for (Entry&lt;String, Collection&lt;String&gt;&gt; tablesByKeyspace : sizeEstimates.asMap().entrySet())</span>
        {
<span class="nc" id="L3386">            String keyspace = tablesByKeyspace.getKey();</span>
<span class="nc bnc" id="L3387" title="All 2 branches missed.">            if (!Schema.instance.getKeyspaces().contains(keyspace))</span>
            {
<span class="nc" id="L3389">                SystemKeyspace.clearSizeEstimates(keyspace);</span>
            }
            else
            {
<span class="nc bnc" id="L3393" title="All 2 branches missed.">                for (String table : tablesByKeyspace.getValue())</span>
                {
<span class="nc bnc" id="L3395" title="All 2 branches missed.">                    if (!Schema.instance.hasCF(Pair.create(keyspace, table)))</span>
<span class="nc" id="L3396">                        SystemKeyspace.clearSizeEstimates(keyspace, table);</span>
<span class="nc" id="L3397">                }</span>
            }
<span class="nc" id="L3399">        }</span>
<span class="fc" id="L3400">    }</span>

    /**
     * @param allowIndexes Allow index CF names to be passed in
     * @param autoAddIndexes Automatically add secondary indexes if a CF has them
     * @param keyspaceName keyspace
     * @param cfNames CFs
     * @throws java.lang.IllegalArgumentException when given CF name does not exist
     */
    public Iterable&lt;ColumnFamilyStore&gt; getValidColumnFamilies(boolean allowIndexes, boolean autoAddIndexes, String keyspaceName, String... cfNames) throws IOException
    {
<span class="nc" id="L3411">        Keyspace keyspace = getValidKeyspace(keyspaceName);</span>
<span class="nc" id="L3412">        return keyspace.getValidColumnFamilies(allowIndexes, autoAddIndexes, cfNames);</span>
    }

    /**
     * Flush all memtables for a keyspace and column families.
     * @param keyspaceName
     * @param tableNames
     * @throws IOException
     */
    public void forceKeyspaceFlush(String keyspaceName, String... tableNames) throws IOException
    {
<span class="nc bnc" id="L3423" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L3425">            logger.debug(&quot;Forcing flush on keyspace {}, CF {}&quot;, keyspaceName, cfStore.name);</span>
<span class="nc" id="L3426">            cfStore.forceBlockingFlush();</span>
<span class="nc" id="L3427">        }</span>
<span class="nc" id="L3428">    }</span>

    public int repairAsync(String keyspace, Map&lt;String, String&gt; repairSpec)
    {
<span class="nc" id="L3432">        RepairOption option = RepairOption.parse(repairSpec, tokenMetadata.partitioner);</span>
        // if ranges are not specified
<span class="nc bnc" id="L3434" title="All 2 branches missed.">        if (option.getRanges().isEmpty())</span>
        {
<span class="nc bnc" id="L3436" title="All 2 branches missed.">            if (option.isPrimaryRange())</span>
            {
                // when repairing only primary range, neither dataCenters nor hosts can be set
<span class="nc bnc" id="L3439" title="All 4 branches missed.">                if (option.getDataCenters().isEmpty() &amp;&amp; option.getHosts().isEmpty())</span>
<span class="nc" id="L3440">                    option.getRanges().addAll(getPrimaryRanges(keyspace));</span>
                    // except dataCenters only contain local DC (i.e. -local)
<span class="nc bnc" id="L3442" title="All 2 branches missed.">                else if (option.isInLocalDCOnly())</span>
<span class="nc" id="L3443">                    option.getRanges().addAll(getPrimaryRangesWithinDC(keyspace));</span>
                else
<span class="nc" id="L3445">                    throw new IllegalArgumentException(&quot;You need to run primary range repair on all nodes in the cluster.&quot;);</span>
            }
            else
            {
<span class="nc" id="L3449">                option.getRanges().addAll(getLocalRanges(keyspace));</span>
            }
        }
<span class="nc" id="L3452">        return forceRepairAsync(keyspace, option, false);</span>
    }

    @Deprecated
    public int forceRepairAsync(String keyspace,
                                boolean isSequential,
                                Collection&lt;String&gt; dataCenters,
                                Collection&lt;String&gt; hosts,
                                boolean primaryRange,
                                boolean fullRepair,
                                String... tableNames)
    {
<span class="nc bnc" id="L3464" title="All 2 branches missed.">        return forceRepairAsync(keyspace, isSequential ? RepairParallelism.SEQUENTIAL.ordinal() : RepairParallelism.PARALLEL.ordinal(), dataCenters, hosts, primaryRange, fullRepair, tableNames);</span>
    }

    @Deprecated
    public int forceRepairAsync(String keyspace,
                                int parallelismDegree,
                                Collection&lt;String&gt; dataCenters,
                                Collection&lt;String&gt; hosts,
                                boolean primaryRange,
                                boolean fullRepair,
                                String... tableNames)
    {
<span class="nc bnc" id="L3476" title="All 4 branches missed.">        if (parallelismDegree &lt; 0 || parallelismDegree &gt; RepairParallelism.values().length - 1)</span>
        {
<span class="nc" id="L3478">            throw new IllegalArgumentException(&quot;Invalid parallelism degree specified: &quot; + parallelismDegree);</span>
        }
<span class="nc" id="L3480">        RepairParallelism parallelism = RepairParallelism.values()[parallelismDegree];</span>
<span class="nc bnc" id="L3481" title="All 4 branches missed.">        if (FBUtilities.isWindows &amp;&amp; parallelism != RepairParallelism.PARALLEL)</span>
        {
<span class="nc" id="L3483">            logger.warn(&quot;Snapshot-based repair is not yet supported on Windows.  Reverting to parallel repair.&quot;);</span>
<span class="nc" id="L3484">            parallelism = RepairParallelism.PARALLEL;</span>
        }

<span class="nc bnc" id="L3487" title="All 2 branches missed.">        RepairOption options = new RepairOption(parallelism, primaryRange, !fullRepair, false, 1, Collections.&lt;Range&lt;Token&gt;&gt;emptyList(), false, false);</span>
<span class="nc bnc" id="L3488" title="All 2 branches missed.">        if (dataCenters != null)</span>
        {
<span class="nc" id="L3490">            options.getDataCenters().addAll(dataCenters);</span>
        }
<span class="nc bnc" id="L3492" title="All 2 branches missed.">        if (hosts != null)</span>
        {
<span class="nc" id="L3494">            options.getHosts().addAll(hosts);</span>
        }
<span class="nc bnc" id="L3496" title="All 2 branches missed.">        if (primaryRange)</span>
        {
            // when repairing only primary range, neither dataCenters nor hosts can be set
<span class="nc bnc" id="L3499" title="All 4 branches missed.">            if (options.getDataCenters().isEmpty() &amp;&amp; options.getHosts().isEmpty())</span>
<span class="nc" id="L3500">                options.getRanges().addAll(getPrimaryRanges(keyspace));</span>
                // except dataCenters only contain local DC (i.e. -local)
<span class="nc bnc" id="L3502" title="All 4 branches missed.">            else if (options.getDataCenters().size() == 1 &amp;&amp; options.getDataCenters().contains(DatabaseDescriptor.getLocalDataCenter()))</span>
<span class="nc" id="L3503">                options.getRanges().addAll(getPrimaryRangesWithinDC(keyspace));</span>
            else
<span class="nc" id="L3505">                throw new IllegalArgumentException(&quot;You need to run primary range repair on all nodes in the cluster.&quot;);</span>
        }
        else
        {
<span class="nc" id="L3509">            options.getRanges().addAll(getLocalRanges(keyspace));</span>
        }
<span class="nc bnc" id="L3511" title="All 2 branches missed.">        if (tableNames != null)</span>
        {
<span class="nc bnc" id="L3513" title="All 2 branches missed.">            for (String table : tableNames)</span>
            {
<span class="nc" id="L3515">                options.getColumnFamilies().add(table);</span>
            }
        }
<span class="nc" id="L3518">        return forceRepairAsync(keyspace, options, true);</span>
    }

    @Deprecated
    public int forceRepairAsync(String keyspace,
                                boolean isSequential,
                                boolean isLocal,
                                boolean primaryRange,
                                boolean fullRepair,
                                String... tableNames)
    {
<span class="nc" id="L3529">        Set&lt;String&gt; dataCenters = null;</span>
<span class="nc bnc" id="L3530" title="All 2 branches missed.">        if (isLocal)</span>
        {
<span class="nc" id="L3532">            dataCenters = Sets.newHashSet(DatabaseDescriptor.getLocalDataCenter());</span>
        }
<span class="nc" id="L3534">        return forceRepairAsync(keyspace, isSequential, dataCenters, null, primaryRange, fullRepair, tableNames);</span>
    }

    @Deprecated
    public int forceRepairRangeAsync(String beginToken,
                                     String endToken,
                                     String keyspaceName,
                                     boolean isSequential,
                                     Collection&lt;String&gt; dataCenters,
                                     Collection&lt;String&gt; hosts,
                                     boolean fullRepair,
                                     String... tableNames)
    {
<span class="nc bnc" id="L3547" title="All 2 branches missed.">        return forceRepairRangeAsync(beginToken, endToken, keyspaceName,</span>
<span class="nc" id="L3548">                                     isSequential ? RepairParallelism.SEQUENTIAL.ordinal() : RepairParallelism.PARALLEL.ordinal(),</span>
                                     dataCenters, hosts, fullRepair, tableNames);
    }

    @Deprecated
    public int forceRepairRangeAsync(String beginToken,
                                     String endToken,
                                     String keyspaceName,
                                     int parallelismDegree,
                                     Collection&lt;String&gt; dataCenters,
                                     Collection&lt;String&gt; hosts,
                                     boolean fullRepair,
                                     String... tableNames)
    {
<span class="nc bnc" id="L3562" title="All 4 branches missed.">        if (parallelismDegree &lt; 0 || parallelismDegree &gt; RepairParallelism.values().length - 1)</span>
        {
<span class="nc" id="L3564">            throw new IllegalArgumentException(&quot;Invalid parallelism degree specified: &quot; + parallelismDegree);</span>
        }
<span class="nc" id="L3566">        RepairParallelism parallelism = RepairParallelism.values()[parallelismDegree];</span>
<span class="nc bnc" id="L3567" title="All 4 branches missed.">        if (FBUtilities.isWindows &amp;&amp; parallelism != RepairParallelism.PARALLEL)</span>
        {
<span class="nc" id="L3569">            logger.warn(&quot;Snapshot-based repair is not yet supported on Windows.  Reverting to parallel repair.&quot;);</span>
<span class="nc" id="L3570">            parallelism = RepairParallelism.PARALLEL;</span>
        }

<span class="nc bnc" id="L3573" title="All 2 branches missed.">        if (!fullRepair)</span>
<span class="nc" id="L3574">            logger.warn(&quot;Incremental repair can't be requested with subrange repair &quot; +</span>
                        &quot;because each subrange repair would generate an anti-compacted table. &quot; +
                        &quot;The repair will occur but without anti-compaction.&quot;);
<span class="nc" id="L3577">        Collection&lt;Range&lt;Token&gt;&gt; repairingRange = createRepairRangeFrom(beginToken, endToken);</span>

<span class="nc bnc" id="L3579" title="All 2 branches missed.">        RepairOption options = new RepairOption(parallelism, false, !fullRepair, false, 1, repairingRange, true, false);</span>
<span class="nc bnc" id="L3580" title="All 2 branches missed.">        if (dataCenters != null)</span>
        {
<span class="nc" id="L3582">            options.getDataCenters().addAll(dataCenters);</span>
        }
<span class="nc bnc" id="L3584" title="All 2 branches missed.">        if (hosts != null)</span>
        {
<span class="nc" id="L3586">            options.getHosts().addAll(hosts);</span>
        }
<span class="nc bnc" id="L3588" title="All 2 branches missed.">        if (tableNames != null)</span>
        {
<span class="nc bnc" id="L3590" title="All 2 branches missed.">            for (String table : tableNames)</span>
            {
<span class="nc" id="L3592">                options.getColumnFamilies().add(table);</span>
            }
        }

<span class="nc" id="L3596">        logger.info(&quot;starting user-requested repair of range {} for keyspace {} and column families {}&quot;,</span>
                    repairingRange, keyspaceName, tableNames);
<span class="nc" id="L3598">        return forceRepairAsync(keyspaceName, options, true);</span>
    }

    @Deprecated
    public int forceRepairRangeAsync(String beginToken,
                                     String endToken,
                                     String keyspaceName,
                                     boolean isSequential,
                                     boolean isLocal,
                                     boolean fullRepair,
                                     String... tableNames)
    {
<span class="nc" id="L3610">        Set&lt;String&gt; dataCenters = null;</span>
<span class="nc bnc" id="L3611" title="All 2 branches missed.">        if (isLocal)</span>
        {
<span class="nc" id="L3613">            dataCenters = Sets.newHashSet(DatabaseDescriptor.getLocalDataCenter());</span>
        }
<span class="nc" id="L3615">        return forceRepairRangeAsync(beginToken, endToken, keyspaceName, isSequential, dataCenters, null, fullRepair, tableNames);</span>
    }

    /**
     * Create collection of ranges that match ring layout from given tokens.
     *
     * @param beginToken beginning token of the range
     * @param endToken end token of the range
     * @return collection of ranges that match ring layout in TokenMetadata
     */
    @VisibleForTesting
    Collection&lt;Range&lt;Token&gt;&gt; createRepairRangeFrom(String beginToken, String endToken)
    {
<span class="nc" id="L3628">        Token parsedBeginToken = getTokenFactory().fromString(beginToken);</span>
<span class="nc" id="L3629">        Token parsedEndToken = getTokenFactory().fromString(endToken);</span>

        // Break up given range to match ring layout in TokenMetadata
<span class="nc" id="L3632">        ArrayList&lt;Range&lt;Token&gt;&gt; repairingRange = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L3634">        ArrayList&lt;Token&gt; tokens = new ArrayList&lt;&gt;(tokenMetadata.sortedTokens());</span>
<span class="nc bnc" id="L3635" title="All 2 branches missed.">        if (!tokens.contains(parsedBeginToken))</span>
        {
<span class="nc" id="L3637">            tokens.add(parsedBeginToken);</span>
        }
<span class="nc bnc" id="L3639" title="All 2 branches missed.">        if (!tokens.contains(parsedEndToken))</span>
        {
<span class="nc" id="L3641">            tokens.add(parsedEndToken);</span>
        }
        // tokens now contain all tokens including our endpoints
<span class="nc" id="L3644">        Collections.sort(tokens);</span>

<span class="nc" id="L3646">        int start = tokens.indexOf(parsedBeginToken), end = tokens.indexOf(parsedEndToken);</span>
<span class="nc bnc" id="L3647" title="All 2 branches missed.">        for (int i = start; i != end; i = (i+1) % tokens.size())</span>
        {
<span class="nc" id="L3649">            Range&lt;Token&gt; range = new Range&lt;&gt;(tokens.get(i), tokens.get((i+1) % tokens.size()));</span>
<span class="nc" id="L3650">            repairingRange.add(range);</span>
        }

<span class="nc" id="L3653">        return repairingRange;</span>
    }

    public TokenFactory getTokenFactory()
    {
<span class="fc" id="L3658">        return tokenMetadata.partitioner.getTokenFactory();</span>
    }

    public int forceRepairAsync(String keyspace, RepairOption options, boolean legacy)
    {
<span class="nc bnc" id="L3663" title="All 4 branches missed.">        if (options.getRanges().isEmpty() || Keyspace.open(keyspace).getReplicationStrategy().getReplicationFactor() &lt; 2)</span>
<span class="nc" id="L3664">            return 0;</span>

<span class="nc" id="L3666">        int cmd = nextRepairCommand.incrementAndGet();</span>
<span class="nc" id="L3667">        NamedThreadFactory.createThread(createRepairTask(cmd, keyspace, options, legacy), &quot;Repair-Task-&quot; + threadCounter.incrementAndGet()).start();</span>
<span class="nc" id="L3668">        return cmd;</span>
    }

    private FutureTask&lt;Object&gt; createRepairTask(final int cmd, final String keyspace, final RepairOption options, boolean legacy)
    {
<span class="nc bnc" id="L3673" title="All 4 branches missed.">        if (!options.getDataCenters().isEmpty() &amp;&amp; !options.getDataCenters().contains(DatabaseDescriptor.getLocalDataCenter()))</span>
        {
<span class="nc" id="L3675">            throw new IllegalArgumentException(&quot;the local data center must be part of the repair&quot;);</span>
        }

<span class="nc" id="L3678">        RepairRunnable task = new RepairRunnable(this, cmd, options, keyspace);</span>
<span class="nc" id="L3679">        task.addProgressListener(progressSupport);</span>
<span class="nc bnc" id="L3680" title="All 2 branches missed.">        if (legacy)</span>
<span class="nc" id="L3681">            task.addProgressListener(legacyProgressSupport);</span>
<span class="nc" id="L3682">        return new FutureTask&lt;&gt;(task, null);</span>
    }

    public void forceTerminateAllRepairSessions()
    {
<span class="nc" id="L3687">        ActiveRepairService.instance.terminateSessions();</span>
<span class="nc" id="L3688">    }</span>

    public void setRepairSessionMaxTreeDepth(int depth)
    {
<span class="nc" id="L3692">        DatabaseDescriptor.setRepairSessionMaxTreeDepth(depth);</span>
<span class="nc" id="L3693">    }</span>

    public int getRepairSessionMaxTreeDepth()
    {
<span class="nc" id="L3697">        return DatabaseDescriptor.getRepairSessionMaxTreeDepth();</span>
    }

    /* End of MBean interface methods */

    /**
     * Get the &quot;primary ranges&quot; for the specified keyspace and endpoint.
     * &quot;Primary ranges&quot; are the ranges that the node is responsible for storing replica primarily.
     * The node that stores replica primarily is defined as the first node returned
     * by {@link AbstractReplicationStrategy#calculateNaturalEndpoints}.
     *
     * @param keyspace Keyspace name to check primary ranges
     * @param ep endpoint we are interested in.
     * @return primary ranges for the specified endpoint.
     */
    public Collection&lt;Range&lt;Token&gt;&gt; getPrimaryRangesForEndpoint(String keyspace, InetAddress ep)
    {
<span class="fc" id="L3714">        AbstractReplicationStrategy strategy = Keyspace.open(keyspace).getReplicationStrategy();</span>
<span class="fc" id="L3715">        Collection&lt;Range&lt;Token&gt;&gt; primaryRanges = new HashSet&lt;&gt;();</span>
<span class="fc" id="L3716">        TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap();</span>
<span class="fc bfc" id="L3717" title="All 2 branches covered.">        for (Token token : metadata.sortedTokens())</span>
        {
<span class="fc" id="L3719">            List&lt;InetAddress&gt; endpoints = strategy.calculateNaturalEndpoints(token, metadata);</span>
<span class="pc bpc" id="L3720" title="1 of 4 branches missed.">            if (endpoints.size() &gt; 0 &amp;&amp; endpoints.get(0).equals(ep))</span>
<span class="fc" id="L3721">                primaryRanges.add(new Range&lt;&gt;(metadata.getPredecessor(token), token));</span>
<span class="fc" id="L3722">        }</span>
<span class="fc" id="L3723">        return primaryRanges;</span>
    }

    /**
     * Get the &quot;primary ranges&quot; within local DC for the specified keyspace and endpoint.
     *
     * @see #getPrimaryRangesForEndpoint(String, java.net.InetAddress)
     * @param keyspace Keyspace name to check primary ranges
     * @param referenceEndpoint endpoint we are interested in.
     * @return primary ranges within local DC for the specified endpoint.
     */
    public Collection&lt;Range&lt;Token&gt;&gt; getPrimaryRangeForEndpointWithinDC(String keyspace, InetAddress referenceEndpoint)
    {
<span class="nc" id="L3736">        TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap();</span>
<span class="nc" id="L3737">        String localDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(referenceEndpoint);</span>
<span class="nc" id="L3738">        Collection&lt;InetAddress&gt; localDcNodes = metadata.getTopology().getDatacenterEndpoints().get(localDC);</span>
<span class="nc" id="L3739">        AbstractReplicationStrategy strategy = Keyspace.open(keyspace).getReplicationStrategy();</span>

<span class="nc" id="L3741">        Collection&lt;Range&lt;Token&gt;&gt; localDCPrimaryRanges = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3742" title="All 2 branches missed.">        for (Token token : metadata.sortedTokens())</span>
        {
<span class="nc" id="L3744">            List&lt;InetAddress&gt; endpoints = strategy.calculateNaturalEndpoints(token, metadata);</span>
<span class="nc bnc" id="L3745" title="All 2 branches missed.">            for (InetAddress endpoint : endpoints)</span>
            {
<span class="nc bnc" id="L3747" title="All 2 branches missed.">                if (localDcNodes.contains(endpoint))</span>
                {
<span class="nc bnc" id="L3749" title="All 2 branches missed.">                    if (endpoint.equals(referenceEndpoint))</span>
                    {
<span class="nc" id="L3751">                        localDCPrimaryRanges.add(new Range&lt;&gt;(metadata.getPredecessor(token), token));</span>
                    }
                    break;
                }
<span class="nc" id="L3755">            }</span>
<span class="nc" id="L3756">        }</span>

<span class="nc" id="L3758">        return localDCPrimaryRanges;</span>
    }

    /**
     * Get all ranges an endpoint is responsible for (by keyspace)
     * @param ep endpoint we are interested in.
     * @return ranges for the specified endpoint.
     */
    Collection&lt;Range&lt;Token&gt;&gt; getRangesForEndpoint(String keyspaceName, InetAddress ep)
    {
<span class="nc" id="L3768">        return Keyspace.open(keyspaceName).getReplicationStrategy().getAddressRanges().get(ep);</span>
    }

    /**
     * Get all ranges that span the ring given a set
     * of tokens. All ranges are in sorted order of
     * ranges.
     * @return ranges in sorted order
    */
    public List&lt;Range&lt;Token&gt;&gt; getAllRanges(List&lt;Token&gt; sortedTokens)
    {
<span class="nc bnc" id="L3779" title="All 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L3780">            logger.trace(&quot;computing ranges for {}&quot;, StringUtils.join(sortedTokens, &quot;, &quot;));</span>

<span class="nc bnc" id="L3782" title="All 2 branches missed.">        if (sortedTokens.isEmpty())</span>
<span class="nc" id="L3783">            return Collections.emptyList();</span>
<span class="nc" id="L3784">        int size = sortedTokens.size();</span>
<span class="nc" id="L3785">        List&lt;Range&lt;Token&gt;&gt; ranges = new ArrayList&lt;&gt;(size + 1);</span>
<span class="nc bnc" id="L3786" title="All 2 branches missed.">        for (int i = 1; i &lt; size; ++i)</span>
        {
<span class="nc" id="L3788">            Range&lt;Token&gt; range = new Range&lt;&gt;(sortedTokens.get(i - 1), sortedTokens.get(i));</span>
<span class="nc" id="L3789">            ranges.add(range);</span>
        }
<span class="nc" id="L3791">        Range&lt;Token&gt; range = new Range&lt;&gt;(sortedTokens.get(size - 1), sortedTokens.get(0));</span>
<span class="nc" id="L3792">        ranges.add(range);</span>

<span class="nc" id="L3794">        return ranges;</span>
    }

    /**
     * This method returns the N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param keyspaceName keyspace name also known as keyspace
     * @param cf Column family name
     * @param key key for which we need to find the endpoint
     * @return the endpoint responsible for this key
     */
    public List&lt;InetAddress&gt; getNaturalEndpoints(String keyspaceName, String cf, String key)
    {
<span class="nc" id="L3808">        KeyspaceMetadata ksMetaData = Schema.instance.getKSMetaData(keyspaceName);</span>
<span class="nc bnc" id="L3809" title="All 2 branches missed.">        if (ksMetaData == null)</span>
<span class="nc" id="L3810">            throw new IllegalArgumentException(&quot;Unknown keyspace '&quot; + keyspaceName + &quot;'&quot;);</span>

<span class="nc" id="L3812">        CFMetaData cfMetaData = ksMetaData.getTableOrViewNullable(cf);</span>
<span class="nc bnc" id="L3813" title="All 2 branches missed.">        if (cfMetaData == null)</span>
<span class="nc" id="L3814">            throw new IllegalArgumentException(&quot;Unknown table '&quot; + cf + &quot;' in keyspace '&quot; + keyspaceName + &quot;'&quot;);</span>

<span class="nc" id="L3816">        return getNaturalEndpoints(keyspaceName, tokenMetadata.partitioner.getToken(cfMetaData.getKeyValidator().fromString(key)));</span>
    }

    public List&lt;InetAddress&gt; getNaturalEndpoints(String keyspaceName, ByteBuffer key)
    {
<span class="nc" id="L3821">        return getNaturalEndpoints(keyspaceName, tokenMetadata.partitioner.getToken(key));</span>
    }

    /**
     * This method returns the N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param keyspaceName keyspace name also known as keyspace
     * @param pos position for which we need to find the endpoint
     * @return the endpoint responsible for this token
     */
    public List&lt;InetAddress&gt; getNaturalEndpoints(String keyspaceName, RingPosition pos)
    {
<span class="fc" id="L3834">        return Keyspace.open(keyspaceName).getReplicationStrategy().getNaturalEndpoints(pos);</span>
    }

    /**
     * Returns the endpoints currently responsible for storing the token plus pending ones
     */
    public Iterable&lt;InetAddress&gt; getNaturalAndPendingEndpoints(String keyspaceName, Token token)
    {
<span class="nc" id="L3842">        return Iterables.concat(getNaturalEndpoints(keyspaceName, token), tokenMetadata.pendingEndpointsFor(token, keyspaceName));</span>
    }

    /**
     * This method attempts to return N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param keyspace keyspace name also known as keyspace
     * @param key key for which we need to find the endpoint
     * @return the endpoint responsible for this key
     */
    public List&lt;InetAddress&gt; getLiveNaturalEndpoints(Keyspace keyspace, ByteBuffer key)
    {
<span class="nc" id="L3855">        return getLiveNaturalEndpoints(keyspace, tokenMetadata.decorateKey(key));</span>
    }

    public List&lt;InetAddress&gt; getLiveNaturalEndpoints(Keyspace keyspace, RingPosition pos)
    {
<span class="fc" id="L3860">        List&lt;InetAddress&gt; liveEps = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L3861">        getLiveNaturalEndpoints(keyspace, pos, liveEps);</span>
<span class="fc" id="L3862">        return liveEps;</span>
    }

    /**
     * This method attempts to return N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param keyspace keyspace name also known as keyspace
     * @param pos position for which we need to find the endpoint
     * @param liveEps the list of endpoints to mutate
     */
    public void getLiveNaturalEndpoints(Keyspace keyspace, RingPosition pos, List&lt;InetAddress&gt; liveEps)
    {
<span class="fc" id="L3875">        List&lt;InetAddress&gt; endpoints = keyspace.getReplicationStrategy().getNaturalEndpoints(pos);</span>

<span class="fc bfc" id="L3877" title="All 2 branches covered.">        for (InetAddress endpoint : endpoints)</span>
        {
<span class="pc bpc" id="L3879" title="1 of 2 branches missed.">            if (FailureDetector.instance.isAlive(endpoint))</span>
<span class="fc" id="L3880">                liveEps.add(endpoint);</span>
<span class="fc" id="L3881">        }</span>
<span class="fc" id="L3882">    }</span>

    public void setLoggingLevel(String classQualifier, String rawLevel) throws Exception
    {
<span class="nc" id="L3886">        LoggingSupportFactory.getLoggingSupport().setLoggingLevel(classQualifier, rawLevel);</span>
<span class="nc" id="L3887">    }</span>

    /**
     * @return the runtime logging levels for all the configured loggers
     */
    @Override
    public Map&lt;String,String&gt; getLoggingLevels()
    {
<span class="nc" id="L3895">        return LoggingSupportFactory.getLoggingSupport().getLoggingLevels();</span>
    }

    /**
     * @return list of Token ranges (_not_ keys!) together with estimated key count,
     *      breaking up the data this node is responsible for into pieces of roughly keysPerSplit
     */
    public List&lt;Pair&lt;Range&lt;Token&gt;, Long&gt;&gt; getSplits(String keyspaceName, String cfName, Range&lt;Token&gt; range, int keysPerSplit)
    {
<span class="nc" id="L3904">        Keyspace t = Keyspace.open(keyspaceName);</span>
<span class="nc" id="L3905">        ColumnFamilyStore cfs = t.getColumnFamilyStore(cfName);</span>
<span class="nc" id="L3906">        List&lt;DecoratedKey&gt; keys = keySamples(Collections.singleton(cfs), range);</span>

<span class="nc" id="L3908">        long totalRowCountEstimate = cfs.estimatedKeysForRange(range);</span>

        // splitCount should be much smaller than number of key samples, to avoid huge sampling error
<span class="nc" id="L3911">        int minSamplesPerSplit = 4;</span>
<span class="nc" id="L3912">        int maxSplitCount = keys.size() / minSamplesPerSplit + 1;</span>
<span class="nc" id="L3913">        int splitCount = Math.max(1, Math.min(maxSplitCount, (int)(totalRowCountEstimate / keysPerSplit)));</span>

<span class="nc" id="L3915">        List&lt;Token&gt; tokens = keysToTokens(range, keys);</span>
<span class="nc" id="L3916">        return getSplits(tokens, splitCount, cfs);</span>
    }

    private List&lt;Pair&lt;Range&lt;Token&gt;, Long&gt;&gt; getSplits(List&lt;Token&gt; tokens, int splitCount, ColumnFamilyStore cfs)
    {
<span class="nc" id="L3921">        double step = (double) (tokens.size() - 1) / splitCount;</span>
<span class="nc" id="L3922">        Token prevToken = tokens.get(0);</span>
<span class="nc" id="L3923">        List&lt;Pair&lt;Range&lt;Token&gt;, Long&gt;&gt; splits = Lists.newArrayListWithExpectedSize(splitCount);</span>
<span class="nc bnc" id="L3924" title="All 2 branches missed.">        for (int i = 1; i &lt;= splitCount; i++)</span>
        {
<span class="nc" id="L3926">            int index = (int) Math.round(i * step);</span>
<span class="nc" id="L3927">            Token token = tokens.get(index);</span>
<span class="nc" id="L3928">            Range&lt;Token&gt; range = new Range&lt;&gt;(prevToken, token);</span>
            // always return an estimate &gt; 0 (see CASSANDRA-7322)
<span class="nc" id="L3930">            splits.add(Pair.create(range, Math.max(cfs.metadata.params.minIndexInterval, cfs.estimatedKeysForRange(range))));</span>
<span class="nc" id="L3931">            prevToken = token;</span>
        }
<span class="nc" id="L3933">        return splits;</span>
    }

    private List&lt;Token&gt; keysToTokens(Range&lt;Token&gt; range, List&lt;DecoratedKey&gt; keys)
    {
<span class="nc" id="L3938">        List&lt;Token&gt; tokens = Lists.newArrayListWithExpectedSize(keys.size() + 2);</span>
<span class="nc" id="L3939">        tokens.add(range.left);</span>
<span class="nc bnc" id="L3940" title="All 2 branches missed.">        for (DecoratedKey key : keys)</span>
<span class="nc" id="L3941">            tokens.add(key.getToken());</span>
<span class="nc" id="L3942">        tokens.add(range.right);</span>
<span class="nc" id="L3943">        return tokens;</span>
    }

    private List&lt;DecoratedKey&gt; keySamples(Iterable&lt;ColumnFamilyStore&gt; cfses, Range&lt;Token&gt; range)
    {
<span class="nc" id="L3948">        List&lt;DecoratedKey&gt; keys = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L3949" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : cfses)</span>
<span class="nc" id="L3950">            Iterables.addAll(keys, cfs.keySamples(range));</span>
<span class="nc" id="L3951">        FBUtilities.sortSampledKeys(keys, range);</span>
<span class="nc" id="L3952">        return keys;</span>
    }

    /**
     * Broadcast leaving status and update local tokenMetadata accordingly
     */
    private void startLeaving()
    {
<span class="nc" id="L3960">        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.leaving(getLocalTokens()));</span>
<span class="nc" id="L3961">        tokenMetadata.addLeavingEndpoint(FBUtilities.getBroadcastAddress());</span>
<span class="nc" id="L3962">        PendingRangeCalculatorService.instance.update();</span>
<span class="nc" id="L3963">    }</span>

    public void decommission() throws InterruptedException
    {
<span class="nc bnc" id="L3967" title="All 2 branches missed.">        if (!tokenMetadata.isMember(FBUtilities.getBroadcastAddress()))</span>
<span class="nc" id="L3968">            throw new UnsupportedOperationException(&quot;local node is not a member of the token ring yet&quot;);</span>
<span class="nc bnc" id="L3969" title="All 2 branches missed.">        if (tokenMetadata.cloneAfterAllLeft().sortedTokens().size() &lt; 2)</span>
<span class="nc" id="L3970">            throw new UnsupportedOperationException(&quot;no other normal nodes in the ring; decommission would be pointless&quot;);</span>
<span class="nc bnc" id="L3971" title="All 4 branches missed.">        if (operationMode != Mode.LEAVING &amp;&amp; operationMode != Mode.NORMAL)</span>
<span class="nc" id="L3972">            throw new UnsupportedOperationException(&quot;Node in &quot; + operationMode + &quot; state; wait for status to become normal or restart&quot;);</span>
<span class="nc bnc" id="L3973" title="All 2 branches missed.">        if (isDecommissioning.compareAndSet(true, true))</span>
<span class="nc" id="L3974">            throw new IllegalStateException(&quot;Node is still decommissioning. Check nodetool netstats.&quot;);</span>

<span class="nc bnc" id="L3976" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L3977">            logger.debug(&quot;DECOMMISSIONING&quot;);</span>

        try
        {
<span class="nc" id="L3981">            PendingRangeCalculatorService.instance.blockUntilFinished();</span>
<span class="nc bnc" id="L3982" title="All 2 branches missed.">            for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())</span>
            {
<span class="nc bnc" id="L3984" title="All 2 branches missed.">                if (tokenMetadata.getPendingRanges(keyspaceName, FBUtilities.getBroadcastAddress()).size() &gt; 0)</span>
<span class="nc" id="L3985">                    throw new UnsupportedOperationException(&quot;data is currently moving to this node; unable to leave the ring&quot;);</span>
<span class="nc" id="L3986">            }</span>

<span class="nc" id="L3988">            startLeaving();</span>
<span class="nc" id="L3989">            long timeout = Math.max(RING_DELAY, BatchlogManager.instance.getBatchlogTimeout());</span>
<span class="nc" id="L3990">            setMode(Mode.LEAVING, &quot;sleeping &quot; + timeout + &quot; ms for batch processing and pending range setup&quot;, true);</span>
<span class="nc" id="L3991">            Thread.sleep(timeout);</span>

<span class="nc" id="L3993">            Runnable finishLeaving = new Runnable()</span>
<span class="nc" id="L3994">            {</span>
                public void run()
                {
<span class="nc" id="L3997">                    shutdownClientServers();</span>
<span class="nc" id="L3998">                    Gossiper.instance.stop();</span>
                    try
                    {
<span class="nc" id="L4001">                        MessagingService.instance().shutdown();</span>
                    }
<span class="nc" id="L4003">                    catch (IOError ioe)</span>
                    {
<span class="nc" id="L4005">                        logger.info(&quot;failed to shutdown message service: {}&quot;, ioe);</span>
<span class="nc" id="L4006">                    }</span>
<span class="nc" id="L4007">                    StageManager.shutdownNow();</span>
<span class="nc" id="L4008">                    SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.DECOMMISSIONED);</span>
<span class="nc" id="L4009">                    setMode(Mode.DECOMMISSIONED, true);</span>
                    // let op be responsible for killing the process
<span class="nc" id="L4011">                }</span>
            };
<span class="nc" id="L4013">            unbootstrap(finishLeaving);</span>
        }
<span class="nc" id="L4015">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L4017">            throw new RuntimeException(&quot;Node interrupted while decommissioning&quot;);</span>
        }
<span class="nc" id="L4019">        catch (ExecutionException e)</span>
        {
<span class="nc" id="L4021">            logger.error(&quot;Error while decommissioning node &quot;, e.getCause());</span>
<span class="nc" id="L4022">            throw new RuntimeException(&quot;Error while decommissioning node: &quot; + e.getCause().getMessage());</span>
        }
        finally
        {
<span class="nc" id="L4026">            isDecommissioning.set(false);</span>
        }
<span class="nc" id="L4028">    }</span>

    private void leaveRing()
    {
<span class="nc" id="L4032">        SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.NEEDS_BOOTSTRAP);</span>
<span class="nc" id="L4033">        tokenMetadata.removeEndpoint(FBUtilities.getBroadcastAddress());</span>
<span class="nc" id="L4034">        PendingRangeCalculatorService.instance.update();</span>

<span class="nc" id="L4036">        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.left(getLocalTokens(),Gossiper.computeExpireTime()));</span>
<span class="nc" id="L4037">        int delay = Math.max(RING_DELAY, Gossiper.intervalInMillis * 2);</span>
<span class="nc" id="L4038">        logger.info(&quot;Announcing that I have left the ring for {}ms&quot;, delay);</span>
<span class="nc" id="L4039">        Uninterruptibles.sleepUninterruptibly(delay, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L4040">    }</span>

    private void unbootstrap(Runnable onFinish) throws ExecutionException, InterruptedException
    {
<span class="nc" id="L4044">        Map&lt;String, Multimap&lt;Range&lt;Token&gt;, InetAddress&gt;&gt; rangesToStream = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L4046" title="All 2 branches missed.">        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())</span>
        {
<span class="nc" id="L4048">            Multimap&lt;Range&lt;Token&gt;, InetAddress&gt; rangesMM = getChangedRangesForLeaving(keyspaceName, FBUtilities.getBroadcastAddress());</span>

<span class="nc bnc" id="L4050" title="All 2 branches missed.">            if (logger.isDebugEnabled())</span>
<span class="nc" id="L4051">                logger.debug(&quot;Ranges needing transfer are [{}]&quot;, StringUtils.join(rangesMM.keySet(), &quot;,&quot;));</span>

<span class="nc" id="L4053">            rangesToStream.put(keyspaceName, rangesMM);</span>
<span class="nc" id="L4054">        }</span>

<span class="nc" id="L4056">        setMode(Mode.LEAVING, &quot;replaying batch log and streaming data to other nodes&quot;, true);</span>

        // Start with BatchLog replay, which may create hints but no writes since this is no longer a valid endpoint.
<span class="nc" id="L4059">        Future&lt;?&gt; batchlogReplay = BatchlogManager.instance.startBatchlogReplay();</span>
<span class="nc" id="L4060">        Future&lt;StreamState&gt; streamSuccess = streamRanges(rangesToStream);</span>

        // Wait for batch log to complete before streaming hints.
<span class="nc" id="L4063">        logger.debug(&quot;waiting for batch log processing.&quot;);</span>
<span class="nc" id="L4064">        batchlogReplay.get();</span>

<span class="nc" id="L4066">        setMode(Mode.LEAVING, &quot;streaming hints to other nodes&quot;, true);</span>

<span class="nc" id="L4068">        Future hintsSuccess = streamHints();</span>

        // wait for the transfer runnables to signal the latch.
<span class="nc" id="L4071">        logger.debug(&quot;waiting for stream acks.&quot;);</span>
<span class="nc" id="L4072">        streamSuccess.get();</span>
<span class="nc" id="L4073">        hintsSuccess.get();</span>
<span class="nc" id="L4074">        logger.debug(&quot;stream acks all received.&quot;);</span>
<span class="nc" id="L4075">        leaveRing();</span>
<span class="nc" id="L4076">        onFinish.run();</span>
<span class="nc" id="L4077">    }</span>

    private Future streamHints()
    {
<span class="nc" id="L4081">        return HintsService.instance.transferHints(this::getPreferredHintsStreamTarget);</span>
    }

    /**
     * Find the best target to stream hints to. Currently the closest peer according to the snitch
     */
    private UUID getPreferredHintsStreamTarget()
    {
<span class="nc" id="L4089">        List&lt;InetAddress&gt; candidates = new ArrayList&lt;&gt;(StorageService.instance.getTokenMetadata().cloneAfterAllLeft().getAllEndpoints());</span>
<span class="nc" id="L4090">        candidates.remove(FBUtilities.getBroadcastAddress());</span>
<span class="nc bnc" id="L4091" title="All 2 branches missed.">        for (Iterator&lt;InetAddress&gt; iter = candidates.iterator(); iter.hasNext(); )</span>
        {
<span class="nc" id="L4093">            InetAddress address = iter.next();</span>
<span class="nc bnc" id="L4094" title="All 2 branches missed.">            if (!FailureDetector.instance.isAlive(address))</span>
<span class="nc" id="L4095">                iter.remove();</span>
<span class="nc" id="L4096">        }</span>

<span class="nc bnc" id="L4098" title="All 2 branches missed.">        if (candidates.isEmpty())</span>
        {
<span class="nc" id="L4100">            logger.warn(&quot;Unable to stream hints since no live endpoints seen&quot;);</span>
<span class="nc" id="L4101">            throw new RuntimeException(&quot;Unable to stream hints since no live endpoints seen&quot;);</span>
        }
        else
        {
            // stream to the closest peer as chosen by the snitch
<span class="nc" id="L4106">            DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getBroadcastAddress(), candidates);</span>
<span class="nc" id="L4107">            InetAddress hintsDestinationHost = candidates.get(0);</span>
<span class="nc" id="L4108">            return tokenMetadata.getHostId(hintsDestinationHost);</span>
        }
    }

    public void move(String newToken) throws IOException
    {
        try
        {
<span class="nc" id="L4116">            getTokenFactory().validate(newToken);</span>
        }
<span class="nc" id="L4118">        catch (ConfigurationException e)</span>
        {
<span class="nc" id="L4120">            throw new IOException(e.getMessage());</span>
<span class="nc" id="L4121">        }</span>
<span class="nc" id="L4122">        move(getTokenFactory().fromString(newToken));</span>
<span class="nc" id="L4123">    }</span>

    /**
     * move the node to new token or find a new token to boot to according to load
     *
     * @param newToken new token to boot to, or if null, find balanced token to boot to
     *
     * @throws IOException on any I/O operation error
     */
    private void move(Token newToken) throws IOException
    {
<span class="nc bnc" id="L4134" title="All 2 branches missed.">        if (newToken == null)</span>
<span class="nc" id="L4135">            throw new IOException(&quot;Can't move to the undefined (null) token.&quot;);</span>

<span class="nc bnc" id="L4137" title="All 2 branches missed.">        if (tokenMetadata.sortedTokens().contains(newToken))</span>
<span class="nc" id="L4138">            throw new IOException(&quot;target token &quot; + newToken + &quot; is already owned by another node.&quot;);</span>

        // address of the current node
<span class="nc" id="L4141">        InetAddress localAddress = FBUtilities.getBroadcastAddress();</span>

        // This doesn't make any sense in a vnodes environment.
<span class="nc bnc" id="L4144" title="All 2 branches missed.">        if (getTokenMetadata().getTokens(localAddress).size() &gt; 1)</span>
        {
<span class="nc" id="L4146">            logger.error(&quot;Invalid request to move(Token); This node has more than one token and cannot be moved thusly.&quot;);</span>
<span class="nc" id="L4147">            throw new UnsupportedOperationException(&quot;This node has more than one token and cannot be moved thusly.&quot;);</span>
        }

<span class="nc" id="L4150">        List&lt;String&gt; keyspacesToProcess = Schema.instance.getNonLocalStrategyKeyspaces();</span>

<span class="nc" id="L4152">        PendingRangeCalculatorService.instance.blockUntilFinished();</span>
        // checking if data is moving to this node
<span class="nc bnc" id="L4154" title="All 2 branches missed.">        for (String keyspaceName : keyspacesToProcess)</span>
        {
<span class="nc bnc" id="L4156" title="All 2 branches missed.">            if (tokenMetadata.getPendingRanges(keyspaceName, localAddress).size() &gt; 0)</span>
<span class="nc" id="L4157">                throw new UnsupportedOperationException(&quot;data is currently moving to this node; unable to leave the ring&quot;);</span>
<span class="nc" id="L4158">        }</span>

<span class="nc" id="L4160">        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.moving(newToken));</span>
<span class="nc" id="L4161">        setMode(Mode.MOVING, String.format(&quot;Moving %s from %s to %s.&quot;, localAddress, getLocalTokens().iterator().next(), newToken), true);</span>

<span class="nc" id="L4163">        setMode(Mode.MOVING, String.format(&quot;Sleeping %s ms before start streaming/fetching ranges&quot;, RING_DELAY), true);</span>
<span class="nc" id="L4164">        Uninterruptibles.sleepUninterruptibly(RING_DELAY, TimeUnit.MILLISECONDS);</span>

<span class="nc" id="L4166">        RangeRelocator relocator = new RangeRelocator(Collections.singleton(newToken), keyspacesToProcess);</span>

<span class="nc bnc" id="L4168" title="All 2 branches missed.">        if (relocator.streamsNeeded())</span>
        {
<span class="nc" id="L4170">            setMode(Mode.MOVING, &quot;fetching new ranges and streaming old ranges&quot;, true);</span>
            try
            {
<span class="nc" id="L4173">                relocator.stream().get();</span>
            }
<span class="nc" id="L4175">            catch (ExecutionException | InterruptedException e)</span>
            {
<span class="nc" id="L4177">                throw new RuntimeException(&quot;Interrupted while waiting for stream/fetch ranges to finish: &quot; + e.getMessage());</span>
<span class="nc" id="L4178">            }</span>
        }
        else
        {
<span class="nc" id="L4182">            setMode(Mode.MOVING, &quot;No ranges to fetch/stream&quot;, true);</span>
        }

<span class="nc" id="L4185">        setTokens(Collections.singleton(newToken)); // setting new token as we have everything settled</span>

<span class="nc bnc" id="L4187" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L4188">            logger.debug(&quot;Successfully moved to new token {}&quot;, getLocalTokens().iterator().next());</span>
<span class="nc" id="L4189">    }</span>

<span class="nc bnc" id="L4191" title="All 2 branches missed.">    private class RangeRelocator</span>
    {
<span class="nc" id="L4193">        private final StreamPlan streamPlan = new StreamPlan(&quot;Relocation&quot;);</span>

        private RangeRelocator(Collection&lt;Token&gt; tokens, List&lt;String&gt; keyspaceNames)
<span class="nc" id="L4196">        {</span>
<span class="nc" id="L4197">            calculateToFromStreams(tokens, keyspaceNames);</span>
<span class="nc" id="L4198">        }</span>

        private void calculateToFromStreams(Collection&lt;Token&gt; newTokens, List&lt;String&gt; keyspaceNames)
        {
<span class="nc" id="L4202">            InetAddress localAddress = FBUtilities.getBroadcastAddress();</span>
<span class="nc" id="L4203">            IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();</span>
<span class="nc" id="L4204">            TokenMetadata tokenMetaCloneAllSettled = tokenMetadata.cloneAfterAllSettled();</span>
            // clone to avoid concurrent modification in calculateNaturalEndpoints
<span class="nc" id="L4206">            TokenMetadata tokenMetaClone = tokenMetadata.cloneOnlyTokenMap();</span>

<span class="nc bnc" id="L4208" title="All 2 branches missed.">            for (String keyspace : keyspaceNames)</span>
            {
                // replication strategy of the current keyspace
<span class="nc" id="L4211">                AbstractReplicationStrategy strategy = Keyspace.open(keyspace).getReplicationStrategy();</span>
<span class="nc" id="L4212">                Multimap&lt;InetAddress, Range&lt;Token&gt;&gt; endpointToRanges = strategy.getAddressRanges();</span>

<span class="nc" id="L4214">                logger.debug(&quot;Calculating ranges to stream and request for keyspace {}&quot;, keyspace);</span>
<span class="nc bnc" id="L4215" title="All 2 branches missed.">                for (Token newToken : newTokens)</span>
                {
                    // getting collection of the currently used ranges by this keyspace
<span class="nc" id="L4218">                    Collection&lt;Range&lt;Token&gt;&gt; currentRanges = endpointToRanges.get(localAddress);</span>
                    // collection of ranges which this node will serve after move to the new token
<span class="nc" id="L4220">                    Collection&lt;Range&lt;Token&gt;&gt; updatedRanges = strategy.getPendingAddressRanges(tokenMetaClone, newToken, localAddress);</span>

                    // ring ranges and endpoints associated with them
                    // this used to determine what nodes should we ping about range data
<span class="nc" id="L4224">                    Multimap&lt;Range&lt;Token&gt;, InetAddress&gt; rangeAddresses = strategy.getRangeAddresses(tokenMetaClone);</span>

                    // calculated parts of the ranges to request/stream from/to nodes in the ring
<span class="nc" id="L4227">                    Pair&lt;Set&lt;Range&lt;Token&gt;&gt;, Set&lt;Range&lt;Token&gt;&gt;&gt; rangesPerKeyspace = calculateStreamAndFetchRanges(currentRanges, updatedRanges);</span>

                    /**
                     * In this loop we are going through all ranges &quot;to fetch&quot; and determining
                     * nodes in the ring responsible for data we are interested in
                     */
<span class="nc" id="L4233">                    Multimap&lt;Range&lt;Token&gt;, InetAddress&gt; rangesToFetchWithPreferredEndpoints = ArrayListMultimap.create();</span>
<span class="nc bnc" id="L4234" title="All 2 branches missed.">                    for (Range&lt;Token&gt; toFetch : rangesPerKeyspace.right)</span>
                    {
<span class="nc bnc" id="L4236" title="All 2 branches missed.">                        for (Range&lt;Token&gt; range : rangeAddresses.keySet())</span>
                        {
<span class="nc bnc" id="L4238" title="All 2 branches missed.">                            if (range.contains(toFetch))</span>
                            {
<span class="nc" id="L4240">                                List&lt;InetAddress&gt; endpoints = null;</span>

<span class="nc bnc" id="L4242" title="All 2 branches missed.">                                if (useStrictConsistency)</span>
                                {
<span class="nc" id="L4244">                                    Set&lt;InetAddress&gt; oldEndpoints = Sets.newHashSet(rangeAddresses.get(range));</span>
<span class="nc" id="L4245">                                    Set&lt;InetAddress&gt; newEndpoints = Sets.newHashSet(strategy.calculateNaturalEndpoints(toFetch.right, tokenMetaCloneAllSettled));</span>

                                    //Due to CASSANDRA-5953 we can have a higher RF then we have endpoints.
                                    //So we need to be careful to only be strict when endpoints == RF
<span class="nc bnc" id="L4249" title="All 2 branches missed.">                                    if (oldEndpoints.size() == strategy.getReplicationFactor())</span>
                                    {
<span class="nc" id="L4251">                                        oldEndpoints.removeAll(newEndpoints);</span>

                                        //No relocation required
<span class="nc bnc" id="L4254" title="All 2 branches missed.">                                        if (oldEndpoints.isEmpty())</span>
<span class="nc" id="L4255">                                            continue;</span>

<span class="nc bnc" id="L4257" title="All 4 branches missed.">                                        assert oldEndpoints.size() == 1 : &quot;Expected 1 endpoint but found &quot; + oldEndpoints.size();</span>
                                    }

<span class="nc" id="L4260">                                    endpoints = Lists.newArrayList(oldEndpoints.iterator().next());</span>
<span class="nc" id="L4261">                                }</span>
                                else
                                {
<span class="nc" id="L4264">                                    endpoints = snitch.getSortedListByProximity(localAddress, rangeAddresses.get(range));</span>
                                }

                                // storing range and preferred endpoint set
<span class="nc" id="L4268">                                rangesToFetchWithPreferredEndpoints.putAll(toFetch, endpoints);</span>
                            }
<span class="nc" id="L4270">                        }</span>

<span class="nc" id="L4272">                        Collection&lt;InetAddress&gt; addressList = rangesToFetchWithPreferredEndpoints.get(toFetch);</span>
<span class="nc bnc" id="L4273" title="All 4 branches missed.">                        if (addressList == null || addressList.isEmpty())</span>
<span class="nc" id="L4274">                            continue;</span>

<span class="nc bnc" id="L4276" title="All 2 branches missed.">                        if (useStrictConsistency)</span>
                        {
<span class="nc bnc" id="L4278" title="All 2 branches missed.">                            if (addressList.size() &gt; 1)</span>
<span class="nc" id="L4279">                                throw new IllegalStateException(&quot;Multiple strict sources found for &quot; + toFetch);</span>

<span class="nc" id="L4281">                            InetAddress sourceIp = addressList.iterator().next();</span>
<span class="nc bnc" id="L4282" title="All 4 branches missed.">                            if (Gossiper.instance.isEnabled() &amp;&amp; !Gossiper.instance.getEndpointStateForEndpoint(sourceIp).isAlive())</span>
<span class="nc" id="L4283">                                throw new RuntimeException(&quot;A node required to move the data consistently is down (&quot;+sourceIp+&quot;).  If you wish to move the data from a potentially inconsistent replica, restart the node with -Dcassandra.consistent.rangemovement=false&quot;);</span>
                        }
<span class="nc" id="L4285">                    }</span>

                    // calculating endpoints to stream current ranges to if needed
                    // in some situations node will handle current ranges as part of the new ranges
<span class="nc" id="L4289">                    Multimap&lt;InetAddress, Range&lt;Token&gt;&gt; endpointRanges = HashMultimap.create();</span>
<span class="nc bnc" id="L4290" title="All 2 branches missed.">                    for (Range&lt;Token&gt; toStream : rangesPerKeyspace.left)</span>
                    {
<span class="nc" id="L4292">                        Set&lt;InetAddress&gt; currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(toStream.right, tokenMetaClone));</span>
<span class="nc" id="L4293">                        Set&lt;InetAddress&gt; newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(toStream.right, tokenMetaCloneAllSettled));</span>
<span class="nc" id="L4294">                        logger.debug(&quot;Range: {} Current endpoints: {} New endpoints: {}&quot;, toStream, currentEndpoints, newEndpoints);</span>
<span class="nc bnc" id="L4295" title="All 2 branches missed.">                        for (InetAddress address : Sets.difference(newEndpoints, currentEndpoints))</span>
                        {
<span class="nc" id="L4297">                            logger.debug(&quot;Range {} has new owner {}&quot;, toStream, address);</span>
<span class="nc" id="L4298">                            endpointRanges.put(address, toStream);</span>
<span class="nc" id="L4299">                        }</span>
<span class="nc" id="L4300">                    }</span>

                    // stream ranges
<span class="nc bnc" id="L4303" title="All 2 branches missed.">                    for (InetAddress address : endpointRanges.keySet())</span>
                    {
<span class="nc" id="L4305">                        logger.debug(&quot;Will stream range {} of keyspace {} to endpoint {}&quot;, endpointRanges.get(address), keyspace, address);</span>
<span class="nc" id="L4306">                        InetAddress preferred = SystemKeyspace.getPreferredIP(address);</span>
<span class="nc" id="L4307">                        streamPlan.transferRanges(address, preferred, keyspace, endpointRanges.get(address));</span>
<span class="nc" id="L4308">                    }</span>

                    // stream requests
<span class="nc" id="L4311">                    Multimap&lt;InetAddress, Range&lt;Token&gt;&gt; workMap = RangeStreamer.getWorkMap(rangesToFetchWithPreferredEndpoints, keyspace, FailureDetector.instance, useStrictConsistency);</span>
<span class="nc bnc" id="L4312" title="All 2 branches missed.">                    for (InetAddress address : workMap.keySet())</span>
                    {
<span class="nc" id="L4314">                        logger.debug(&quot;Will request range {} of keyspace {} from endpoint {}&quot;, workMap.get(address), keyspace, address);</span>
<span class="nc" id="L4315">                        InetAddress preferred = SystemKeyspace.getPreferredIP(address);</span>
<span class="nc" id="L4316">                        streamPlan.requestRanges(address, preferred, keyspace, workMap.get(address));</span>
<span class="nc" id="L4317">                    }</span>

<span class="nc" id="L4319">                    logger.debug(&quot;Keyspace {}: work map {}.&quot;, keyspace, workMap);</span>
<span class="nc" id="L4320">                }</span>
<span class="nc" id="L4321">            }</span>
<span class="nc" id="L4322">        }</span>

        public Future&lt;StreamState&gt; stream()
        {
<span class="nc" id="L4326">            return streamPlan.execute();</span>
        }

        public boolean streamsNeeded()
        {
<span class="nc bnc" id="L4331" title="All 2 branches missed.">            return !streamPlan.isEmpty();</span>
        }
    }

    /**
     * Get the status of a token removal.
     */
    public String getRemovalStatus()
    {
<span class="nc bnc" id="L4340" title="All 2 branches missed.">        if (removingNode == null)</span>
        {
<span class="nc" id="L4342">            return &quot;No token removals in process.&quot;;</span>
        }
<span class="nc" id="L4344">        return String.format(&quot;Removing token (%s). Waiting for replication confirmation from [%s].&quot;,</span>
<span class="nc" id="L4345">                             tokenMetadata.getToken(removingNode),</span>
<span class="nc" id="L4346">                             StringUtils.join(replicatingNodes, &quot;,&quot;));</span>
    }

    /**
     * Force a remove operation to complete. This may be necessary if a remove operation
     * blocks forever due to node/stream failure. removeNode() must be called
     * first, this is a last resort measure.  No further attempt will be made to restore replicas.
     */
    public void forceRemoveCompletion()
    {
<span class="nc bnc" id="L4356" title="All 4 branches missed.">        if (!replicatingNodes.isEmpty()  || !tokenMetadata.getLeavingEndpoints().isEmpty())</span>
        {
<span class="nc" id="L4358">            logger.warn(&quot;Removal not confirmed for for {}&quot;, StringUtils.join(this.replicatingNodes, &quot;,&quot;));</span>
<span class="nc bnc" id="L4359" title="All 2 branches missed.">            for (InetAddress endpoint : tokenMetadata.getLeavingEndpoints())</span>
            {
<span class="nc" id="L4361">                UUID hostId = tokenMetadata.getHostId(endpoint);</span>
<span class="nc" id="L4362">                Gossiper.instance.advertiseTokenRemoved(endpoint, hostId);</span>
<span class="nc" id="L4363">                excise(tokenMetadata.getTokens(endpoint), endpoint);</span>
<span class="nc" id="L4364">            }</span>
<span class="nc" id="L4365">            replicatingNodes.clear();</span>
<span class="nc" id="L4366">            removingNode = null;</span>
        }
        else
        {
<span class="nc" id="L4370">            logger.warn(&quot;No nodes to force removal on, call 'removenode' first&quot;);</span>
        }
<span class="nc" id="L4372">    }</span>

    /**
     * Remove a node that has died, attempting to restore the replica count.
     * If the node is alive, decommission should be attempted.  If decommission
     * fails, then removeNode should be called.  If we fail while trying to
     * restore the replica count, finally forceRemoveCompleteion should be
     * called to forcibly remove the node without regard to replica count.
     *
     * @param hostIdString Host ID for the node
     */
    public void removeNode(String hostIdString)
    {
<span class="nc" id="L4385">        InetAddress myAddress = FBUtilities.getBroadcastAddress();</span>
<span class="nc" id="L4386">        UUID localHostId = tokenMetadata.getHostId(myAddress);</span>
<span class="nc" id="L4387">        UUID hostId = UUID.fromString(hostIdString);</span>
<span class="nc" id="L4388">        InetAddress endpoint = tokenMetadata.getEndpointForHostId(hostId);</span>

<span class="nc bnc" id="L4390" title="All 2 branches missed.">        if (endpoint == null)</span>
<span class="nc" id="L4391">            throw new UnsupportedOperationException(&quot;Host ID not found.&quot;);</span>

<span class="nc bnc" id="L4393" title="All 2 branches missed.">        if (!tokenMetadata.isMember(endpoint))</span>
<span class="nc" id="L4394">            throw new UnsupportedOperationException(&quot;Node to be removed is not a member of the token ring&quot;);</span>

<span class="nc bnc" id="L4396" title="All 2 branches missed.">        if (endpoint.equals(myAddress))</span>
<span class="nc" id="L4397">             throw new UnsupportedOperationException(&quot;Cannot remove self&quot;);</span>

<span class="nc bnc" id="L4399" title="All 2 branches missed.">        if (Gossiper.instance.getLiveMembers().contains(endpoint))</span>
<span class="nc" id="L4400">            throw new UnsupportedOperationException(&quot;Node &quot; + endpoint + &quot; is alive and owns this ID. Use decommission command to remove it from the ring&quot;);</span>

        // A leaving endpoint that is dead is already being removed.
<span class="nc bnc" id="L4403" title="All 2 branches missed.">        if (tokenMetadata.isLeaving(endpoint))</span>
<span class="nc" id="L4404">            logger.warn(&quot;Node {} is already being removed, continuing removal anyway&quot;, endpoint);</span>

<span class="nc bnc" id="L4406" title="All 2 branches missed.">        if (!replicatingNodes.isEmpty())</span>
<span class="nc" id="L4407">            throw new UnsupportedOperationException(&quot;This node is already processing a removal. Wait for it to complete, or use 'removenode force' if this has failed.&quot;);</span>

<span class="nc" id="L4409">        Collection&lt;Token&gt; tokens = tokenMetadata.getTokens(endpoint);</span>

        // Find the endpoints that are going to become responsible for data
<span class="nc bnc" id="L4412" title="All 2 branches missed.">        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())</span>
        {
            // if the replication factor is 1 the data is lost so we shouldn't wait for confirmation
<span class="nc bnc" id="L4415" title="All 2 branches missed.">            if (Keyspace.open(keyspaceName).getReplicationStrategy().getReplicationFactor() == 1)</span>
<span class="nc" id="L4416">                continue;</span>

            // get all ranges that change ownership (that is, a node needs
            // to take responsibility for new range)
<span class="nc" id="L4420">            Multimap&lt;Range&lt;Token&gt;, InetAddress&gt; changedRanges = getChangedRangesForLeaving(keyspaceName, endpoint);</span>
<span class="nc" id="L4421">            IFailureDetector failureDetector = FailureDetector.instance;</span>
<span class="nc bnc" id="L4422" title="All 2 branches missed.">            for (InetAddress ep : changedRanges.values())</span>
            {
<span class="nc bnc" id="L4424" title="All 2 branches missed.">                if (failureDetector.isAlive(ep))</span>
<span class="nc" id="L4425">                    replicatingNodes.add(ep);</span>
                else
<span class="nc" id="L4427">                    logger.warn(&quot;Endpoint {} is down and will not receive data for re-replication of {}&quot;, ep, endpoint);</span>
<span class="nc" id="L4428">            }</span>
<span class="nc" id="L4429">        }</span>
<span class="nc" id="L4430">        removingNode = endpoint;</span>

<span class="nc" id="L4432">        tokenMetadata.addLeavingEndpoint(endpoint);</span>
<span class="nc" id="L4433">        PendingRangeCalculatorService.instance.update();</span>

        // the gossiper will handle spoofing this node's state to REMOVING_TOKEN for us
        // we add our own token so other nodes to let us know when they're done
<span class="nc" id="L4437">        Gossiper.instance.advertiseRemoving(endpoint, hostId, localHostId);</span>

        // kick off streaming commands
<span class="nc" id="L4440">        restoreReplicaCount(endpoint, myAddress);</span>

        // wait for ReplicationFinishedVerbHandler to signal we're done
<span class="nc bnc" id="L4443" title="All 2 branches missed.">        while (!replicatingNodes.isEmpty())</span>
        {
<span class="nc" id="L4445">            Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);</span>
        }

<span class="nc" id="L4448">        excise(tokens, endpoint);</span>

        // gossiper will indicate the token has left
<span class="nc" id="L4451">        Gossiper.instance.advertiseTokenRemoved(endpoint, hostId);</span>

<span class="nc" id="L4453">        replicatingNodes.clear();</span>
<span class="nc" id="L4454">        removingNode = null;</span>
<span class="nc" id="L4455">    }</span>

    public void confirmReplication(InetAddress node)
    {
        // replicatingNodes can be empty in the case where this node used to be a removal coordinator,
        // but restarted before all 'replication finished' messages arrived. In that case, we'll
        // still go ahead and acknowledge it.
<span class="nc bnc" id="L4462" title="All 2 branches missed.">        if (!replicatingNodes.isEmpty())</span>
        {
<span class="nc" id="L4464">            replicatingNodes.remove(node);</span>
        }
        else
        {
<span class="nc" id="L4468">            logger.info(&quot;Received unexpected REPLICATION_FINISHED message from {}. Was this node recently a removal coordinator?&quot;, node);</span>
        }
<span class="nc" id="L4470">    }</span>

    public String getOperationMode()
    {
<span class="nc" id="L4474">        return operationMode.toString();</span>
    }

    public boolean isStarting()
    {
<span class="nc bnc" id="L4479" title="All 2 branches missed.">        return operationMode == Mode.STARTING;</span>
    }

    public boolean isMoving()
    {
<span class="nc bnc" id="L4484" title="All 2 branches missed.">        return operationMode == Mode.MOVING;</span>
    }

    public boolean isJoining()
    {
<span class="nc bnc" id="L4489" title="All 2 branches missed.">        return operationMode == Mode.JOINING;</span>
    }

    public boolean isDrained()
    {
<span class="nc bnc" id="L4494" title="All 2 branches missed.">        return operationMode == Mode.DRAINED;</span>
    }

    public boolean isDraining()
    {
<span class="nc bnc" id="L4499" title="All 2 branches missed.">        return operationMode == Mode.DRAINING;</span>
    }

    public String getDrainProgress()
    {
<span class="nc" id="L4504">        return String.format(&quot;Drained %s/%s ColumnFamilies&quot;, remainingCFs, totalCFs);</span>
    }

    /**
     * Shuts node off to writes, empties memtables and the commit log.
     */
    public synchronized void drain() throws IOException, InterruptedException, ExecutionException
    {
<span class="nc" id="L4512">        drain(false);</span>
<span class="nc" id="L4513">    }</span>

    protected synchronized void drain(boolean isFinalShutdown) throws IOException, InterruptedException, ExecutionException
    {
<span class="fc" id="L4517">        ExecutorService counterMutationStage = StageManager.getStage(Stage.COUNTER_MUTATION);</span>
<span class="fc" id="L4518">        ExecutorService viewMutationStage = StageManager.getStage(Stage.VIEW_MUTATION);</span>
<span class="fc" id="L4519">        ExecutorService mutationStage = StageManager.getStage(Stage.MUTATION);</span>

<span class="pc bpc" id="L4521" title="1 of 2 branches missed.">        if (mutationStage.isTerminated()</span>
<span class="nc bnc" id="L4522" title="All 2 branches missed.">            &amp;&amp; counterMutationStage.isTerminated()</span>
<span class="nc bnc" id="L4523" title="All 2 branches missed.">            &amp;&amp; viewMutationStage.isTerminated())</span>
        {
<span class="nc bnc" id="L4525" title="All 2 branches missed.">            if (!isFinalShutdown)</span>
<span class="nc" id="L4526">                logger.warn(&quot;Cannot drain node (did it already happen?)&quot;);</span>
<span class="nc" id="L4527">            return;</span>
        }

<span class="pc bpc" id="L4530" title="2 of 4 branches missed.">        assert !isShutdown;</span>
<span class="fc" id="L4531">        isShutdown = true;</span>

<span class="pc" id="L4533">        Throwable preShutdownHookThrowable = Throwables.perform(null, preShutdownHooks.stream().map(h -&gt; h::run));</span>
<span class="pc bpc" id="L4534" title="1 of 2 branches missed.">        if (preShutdownHookThrowable != null)</span>
<span class="nc" id="L4535">            logger.error(&quot;Attempting to continue draining after pre-shutdown hooks returned exception&quot;, preShutdownHookThrowable);</span>

        try
        {
<span class="pc bpc" id="L4539" title="1 of 2 branches missed.">            setMode(Mode.DRAINING, &quot;starting drain process&quot;, !isFinalShutdown);</span>

            try
            {
                /* not clear this is reasonable time, but propagated from prior embedded behaviour */
<span class="fc" id="L4544">                BatchlogManager.instance.shutdownAndWait(1L, MINUTES);</span>
            }
<span class="nc" id="L4546">            catch (TimeoutException t)</span>
            {
<span class="nc" id="L4548">                logger.error(&quot;Batchlog manager timed out shutting down&quot;, t);</span>
<span class="fc" id="L4549">            }</span>

<span class="fc" id="L4551">            HintsService.instance.pauseDispatch();</span>

<span class="pc bpc" id="L4553" title="1 of 2 branches missed.">            if (daemon != null)</span>
<span class="fc" id="L4554">                shutdownClientServers();</span>
<span class="fc" id="L4555">            ScheduledExecutors.optionalTasks.shutdown();</span>
<span class="nc" id="L4556">            Gossiper.instance.stop();</span>

<span class="nc bnc" id="L4558" title="All 2 branches missed.">            if (!isFinalShutdown)</span>
<span class="nc" id="L4559">                setMode(Mode.DRAINING, &quot;shutting down MessageService&quot;, false);</span>

            // In-progress writes originating here could generate hints to be written, so shut down MessagingService
            // before mutation stage, so we can get all the hints saved before shutting down
<span class="nc" id="L4563">            MessagingService.instance().shutdown();</span>

<span class="nc bnc" id="L4565" title="All 2 branches missed.">            if (!isFinalShutdown)</span>
<span class="nc" id="L4566">                setMode(Mode.DRAINING, &quot;clearing mutation stage&quot;, false);</span>
<span class="nc" id="L4567">            viewMutationStage.shutdown();</span>
<span class="nc" id="L4568">            counterMutationStage.shutdown();</span>
<span class="nc" id="L4569">            mutationStage.shutdown();</span>
<span class="nc" id="L4570">            viewMutationStage.awaitTermination(3600, TimeUnit.SECONDS);</span>
<span class="nc" id="L4571">            counterMutationStage.awaitTermination(3600, TimeUnit.SECONDS);</span>
<span class="nc" id="L4572">            mutationStage.awaitTermination(3600, TimeUnit.SECONDS);</span>

<span class="nc" id="L4574">            StorageProxy.instance.verifyNoHintsInProgress();</span>

<span class="nc bnc" id="L4576" title="All 2 branches missed.">            if (!isFinalShutdown)</span>
<span class="nc" id="L4577">                setMode(Mode.DRAINING, &quot;flushing column families&quot;, false);</span>

            // disable autocompaction - we don't want to start any new compactions while we are draining
<span class="nc bnc" id="L4580" title="All 2 branches missed.">            for (Keyspace keyspace : Keyspace.all())</span>
<span class="nc bnc" id="L4581" title="All 2 branches missed.">                for (ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())</span>
<span class="nc" id="L4582">                    cfs.disableAutoCompaction();</span>

            // count CFs first, since forceFlush could block for the flushWriter to get a queue slot empty
<span class="nc" id="L4585">            totalCFs = 0;</span>
<span class="nc bnc" id="L4586" title="All 2 branches missed.">            for (Keyspace keyspace : Keyspace.nonSystem())</span>
<span class="nc" id="L4587">                totalCFs += keyspace.getColumnFamilyStores().size();</span>
<span class="nc" id="L4588">            remainingCFs = totalCFs;</span>
            // flush
<span class="nc" id="L4590">            List&lt;Future&lt;?&gt;&gt; flushes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L4591" title="All 2 branches missed.">            for (Keyspace keyspace : Keyspace.nonSystem())</span>
            {
<span class="nc bnc" id="L4593" title="All 2 branches missed.">                for (ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())</span>
<span class="nc" id="L4594">                    flushes.add(cfs.forceFlush());</span>
<span class="nc" id="L4595">            }</span>
            // wait for the flushes.
            // TODO this is a godawful way to track progress, since they flush in parallel.  a long one could
            // thus make several short ones &quot;instant&quot; if we wait for them later.
<span class="nc bnc" id="L4599" title="All 2 branches missed.">            for (Future f : flushes)</span>
            {
                try
                {
<span class="nc" id="L4603">                    FBUtilities.waitOnFuture(f);</span>
                }
<span class="nc" id="L4605">                catch (Throwable t)</span>
                {
<span class="nc" id="L4607">                    JVMStabilityInspector.inspectThrowable(t);</span>
                    // don't let this stop us from shutting down the commitlog and other thread pools
<span class="nc" id="L4609">                    logger.warn(&quot;Caught exception while waiting for memtable flushes during shutdown hook&quot;, t);</span>
<span class="nc" id="L4610">                }</span>

<span class="nc" id="L4612">                remainingCFs--;</span>
<span class="nc" id="L4613">            }</span>

            // Interrupt ongoing compactions and shutdown CM to prevent further compactions.
<span class="nc" id="L4616">            CompactionManager.instance.forceShutdown();</span>
            // Flush the system tables after all other tables are flushed, just in case flushing modifies any system state
            // like CASSANDRA-5151. Don't bother with progress tracking since system data is tiny.
            // Flush system tables after stopping compactions since they modify
            // system tables (for example compactions can obsolete sstables and the tidiers in SSTableReader update
            // system tables, see SSTableReader.GlobalTidy)
<span class="nc" id="L4622">            flushes.clear();</span>
<span class="nc bnc" id="L4623" title="All 2 branches missed.">            for (Keyspace keyspace : Keyspace.system())</span>
            {
<span class="nc bnc" id="L4625" title="All 2 branches missed.">                for (ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())</span>
<span class="nc" id="L4626">                    flushes.add(cfs.forceFlush());</span>
<span class="nc" id="L4627">            }</span>
<span class="nc" id="L4628">            FBUtilities.waitOnFutures(flushes);</span>

<span class="nc" id="L4630">            HintsService.instance.shutdownBlocking();</span>

            // Interrupt ongoing compactions and shutdown CM to prevent further compactions.
<span class="nc" id="L4633">            CompactionManager.instance.forceShutdown();</span>

            // whilst we've flushed all the CFs, which will have recycled all completed segments, we want to ensure
            // there are no segments to replay, so we force the recycling of any remaining (should be at most one)
<span class="nc" id="L4637">            CommitLog.instance.forceRecycleAllSegments();</span>

<span class="nc" id="L4639">            CommitLog.instance.shutdownBlocking();</span>

            // wait for miscellaneous tasks like sstable and commitlog segment deletion
<span class="nc" id="L4642">            ScheduledExecutors.nonPeriodicTasks.shutdown();</span>
<span class="nc bnc" id="L4643" title="All 2 branches missed.">            if (!ScheduledExecutors.nonPeriodicTasks.awaitTermination(1, MINUTES))</span>
<span class="nc" id="L4644">                logger.warn(&quot;Failed to wait for non periodic tasks to shutdown&quot;);</span>

<span class="nc" id="L4646">            ColumnFamilyStore.shutdownPostFlushExecutor();</span>
<span class="nc bnc" id="L4647" title="All 2 branches missed.">            setMode(Mode.DRAINED, !isFinalShutdown);</span>
        }
<span class="nc" id="L4649">        catch (Throwable t)</span>
        {
<span class="nc" id="L4651">            logger.error(&quot;Caught an exception while draining &quot;, t);</span>
        }
        finally
        {
<span class="nc" id="L4655">            Throwable postShutdownHookThrowable = Throwables.perform(null, postShutdownHooks.stream().map(h -&gt; h::run));</span>
<span class="nc bnc" id="L4656" title="All 2 branches missed.">            if (postShutdownHookThrowable != null)</span>
<span class="nc" id="L4657">                logger.error(&quot;Post-shutdown hooks returned exception&quot;, postShutdownHookThrowable);</span>
        }
<span class="nc" id="L4659">    }</span>

    /**
     * Add a runnable which will be called before shut down or drain. This is useful for other
     * applications running in the same JVM which may want to shut down first rather than time
     * out attempting to use Cassandra calls which will no longer work.
     * @param hook: the code to run
     * @return true on success, false if Cassandra is already shutting down, in which case the runnable
     * has NOT been added.
     */
    public synchronized boolean addPreShutdownHook(Runnable hook)
    {
<span class="nc bnc" id="L4671" title="All 4 branches missed.">        if (!isDraining() &amp;&amp; !isDrained())</span>
<span class="nc" id="L4672">            return preShutdownHooks.add(hook);</span>

<span class="nc" id="L4674">        return false;</span>
    }

    /**
     * Remove a preshutdown hook
     */
    public synchronized boolean removePreShutdownHook(Runnable hook)
    {
<span class="nc" id="L4682">        return preShutdownHooks.remove(hook);</span>
    }

    /**
     * Add a runnable which will be called after shutdown or drain. This is useful for other applications
     * running in the same JVM that Cassandra needs to work and should shut down later.
     * @param hook: the code to run
     * @return true on success, false if Cassandra is already shutting down, in which case the runnable has NOT been
     * added.
     */
    public synchronized boolean addPostShutdownHook(Runnable hook)
    {
<span class="nc bnc" id="L4694" title="All 4 branches missed.">        if (!isDraining() &amp;&amp; !isDrained())</span>
<span class="nc" id="L4695">            return postShutdownHooks.add(hook);</span>

<span class="nc" id="L4697">        return false;</span>
    }

    /**
     * Remove a postshutdownhook
     */
    public synchronized boolean removePostShutdownHook(Runnable hook)
    {
<span class="nc" id="L4705">        return postShutdownHooks.remove(hook);</span>
    }

    /**
     * Some services are shutdown during draining and we should not attempt to start them again.
     *
     * @param service - the name of the service we are trying to start.
     * @throws IllegalStateException - an exception that nodetool is able to convert into a message to display to the user
     */
    synchronized void checkServiceAllowedToStart(String service)
    {
<span class="nc bnc" id="L4716" title="All 2 branches missed.">        if (isDraining()) // when draining isShutdown is also true, so we check first to return a more accurate message</span>
<span class="nc" id="L4717">            throw new IllegalStateException(String.format(&quot;Unable to start %s because the node is draining.&quot;, service));</span>

<span class="nc bnc" id="L4719" title="All 2 branches missed.">        if (isShutdown()) // do not rely on operationMode in case it gets changed to decomissioned or other</span>
<span class="nc" id="L4720">            throw new IllegalStateException(String.format(&quot;Unable to start %s because the node was drained.&quot;, service));</span>
<span class="nc" id="L4721">    }</span>

    // Never ever do this at home. Used by tests.
    @VisibleForTesting
    public IPartitioner setPartitionerUnsafe(IPartitioner newPartitioner)
    {
<span class="nc" id="L4727">        IPartitioner oldPartitioner = DatabaseDescriptor.setPartitionerUnsafe(newPartitioner);</span>
<span class="nc" id="L4728">        tokenMetadata = tokenMetadata.cloneWithNewPartitioner(newPartitioner);</span>
<span class="nc" id="L4729">        valueFactory = new VersionedValue.VersionedValueFactory(newPartitioner);</span>
<span class="nc" id="L4730">        return oldPartitioner;</span>
    }

    TokenMetadata setTokenMetadataUnsafe(TokenMetadata tmd)
    {
<span class="nc" id="L4735">        TokenMetadata old = tokenMetadata;</span>
<span class="nc" id="L4736">        tokenMetadata = tmd;</span>
<span class="nc" id="L4737">        return old;</span>
    }

    public void truncate(String keyspace, String table) throws TimeoutException, IOException
    {
        try
        {
<span class="nc" id="L4744">            StorageProxy.truncateBlocking(keyspace, table);</span>
        }
<span class="nc" id="L4746">        catch (UnavailableException e)</span>
        {
<span class="nc" id="L4748">            throw new IOException(e.getMessage());</span>
<span class="nc" id="L4749">        }</span>
<span class="nc" id="L4750">    }</span>

    public Map&lt;InetAddress, Float&gt; getOwnership()
    {
<span class="nc" id="L4754">        List&lt;Token&gt; sortedTokens = tokenMetadata.sortedTokens();</span>
        // describeOwnership returns tokens in an unspecified order, let's re-order them
<span class="nc" id="L4756">        Map&lt;Token, Float&gt; tokenMap = new TreeMap&lt;Token, Float&gt;(tokenMetadata.partitioner.describeOwnership(sortedTokens));</span>
<span class="nc" id="L4757">        Map&lt;InetAddress, Float&gt; nodeMap = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4758" title="All 2 branches missed.">        for (Map.Entry&lt;Token, Float&gt; entry : tokenMap.entrySet())</span>
        {
<span class="nc" id="L4760">            InetAddress endpoint = tokenMetadata.getEndpoint(entry.getKey());</span>
<span class="nc" id="L4761">            Float tokenOwnership = entry.getValue();</span>
<span class="nc bnc" id="L4762" title="All 2 branches missed.">            if (nodeMap.containsKey(endpoint))</span>
<span class="nc" id="L4763">                nodeMap.put(endpoint, nodeMap.get(endpoint) + tokenOwnership);</span>
            else
<span class="nc" id="L4765">                nodeMap.put(endpoint, tokenOwnership);</span>
<span class="nc" id="L4766">        }</span>
<span class="nc" id="L4767">        return nodeMap;</span>
    }

    /**
     * Calculates ownership. If there are multiple DC's and the replication strategy is DC aware then ownership will be
     * calculated per dc, i.e. each DC will have total ring ownership divided amongst its nodes. Without replication
     * total ownership will be a multiple of the number of DC's and this value will then go up within each DC depending
     * on the number of replicas within itself. For DC unaware replication strategies, ownership without replication
     * will be 100%.
     *
     * @throws IllegalStateException when node is not configured properly.
     */
    public LinkedHashMap&lt;InetAddress, Float&gt; effectiveOwnership(String keyspace) throws IllegalStateException
    {
        AbstractReplicationStrategy strategy;
<span class="nc bnc" id="L4782" title="All 2 branches missed.">        if (keyspace != null)</span>
        {
<span class="nc" id="L4784">            Keyspace keyspaceInstance = Schema.instance.getKeyspaceInstance(keyspace);</span>
<span class="nc bnc" id="L4785" title="All 2 branches missed.">            if (keyspaceInstance == null)</span>
<span class="nc" id="L4786">                throw new IllegalArgumentException(&quot;The keyspace &quot; + keyspace + &quot;, does not exist&quot;);</span>

<span class="nc bnc" id="L4788" title="All 2 branches missed.">            if (keyspaceInstance.getReplicationStrategy() instanceof LocalStrategy)</span>
<span class="nc" id="L4789">                throw new IllegalStateException(&quot;Ownership values for keyspaces with LocalStrategy are meaningless&quot;);</span>
<span class="nc" id="L4790">            strategy = keyspaceInstance.getReplicationStrategy();</span>
<span class="nc" id="L4791">        }</span>
        else
        {
<span class="nc" id="L4794">            List&lt;String&gt; userKeyspaces = Schema.instance.getUserKeyspaces();</span>

<span class="nc bnc" id="L4796" title="All 2 branches missed.">            if (userKeyspaces.size() &gt; 0)</span>
            {
<span class="nc" id="L4798">                keyspace = userKeyspaces.get(0);</span>
<span class="nc" id="L4799">                AbstractReplicationStrategy replicationStrategy = Schema.instance.getKeyspaceInstance(keyspace).getReplicationStrategy();</span>
<span class="nc bnc" id="L4800" title="All 2 branches missed.">                for (String keyspaceName : userKeyspaces)</span>
                {
<span class="nc bnc" id="L4802" title="All 2 branches missed.">                    if (!Schema.instance.getKeyspaceInstance(keyspaceName).getReplicationStrategy().hasSameSettings(replicationStrategy))</span>
<span class="nc" id="L4803">                        throw new IllegalStateException(&quot;Non-system keyspaces don't have the same replication settings, effective ownership information is meaningless&quot;);</span>
<span class="nc" id="L4804">                }</span>
<span class="nc" id="L4805">            }</span>
            else
            {
<span class="nc" id="L4808">                keyspace = &quot;system_traces&quot;;</span>
            }

<span class="nc" id="L4811">            Keyspace keyspaceInstance = Schema.instance.getKeyspaceInstance(keyspace);</span>
<span class="nc bnc" id="L4812" title="All 2 branches missed.">            if (keyspaceInstance == null)</span>
<span class="nc" id="L4813">                throw new IllegalArgumentException(&quot;The node does not have &quot; + keyspace + &quot; yet, probably still bootstrapping&quot;);</span>
<span class="nc" id="L4814">            strategy = keyspaceInstance.getReplicationStrategy();</span>
        }

<span class="nc" id="L4817">        TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap();</span>

<span class="nc" id="L4819">        Collection&lt;Collection&lt;InetAddress&gt;&gt; endpointsGroupedByDc = new ArrayList&lt;&gt;();</span>
        // mapping of dc's to nodes, use sorted map so that we get dcs sorted
<span class="nc" id="L4821">        SortedMap&lt;String, Collection&lt;InetAddress&gt;&gt; sortedDcsToEndpoints = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L4822">        sortedDcsToEndpoints.putAll(metadata.getTopology().getDatacenterEndpoints().asMap());</span>
<span class="nc bnc" id="L4823" title="All 2 branches missed.">        for (Collection&lt;InetAddress&gt; endpoints : sortedDcsToEndpoints.values())</span>
<span class="nc" id="L4824">            endpointsGroupedByDc.add(endpoints);</span>

<span class="nc" id="L4826">        Map&lt;Token, Float&gt; tokenOwnership = tokenMetadata.partitioner.describeOwnership(tokenMetadata.sortedTokens());</span>
<span class="nc" id="L4827">        LinkedHashMap&lt;InetAddress, Float&gt; finalOwnership = Maps.newLinkedHashMap();</span>

<span class="nc" id="L4829">        Multimap&lt;InetAddress, Range&lt;Token&gt;&gt; endpointToRanges = strategy.getAddressRanges();</span>
        // calculate ownership per dc
<span class="nc bnc" id="L4831" title="All 2 branches missed.">        for (Collection&lt;InetAddress&gt; endpoints : endpointsGroupedByDc)</span>
        {
            // calculate the ownership with replication and add the endpoint to the final ownership map
<span class="nc bnc" id="L4834" title="All 2 branches missed.">            for (InetAddress endpoint : endpoints)</span>
            {
<span class="nc" id="L4836">                float ownership = 0.0f;</span>
<span class="nc bnc" id="L4837" title="All 2 branches missed.">                for (Range&lt;Token&gt; range : endpointToRanges.get(endpoint))</span>
                {
<span class="nc bnc" id="L4839" title="All 2 branches missed.">                    if (tokenOwnership.containsKey(range.right))</span>
<span class="nc" id="L4840">                        ownership += tokenOwnership.get(range.right);</span>
<span class="nc" id="L4841">                }</span>
<span class="nc" id="L4842">                finalOwnership.put(endpoint, ownership);</span>
<span class="nc" id="L4843">            }</span>
<span class="nc" id="L4844">        }</span>
<span class="nc" id="L4845">        return finalOwnership;</span>
    }

    public List&lt;String&gt; getKeyspaces()
    {
<span class="nc" id="L4850">        List&lt;String&gt; keyspaceNamesList = new ArrayList&lt;&gt;(Schema.instance.getKeyspaces());</span>
<span class="nc" id="L4851">        return Collections.unmodifiableList(keyspaceNamesList);</span>
    }

    public List&lt;String&gt; getNonSystemKeyspaces()
    {
<span class="nc" id="L4856">        List&lt;String&gt; nonKeyspaceNamesList = new ArrayList&lt;&gt;(Schema.instance.getNonSystemKeyspaces());</span>
<span class="nc" id="L4857">        return Collections.unmodifiableList(nonKeyspaceNamesList);</span>
    }

    public List&lt;String&gt; getNonLocalStrategyKeyspaces()
    {
<span class="nc" id="L4862">        return Collections.unmodifiableList(Schema.instance.getNonLocalStrategyKeyspaces());</span>
    }

    public Map&lt;String, String&gt; getViewBuildStatuses(String keyspace, String view)
    {
<span class="nc" id="L4867">        Map&lt;UUID, String&gt; coreViewStatus = SystemDistributedKeyspace.viewStatus(keyspace, view);</span>
<span class="nc" id="L4868">        Map&lt;InetAddress, UUID&gt; hostIdToEndpoint = tokenMetadata.getEndpointToHostIdMapForReading();</span>
<span class="nc" id="L4869">        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L4871" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddress, UUID&gt; entry : hostIdToEndpoint.entrySet())</span>
        {
<span class="nc" id="L4873">            UUID hostId = entry.getValue();</span>
<span class="nc" id="L4874">            InetAddress endpoint = entry.getKey();</span>
<span class="nc" id="L4875">            result.put(endpoint.toString(),</span>
<span class="nc bnc" id="L4876" title="All 2 branches missed.">                       coreViewStatus.containsKey(hostId)</span>
<span class="nc" id="L4877">                       ? coreViewStatus.get(hostId)</span>
                       : &quot;UNKNOWN&quot;);
<span class="nc" id="L4879">        }</span>

<span class="nc" id="L4881">        return Collections.unmodifiableMap(result);</span>
    }

    public void setDynamicUpdateInterval(int dynamicUpdateInterval)
    {
<span class="nc bnc" id="L4886" title="All 2 branches missed.">        if (DatabaseDescriptor.getEndpointSnitch() instanceof DynamicEndpointSnitch)</span>
        {

            try
            {
<span class="nc" id="L4891">                updateSnitch(null, true, dynamicUpdateInterval, null, null);</span>
            }
<span class="nc" id="L4893">            catch (ClassNotFoundException e)</span>
            {
<span class="nc" id="L4895">                throw new RuntimeException(e);</span>
<span class="nc" id="L4896">            }</span>
        }
<span class="nc" id="L4898">    }</span>

    public int getDynamicUpdateInterval()
    {
<span class="nc" id="L4902">        return DatabaseDescriptor.getDynamicUpdateInterval();</span>
    }

    public void updateSnitch(String epSnitchClassName, Boolean dynamic, Integer dynamicUpdateInterval, Integer dynamicResetInterval, Double dynamicBadnessThreshold) throws ClassNotFoundException
    {
        // apply dynamic snitch configuration
<span class="nc bnc" id="L4908" title="All 2 branches missed.">        if (dynamicUpdateInterval != null)</span>
<span class="nc" id="L4909">            DatabaseDescriptor.setDynamicUpdateInterval(dynamicUpdateInterval);</span>
<span class="nc bnc" id="L4910" title="All 2 branches missed.">        if (dynamicResetInterval != null)</span>
<span class="nc" id="L4911">            DatabaseDescriptor.setDynamicResetInterval(dynamicResetInterval);</span>
<span class="nc bnc" id="L4912" title="All 2 branches missed.">        if (dynamicBadnessThreshold != null)</span>
<span class="nc" id="L4913">            DatabaseDescriptor.setDynamicBadnessThreshold(dynamicBadnessThreshold);</span>

<span class="nc" id="L4915">        IEndpointSnitch oldSnitch = DatabaseDescriptor.getEndpointSnitch();</span>

        // new snitch registers mbean during construction
<span class="nc bnc" id="L4918" title="All 2 branches missed.">        if(epSnitchClassName != null)</span>
        {

            // need to unregister the mbean _before_ the new dynamic snitch is instantiated (and implicitly initialized
            // and its mbean registered)
<span class="nc bnc" id="L4923" title="All 2 branches missed.">            if (oldSnitch instanceof DynamicEndpointSnitch)</span>
<span class="nc" id="L4924">                ((DynamicEndpointSnitch)oldSnitch).close();</span>

            IEndpointSnitch newSnitch;
            try
            {
<span class="nc bnc" id="L4929" title="All 4 branches missed.">                newSnitch = DatabaseDescriptor.createEndpointSnitch(dynamic != null &amp;&amp; dynamic, epSnitchClassName);</span>
            }
<span class="nc" id="L4931">            catch (ConfigurationException e)</span>
            {
<span class="nc" id="L4933">                throw new ClassNotFoundException(e.getMessage());</span>
<span class="nc" id="L4934">            }</span>

<span class="nc bnc" id="L4936" title="All 2 branches missed.">            if (newSnitch instanceof DynamicEndpointSnitch)</span>
            {
<span class="nc" id="L4938">                logger.info(&quot;Created new dynamic snitch {} with update-interval={}, reset-interval={}, badness-threshold={}&quot;,</span>
<span class="nc" id="L4939">                            ((DynamicEndpointSnitch)newSnitch).subsnitch.getClass().getName(), DatabaseDescriptor.getDynamicUpdateInterval(),</span>
<span class="nc" id="L4940">                            DatabaseDescriptor.getDynamicResetInterval(), DatabaseDescriptor.getDynamicBadnessThreshold());</span>
            }
            else
            {
<span class="nc" id="L4944">                logger.info(&quot;Created new non-dynamic snitch {}&quot;, newSnitch.getClass().getName());</span>
            }

            // point snitch references to the new instance
<span class="nc" id="L4948">            DatabaseDescriptor.setEndpointSnitch(newSnitch);</span>
<span class="nc bnc" id="L4949" title="All 2 branches missed.">            for (String ks : Schema.instance.getKeyspaces())</span>
            {
<span class="nc" id="L4951">                Keyspace.open(ks).getReplicationStrategy().snitch = newSnitch;</span>
<span class="nc" id="L4952">            }</span>
<span class="nc" id="L4953">        }</span>
        else
        {
<span class="nc bnc" id="L4956" title="All 2 branches missed.">            if (oldSnitch instanceof DynamicEndpointSnitch)</span>
            {
<span class="nc" id="L4958">                logger.info(&quot;Applying config change to dynamic snitch {} with update-interval={}, reset-interval={}, badness-threshold={}&quot;,</span>
<span class="nc" id="L4959">                            ((DynamicEndpointSnitch)oldSnitch).subsnitch.getClass().getName(), DatabaseDescriptor.getDynamicUpdateInterval(),</span>
<span class="nc" id="L4960">                            DatabaseDescriptor.getDynamicResetInterval(), DatabaseDescriptor.getDynamicBadnessThreshold());</span>

<span class="nc" id="L4962">                DynamicEndpointSnitch snitch = (DynamicEndpointSnitch)oldSnitch;</span>
<span class="nc" id="L4963">                snitch.applyConfigChanges();</span>
            }
        }

<span class="nc" id="L4967">        updateTopology();</span>
<span class="nc" id="L4968">    }</span>

    /**
     * Seed data to the endpoints that will be responsible for it at the future
     *
     * @param rangesToStreamByKeyspace keyspaces and data ranges with endpoints included for each
     * @return async Future for whether stream was success
     */
    private Future&lt;StreamState&gt; streamRanges(Map&lt;String, Multimap&lt;Range&lt;Token&gt;, InetAddress&gt;&gt; rangesToStreamByKeyspace)
    {
        // First, we build a list of ranges to stream to each host, per table
<span class="nc" id="L4979">        Map&lt;String, Map&lt;InetAddress, List&lt;Range&lt;Token&gt;&gt;&gt;&gt; sessionsToStreamByKeyspace = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L4981" title="All 2 branches missed.">        for (Map.Entry&lt;String, Multimap&lt;Range&lt;Token&gt;, InetAddress&gt;&gt; entry : rangesToStreamByKeyspace.entrySet())</span>
        {
<span class="nc" id="L4983">            String keyspace = entry.getKey();</span>
<span class="nc" id="L4984">            Multimap&lt;Range&lt;Token&gt;, InetAddress&gt; rangesWithEndpoints = entry.getValue();</span>

<span class="nc bnc" id="L4986" title="All 2 branches missed.">            if (rangesWithEndpoints.isEmpty())</span>
<span class="nc" id="L4987">                continue;</span>

<span class="nc" id="L4989">            Map&lt;InetAddress, Set&lt;Range&lt;Token&gt;&gt;&gt; transferredRangePerKeyspace = SystemKeyspace.getTransferredRanges(&quot;Unbootstrap&quot;,</span>
                                                                                                                  keyspace,
<span class="nc" id="L4991">                                                                                                                  StorageService.instance.getTokenMetadata().partitioner);</span>
<span class="nc" id="L4992">            Map&lt;InetAddress, List&lt;Range&lt;Token&gt;&gt;&gt; rangesPerEndpoint = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4993" title="All 2 branches missed.">            for (Map.Entry&lt;Range&lt;Token&gt;, InetAddress&gt; endPointEntry : rangesWithEndpoints.entries())</span>
            {
<span class="nc" id="L4995">                Range&lt;Token&gt; range = endPointEntry.getKey();</span>
<span class="nc" id="L4996">                InetAddress endpoint = endPointEntry.getValue();</span>

<span class="nc" id="L4998">                Set&lt;Range&lt;Token&gt;&gt; transferredRanges = transferredRangePerKeyspace.get(endpoint);</span>
<span class="nc bnc" id="L4999" title="All 4 branches missed.">                if (transferredRanges != null &amp;&amp; transferredRanges.contains(range))</span>
                {
<span class="nc" id="L5001">                    logger.debug(&quot;Skipping transferred range {} of keyspace {}, endpoint {}&quot;, range, keyspace, endpoint);</span>
<span class="nc" id="L5002">                    continue;</span>
                }

<span class="nc" id="L5005">                List&lt;Range&lt;Token&gt;&gt; curRanges = rangesPerEndpoint.get(endpoint);</span>
<span class="nc bnc" id="L5006" title="All 2 branches missed.">                if (curRanges == null)</span>
                {
<span class="nc" id="L5008">                    curRanges = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L5009">                    rangesPerEndpoint.put(endpoint, curRanges);</span>
                }
<span class="nc" id="L5011">                curRanges.add(range);</span>
<span class="nc" id="L5012">            }</span>

<span class="nc" id="L5014">            sessionsToStreamByKeyspace.put(keyspace, rangesPerEndpoint);</span>
<span class="nc" id="L5015">        }</span>

<span class="nc" id="L5017">        StreamPlan streamPlan = new StreamPlan(&quot;Unbootstrap&quot;);</span>

        // Vinculate StreamStateStore to current StreamPlan to update transferred ranges per StreamSession
<span class="nc" id="L5020">        streamPlan.listeners(streamStateStore);</span>

<span class="nc bnc" id="L5022" title="All 2 branches missed.">        for (Map.Entry&lt;String, Map&lt;InetAddress, List&lt;Range&lt;Token&gt;&gt;&gt;&gt; entry : sessionsToStreamByKeyspace.entrySet())</span>
        {
<span class="nc" id="L5024">            String keyspaceName = entry.getKey();</span>
<span class="nc" id="L5025">            Map&lt;InetAddress, List&lt;Range&lt;Token&gt;&gt;&gt; rangesPerEndpoint = entry.getValue();</span>

<span class="nc bnc" id="L5027" title="All 2 branches missed.">            for (Map.Entry&lt;InetAddress, List&lt;Range&lt;Token&gt;&gt;&gt; rangesEntry : rangesPerEndpoint.entrySet())</span>
            {
<span class="nc" id="L5029">                List&lt;Range&lt;Token&gt;&gt; ranges = rangesEntry.getValue();</span>
<span class="nc" id="L5030">                InetAddress newEndpoint = rangesEntry.getKey();</span>
<span class="nc" id="L5031">                InetAddress preferred = SystemKeyspace.getPreferredIP(newEndpoint);</span>

                // TODO each call to transferRanges re-flushes, this is potentially a lot of waste
<span class="nc" id="L5034">                streamPlan.transferRanges(newEndpoint, preferred, keyspaceName, ranges);</span>
<span class="nc" id="L5035">            }</span>
<span class="nc" id="L5036">        }</span>
<span class="nc" id="L5037">        return streamPlan.execute();</span>
    }

    /**
     * Calculate pair of ranges to stream/fetch for given two range collections
     * (current ranges for keyspace and ranges after move to new token)
     *
     * @param current collection of the ranges by current token
     * @param updated collection of the ranges after token is changed
     * @return pair of ranges to stream/fetch for given current and updated range collections
     */
    public Pair&lt;Set&lt;Range&lt;Token&gt;&gt;, Set&lt;Range&lt;Token&gt;&gt;&gt; calculateStreamAndFetchRanges(Collection&lt;Range&lt;Token&gt;&gt; current, Collection&lt;Range&lt;Token&gt;&gt; updated)
    {
<span class="nc" id="L5050">        Set&lt;Range&lt;Token&gt;&gt; toStream = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5051">        Set&lt;Range&lt;Token&gt;&gt; toFetch  = new HashSet&lt;&gt;();</span>


<span class="nc bnc" id="L5054" title="All 2 branches missed.">        for (Range&lt;Token&gt; r1 : current)</span>
        {
<span class="nc" id="L5056">            boolean intersect = false;</span>
<span class="nc bnc" id="L5057" title="All 2 branches missed.">            for (Range&lt;Token&gt; r2 : updated)</span>
            {
<span class="nc bnc" id="L5059" title="All 2 branches missed.">                if (r1.intersects(r2))</span>
                {
                    // adding difference ranges to fetch from a ring
<span class="nc" id="L5062">                    toStream.addAll(r1.subtract(r2));</span>
<span class="nc" id="L5063">                    intersect = true;</span>
                }
<span class="nc" id="L5065">            }</span>
<span class="nc bnc" id="L5066" title="All 2 branches missed.">            if (!intersect)</span>
            {
<span class="nc" id="L5068">                toStream.add(r1); // should seed whole old range</span>
            }
<span class="nc" id="L5070">        }</span>

<span class="nc bnc" id="L5072" title="All 2 branches missed.">        for (Range&lt;Token&gt; r2 : updated)</span>
        {
<span class="nc" id="L5074">            boolean intersect = false;</span>
<span class="nc bnc" id="L5075" title="All 2 branches missed.">            for (Range&lt;Token&gt; r1 : current)</span>
            {
<span class="nc bnc" id="L5077" title="All 2 branches missed.">                if (r2.intersects(r1))</span>
                {
                    // adding difference ranges to fetch from a ring
<span class="nc" id="L5080">                    toFetch.addAll(r2.subtract(r1));</span>
<span class="nc" id="L5081">                    intersect = true;</span>
                }
<span class="nc" id="L5083">            }</span>
<span class="nc bnc" id="L5084" title="All 2 branches missed.">            if (!intersect)</span>
            {
<span class="nc" id="L5086">                toFetch.add(r2); // should fetch whole old range</span>
            }
<span class="nc" id="L5088">        }</span>

<span class="nc" id="L5090">        return Pair.create(toStream, toFetch);</span>
    }

    public void bulkLoad(String directory)
    {
        try
        {
<span class="nc" id="L5097">            bulkLoadInternal(directory).get();</span>
        }
<span class="nc" id="L5099">        catch (Exception e)</span>
        {
<span class="nc" id="L5101">            throw new RuntimeException(e);</span>
<span class="nc" id="L5102">        }</span>
<span class="nc" id="L5103">    }</span>

    public String bulkLoadAsync(String directory)
    {
<span class="nc" id="L5107">        return bulkLoadInternal(directory).planId.toString();</span>
    }

    private StreamResultFuture bulkLoadInternal(String directory)
    {
<span class="nc" id="L5112">        File dir = new File(directory);</span>

<span class="nc bnc" id="L5114" title="All 4 branches missed.">        if (!dir.exists() || !dir.isDirectory())</span>
<span class="nc" id="L5115">            throw new IllegalArgumentException(&quot;Invalid directory &quot; + directory);</span>

<span class="nc" id="L5117">        SSTableLoader.Client client = new SSTableLoader.Client()</span>
<span class="nc" id="L5118">        {</span>
            private String keyspace;

            public void init(String keyspace)
            {
<span class="nc" id="L5123">                this.keyspace = keyspace;</span>
                try
                {
<span class="nc bnc" id="L5126" title="All 2 branches missed.">                    for (Map.Entry&lt;Range&lt;Token&gt;, List&lt;InetAddress&gt;&gt; entry : StorageService.instance.getRangeToAddressMap(keyspace).entrySet())</span>
                    {
<span class="nc" id="L5128">                        Range&lt;Token&gt; range = entry.getKey();</span>
<span class="nc bnc" id="L5129" title="All 2 branches missed.">                        for (InetAddress endpoint : entry.getValue())</span>
<span class="nc" id="L5130">                            addRangeForEndpoint(range, endpoint);</span>
<span class="nc" id="L5131">                    }</span>
                }
<span class="nc" id="L5133">                catch (Exception e)</span>
                {
<span class="nc" id="L5135">                    throw new RuntimeException(e);</span>
<span class="nc" id="L5136">                }</span>
<span class="nc" id="L5137">            }</span>

            public CFMetaData getTableMetadata(String tableName)
            {
<span class="nc" id="L5141">                return Schema.instance.getCFMetaData(keyspace, tableName);</span>
            }
        };

<span class="nc" id="L5145">        return new SSTableLoader(dir, client, new OutputHandler.LogOutput()).stream();</span>
    }

    public void rescheduleFailedDeletions()
    {
<span class="nc" id="L5150">        LifecycleTransaction.rescheduleFailedDeletions();</span>
<span class="nc" id="L5151">    }</span>

    /**
     * #{@inheritDoc}
     */
    public void loadNewSSTables(String ksName, String cfName)
    {
<span class="nc bnc" id="L5158" title="All 2 branches missed.">        if (!isInitialized())</span>
<span class="nc" id="L5159">            throw new RuntimeException(&quot;Not yet initialized, can't load new sstables&quot;);</span>
<span class="nc" id="L5160">        ColumnFamilyStore.loadNewSSTables(ksName, cfName);</span>
<span class="nc" id="L5161">    }</span>

    /**
     * #{@inheritDoc}
     */
    public List&lt;String&gt; sampleKeyRange() // do not rename to getter - see CASSANDRA-4452 for details
    {
<span class="nc" id="L5168">        List&lt;DecoratedKey&gt; keys = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L5169" title="All 2 branches missed.">        for (Keyspace keyspace : Keyspace.nonLocalStrategy())</span>
        {
<span class="nc bnc" id="L5171" title="All 2 branches missed.">            for (Range&lt;Token&gt; range : getPrimaryRangesForEndpoint(keyspace.getName(), FBUtilities.getBroadcastAddress()))</span>
<span class="nc" id="L5172">                keys.addAll(keySamples(keyspace.getColumnFamilyStores(), range));</span>
<span class="nc" id="L5173">        }</span>

<span class="nc" id="L5175">        List&lt;String&gt; sampledKeys = new ArrayList&lt;&gt;(keys.size());</span>
<span class="nc bnc" id="L5176" title="All 2 branches missed.">        for (DecoratedKey key : keys)</span>
<span class="nc" id="L5177">            sampledKeys.add(key.getToken().toString());</span>
<span class="nc" id="L5178">        return sampledKeys;</span>
    }

    public void rebuildSecondaryIndex(String ksName, String cfName, String... idxNames)
    {
<span class="nc" id="L5183">        String[] indices = asList(idxNames).stream()</span>
<span class="nc bnc" id="L5184" title="All 2 branches missed.">                                           .map(p -&gt; isIndexColumnFamily(p) ? getIndexName(p) : p)</span>
<span class="nc" id="L5185">                                           .collect(toList())</span>
<span class="nc" id="L5186">                                           .toArray(new String[idxNames.length]);</span>

<span class="nc" id="L5188">        ColumnFamilyStore.rebuildSecondaryIndex(ksName, cfName, indices);</span>
<span class="nc" id="L5189">    }</span>

    public void resetLocalSchema() throws IOException
    {
<span class="nc" id="L5193">        MigrationManager.resetLocalSchema();</span>
<span class="nc" id="L5194">    }</span>

    public void reloadLocalSchema()
    {
<span class="nc" id="L5198">        SchemaKeyspace.reloadSchemaAndAnnounceVersion();</span>
<span class="nc" id="L5199">    }</span>

    public void setTraceProbability(double probability)
    {
<span class="nc" id="L5203">        this.traceProbability = probability;</span>
<span class="nc" id="L5204">    }</span>

    public double getTraceProbability()
    {
<span class="nc" id="L5208">        return traceProbability;</span>
    }

    public void disableAutoCompaction(String ks, String... tables) throws IOException
    {
<span class="nc bnc" id="L5213" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : getValidColumnFamilies(true, true, ks, tables))</span>
        {
<span class="nc" id="L5215">            cfs.disableAutoCompaction();</span>
<span class="nc" id="L5216">        }</span>
<span class="nc" id="L5217">    }</span>

    public synchronized void enableAutoCompaction(String ks, String... tables) throws IOException
    {
<span class="nc" id="L5221">        checkServiceAllowedToStart(&quot;auto compaction&quot;);</span>

<span class="nc bnc" id="L5223" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : getValidColumnFamilies(true, true, ks, tables))</span>
        {
<span class="nc" id="L5225">            cfs.enableAutoCompaction();</span>
<span class="nc" id="L5226">        }</span>
<span class="nc" id="L5227">    }</span>

    /** Returns the name of the cluster */
    public String getClusterName()
    {
<span class="nc" id="L5232">        return DatabaseDescriptor.getClusterName();</span>
    }

    /** Returns the cluster partitioner */
    public String getPartitionerName()
    {
<span class="nc" id="L5238">        return DatabaseDescriptor.getPartitionerName();</span>
    }

    public int getTombstoneWarnThreshold()
    {
<span class="nc" id="L5243">        return DatabaseDescriptor.getTombstoneWarnThreshold();</span>
    }

    public void setTombstoneWarnThreshold(int threshold)
    {
<span class="nc" id="L5248">        DatabaseDescriptor.setTombstoneWarnThreshold(threshold);</span>
<span class="nc" id="L5249">    }</span>

    public int getTombstoneFailureThreshold()
    {
<span class="nc" id="L5253">        return DatabaseDescriptor.getTombstoneFailureThreshold();</span>
    }

    public void setTombstoneFailureThreshold(int threshold)
    {
<span class="nc" id="L5258">        DatabaseDescriptor.setTombstoneFailureThreshold(threshold);</span>
<span class="nc" id="L5259">    }</span>

    public int getBatchSizeFailureThreshold()
    {
<span class="nc" id="L5263">        return DatabaseDescriptor.getBatchSizeFailThresholdInKB();</span>
    }

    public void setBatchSizeFailureThreshold(int threshold)
    {
<span class="nc" id="L5268">        DatabaseDescriptor.setBatchSizeFailThresholdInKB(threshold);</span>
<span class="nc" id="L5269">    }</span>

    public void setHintedHandoffThrottleInKB(int throttleInKB)
    {
<span class="nc" id="L5273">        DatabaseDescriptor.setHintedHandoffThrottleInKB(throttleInKB);</span>
<span class="nc" id="L5274">        logger.info(&quot;Updated hinted_handoff_throttle_in_kb to {}&quot;, throttleInKB);</span>
<span class="nc" id="L5275">    }</span>

    @VisibleForTesting
    public void shutdownServer()
    {
<span class="nc bnc" id="L5280" title="All 2 branches missed.">        if (drainOnShutdown != null)</span>
        {
<span class="nc" id="L5282">            Runtime.getRuntime().removeShutdownHook(drainOnShutdown);</span>
        }
<span class="nc" id="L5284">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>