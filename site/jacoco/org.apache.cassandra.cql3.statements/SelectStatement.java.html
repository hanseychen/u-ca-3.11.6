<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SelectStatement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.statements</a> &gt; <span class="el_source">SelectStatement.java</span></div><h1>SelectStatement.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.statements;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.SortedSet;

import com.google.common.base.MoreObjects;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.auth.Permission;
import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.ColumnDefinition;
import org.apache.cassandra.cql3.CFName;
import org.apache.cassandra.cql3.CQLStatement;
import org.apache.cassandra.cql3.ColumnIdentifier;
import org.apache.cassandra.cql3.ColumnSpecification;
import org.apache.cassandra.cql3.QueryOptions;
import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.cql3.ResultSet;
import org.apache.cassandra.cql3.SuperColumnCompatibility;
import org.apache.cassandra.cql3.Term;
import org.apache.cassandra.cql3.VariableSpecifications;
import org.apache.cassandra.cql3.WhereClause;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.cql3.restrictions.StatementRestrictions;
import org.apache.cassandra.cql3.selection.RawSelector;
import org.apache.cassandra.cql3.selection.Selection;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.aggregation.AggregationSpecification;
import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.DataRange;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.db.PartitionRangeReadCommand;
import org.apache.cassandra.db.ReadQuery;
import org.apache.cassandra.db.SinglePartitionReadCommand;
import org.apache.cassandra.db.Slice;
import org.apache.cassandra.db.Slices;
import org.apache.cassandra.db.filter.ClusteringIndexFilter;
import org.apache.cassandra.db.filter.ClusteringIndexNamesFilter;
import org.apache.cassandra.db.filter.ClusteringIndexSliceFilter;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.filter.DataLimits;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.db.marshal.CollectionType;
import org.apache.cassandra.db.marshal.CompositeType;
import org.apache.cassandra.db.marshal.Int32Type;
import org.apache.cassandra.db.marshal.UserType;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.rows.ComplexColumnData;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.RowIterator;
import org.apache.cassandra.db.view.View;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.exceptions.RequestExecutionException;
import org.apache.cassandra.exceptions.RequestValidationException;
import org.apache.cassandra.exceptions.UnauthorizedException;
import org.apache.cassandra.index.SecondaryIndexManager;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.ClientWarn;
import org.apache.cassandra.service.QueryState;
import org.apache.cassandra.service.pager.AggregationQueryPager;
import org.apache.cassandra.service.pager.PagingState;
import org.apache.cassandra.service.pager.QueryPager;
import org.apache.cassandra.thrift.ThriftValidation;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.transport.messages.ResultMessage;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.FBUtilities;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkNotNull;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkNull;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
import static org.apache.cassandra.utils.ByteBufferUtil.UNSET_BYTE_BUFFER;

/**
 * Encapsulates a completely parsed SELECT query, including the target
 * column family, expression, result count, and ordering clause.
 *
 * A number of public methods here are only used internally. However,
 * many of these are made accessible for the benefit of custom
 * QueryHandler implementations, so before reducing their accessibility
 * due consideration should be given.
 */
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">public class SelectStatement implements CQLStatement</span>
{
<span class="fc" id="L119">    private static final Logger logger = LoggerFactory.getLogger(SelectStatement.class);</span>

    public static final int DEFAULT_PAGE_SIZE = 10000;

    private final int boundTerms;
    public final CFMetaData cfm;
    public final Parameters parameters;
    private final Selection selection;
    private final Term limit;
    private final Term perPartitionLimit;

    private final StatementRestrictions restrictions;

    private final boolean isReversed;

    /**
     * The &lt;code&gt;AggregationSpecification&lt;/code&gt; used to make the aggregates.
     */
    private final AggregationSpecification aggregationSpec;

    /**
     * The comparator used to orders results when multiple keys are selected (using IN).
     */
    private final Comparator&lt;List&lt;ByteBuffer&gt;&gt; orderingComparator;

    private final ColumnFilter queriedColumns;

    // Used by forSelection below
<span class="fc" id="L147">    private static final Parameters defaultParameters = new Parameters(Collections.emptyMap(),</span>
<span class="fc" id="L148">                                                                       Collections.emptyList(),</span>
                                                                       false,
                                                                       false,
                                                                       false);

    public SelectStatement(CFMetaData cfm,
                           int boundTerms,
                           Parameters parameters,
                           Selection selection,
                           StatementRestrictions restrictions,
                           boolean isReversed,
                           AggregationSpecification aggregationSpec,
                           Comparator&lt;List&lt;ByteBuffer&gt;&gt; orderingComparator,
                           Term limit,
                           Term perPartitionLimit)
<span class="fc" id="L163">    {</span>
<span class="fc" id="L164">        this.cfm = cfm;</span>
<span class="fc" id="L165">        this.boundTerms = boundTerms;</span>
<span class="fc" id="L166">        this.selection = selection;</span>
<span class="fc" id="L167">        this.restrictions = restrictions;</span>
<span class="fc" id="L168">        this.isReversed = isReversed;</span>
<span class="fc" id="L169">        this.aggregationSpec = aggregationSpec;</span>
<span class="fc" id="L170">        this.orderingComparator = orderingComparator;</span>
<span class="fc" id="L171">        this.parameters = parameters;</span>
<span class="fc" id="L172">        this.limit = limit;</span>
<span class="fc" id="L173">        this.perPartitionLimit = perPartitionLimit;</span>
<span class="fc" id="L174">        this.queriedColumns = gatherQueriedColumns();</span>
<span class="fc" id="L175">    }</span>

    public Iterable&lt;Function&gt; getFunctions()
    {
<span class="fc" id="L179">        List&lt;Function&gt; functions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L180">        addFunctionsTo(functions);</span>
<span class="fc" id="L181">        return functions;</span>
    }

    private void addFunctionsTo(List&lt;Function&gt; functions)
    {
<span class="fc" id="L186">        selection.addFunctionsTo(functions);</span>
<span class="fc" id="L187">        restrictions.addFunctionsTo(functions);</span>

<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (limit != null)</span>
<span class="fc" id="L190">            limit.addFunctionsTo(functions);</span>

<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (perPartitionLimit != null)</span>
<span class="nc" id="L193">            perPartitionLimit.addFunctionsTo(functions);</span>
<span class="fc" id="L194">    }</span>

    // Note that the queried columns internally is different from the one selected by the
    // user as it also include any column for which we have a restriction on.
    private ColumnFilter gatherQueriedColumns()
    {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (selection.isWildcard())</span>
<span class="fc" id="L201">            return ColumnFilter.all(cfm);</span>

<span class="fc" id="L203">        ColumnFilter.Builder builder = ColumnFilter.allColumnsBuilder(cfm);</span>
        // Adds all selected columns
<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (ColumnDefinition def : selection.getColumns())</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (!def.isPrimaryKeyColumn())</span>
<span class="fc" id="L207">                builder.add(def);</span>
        // as well as any restricted column (so we can actually apply the restriction)
<span class="fc" id="L209">        builder.addAll(restrictions.nonPKRestrictedColumns(true));</span>
<span class="fc" id="L210">        return builder.build();</span>
    }

    /**
     * The columns to fetch internally for this SELECT statement (which can be more than the one selected by the
     * user as it also include any restricted column in particular).
     */
    public ColumnFilter queriedColumns()
    {
<span class="nc" id="L219">        return queriedColumns;</span>
    }

    // Creates a simple select based on the given selection.
    // Note that the results select statement should not be used for actual queries, but only for processing already
    // queried data through processColumnFamily.
    static SelectStatement forSelection(CFMetaData cfm, Selection selection)
    {
<span class="nc" id="L227">        return new SelectStatement(cfm,</span>
                                   0,
                                   defaultParameters,
                                   selection,
<span class="nc" id="L231">                                   StatementRestrictions.empty(StatementType.SELECT, cfm),</span>
                                   false,
                                   null,
                                   null,
                                   null,
                                   null);
    }

    public ResultSet.ResultMetadata getResultMetadata()
    {
<span class="fc" id="L241">        return selection.getResultMetadata(parameters.isJson);</span>
    }

    public int getBoundTerms()
    {
<span class="fc" id="L246">        return boundTerms;</span>
    }

    public void checkAccess(ClientState state) throws InvalidRequestException, UnauthorizedException
    {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        if (cfm.isView())</span>
        {
<span class="nc" id="L253">            CFMetaData baseTable = View.findBaseTable(keyspace(), columnFamily());</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (baseTable != null)</span>
<span class="nc" id="L255">                state.hasColumnFamilyAccess(baseTable, Permission.SELECT);</span>
<span class="nc" id="L256">        }</span>
        else
        {
<span class="fc" id="L259">            state.hasColumnFamilyAccess(cfm, Permission.SELECT);</span>
        }

<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        for (Function function : getFunctions())</span>
<span class="nc" id="L263">            state.ensureHasPermission(Permission.EXECUTE, function);</span>
<span class="fc" id="L264">    }</span>

    public void validate(ClientState state) throws InvalidRequestException
    {
        // Nothing to do, all validation has been done by RawStatement.prepare()
<span class="fc" id="L269">    }</span>

    public ResultMessage.Rows execute(QueryState state, QueryOptions options, long queryStartNanoTime) throws RequestExecutionException, RequestValidationException
    {
<span class="fc" id="L273">        ConsistencyLevel cl = options.getConsistency();</span>
<span class="fc" id="L274">        checkNotNull(cl, &quot;Invalid empty consistency level&quot;);</span>

<span class="fc" id="L276">        cl.validateForRead(keyspace());</span>

<span class="fc" id="L278">        int nowInSec = FBUtilities.nowInSeconds();</span>
<span class="fc" id="L279">        int userLimit = getLimit(options);</span>
<span class="fc" id="L280">        int userPerPartitionLimit = getPerPartitionLimit(options);</span>
<span class="fc" id="L281">        int pageSize = options.getPageSize();</span>
<span class="fc" id="L282">        ReadQuery query = getQuery(options, nowInSec, userLimit, userPerPartitionLimit, pageSize);</span>

<span class="pc bpc" id="L284" title="4 of 6 branches missed.">        if (aggregationSpec == null &amp;&amp; (pageSize &lt;= 0 || (query.limits().count() &lt;= pageSize)))</span>
<span class="fc" id="L285">            return execute(query, options, state, nowInSec, userLimit, queryStartNanoTime);</span>

<span class="nc" id="L287">        QueryPager pager = getPager(query, options);</span>

<span class="nc" id="L289">        return execute(Pager.forDistributedQuery(pager, cl, state.getClientState()), options, pageSize, nowInSec, userLimit, queryStartNanoTime);</span>
    }

    public ReadQuery getQuery(QueryOptions options, int nowInSec) throws RequestValidationException
    {
<span class="fc" id="L294">        return getQuery(options, nowInSec, getLimit(options), getPerPartitionLimit(options), options.getPageSize());</span>
    }

    public ReadQuery getQuery(QueryOptions options, int nowInSec, int userLimit, int perPartitionLimit, int pageSize)
    {
<span class="pc bpc" id="L299" title="1 of 4 branches missed.">        boolean isPartitionRangeQuery = restrictions.isKeyRange() || restrictions.usesSecondaryIndexing();</span>

<span class="fc" id="L301">        DataLimits limit = getDataLimits(userLimit, perPartitionLimit, pageSize);</span>

<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (isPartitionRangeQuery)</span>
<span class="fc" id="L304">            return getRangeCommand(options, limit, nowInSec);</span>

<span class="fc" id="L306">        return getSliceCommands(options, limit, nowInSec);</span>
    }

    private ResultMessage.Rows execute(ReadQuery query,
                                       QueryOptions options,
                                       QueryState state,
                                       int nowInSec,
                                       int userLimit, long queryStartNanoTime) throws RequestValidationException, RequestExecutionException
    {
<span class="fc" id="L315">        try (PartitionIterator data = query.execute(options.getConsistency(), state.getClientState(), queryStartNanoTime))</span>
        {
<span class="fc" id="L317">            return processResults(data, options, nowInSec, userLimit);</span>
        }
    }

    // Simple wrapper class to avoid some code duplication
    private static abstract class Pager
    {
        protected QueryPager pager;

        protected Pager(QueryPager pager)
<span class="nc" id="L327">        {</span>
<span class="nc" id="L328">            this.pager = pager;</span>
<span class="nc" id="L329">        }</span>

        public static Pager forInternalQuery(QueryPager pager, ReadExecutionController executionController)
        {
<span class="nc" id="L333">            return new InternalPager(pager, executionController);</span>
        }

        public static Pager forDistributedQuery(QueryPager pager, ConsistencyLevel consistency, ClientState clientState)
        {
<span class="nc" id="L338">            return new NormalPager(pager, consistency, clientState);</span>
        }

        public boolean isExhausted()
        {
<span class="nc" id="L343">            return pager.isExhausted();</span>
        }

        public PagingState state()
        {
<span class="nc" id="L348">            return pager.state();</span>
        }

        public abstract PartitionIterator fetchPage(int pageSize, long queryStartNanoTime);

        public static class NormalPager extends Pager
        {
            private final ConsistencyLevel consistency;
            private final ClientState clientState;

            private NormalPager(QueryPager pager, ConsistencyLevel consistency, ClientState clientState)
            {
<span class="nc" id="L360">                super(pager);</span>
<span class="nc" id="L361">                this.consistency = consistency;</span>
<span class="nc" id="L362">                this.clientState = clientState;</span>
<span class="nc" id="L363">            }</span>

            public PartitionIterator fetchPage(int pageSize, long queryStartNanoTime)
            {
<span class="nc" id="L367">                return pager.fetchPage(pageSize, consistency, clientState, queryStartNanoTime);</span>
            }
        }

        public static class InternalPager extends Pager
        {
            private final ReadExecutionController executionController;

            private InternalPager(QueryPager pager, ReadExecutionController executionController)
            {
<span class="nc" id="L377">                super(pager);</span>
<span class="nc" id="L378">                this.executionController = executionController;</span>
<span class="nc" id="L379">            }</span>

            public PartitionIterator fetchPage(int pageSize, long queryStartNanoTime)
            {
<span class="nc" id="L383">                return pager.fetchPageInternal(pageSize, executionController);</span>
            }
        }
    }

    private ResultMessage.Rows execute(Pager pager,
                                       QueryOptions options,
                                       int pageSize,
                                       int nowInSec,
                                       int userLimit,
                                       long queryStartNanoTime) throws RequestValidationException, RequestExecutionException
    {
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (aggregationSpec != null)</span>
        {
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (!restrictions.hasPartitionKeyRestrictions())</span>
            {
<span class="nc" id="L399">                warn(&quot;Aggregation query used without partition key&quot;);</span>
            }
<span class="nc bnc" id="L401" title="All 2 branches missed.">            else if (restrictions.keyIsInRelation())</span>
            {
<span class="nc" id="L403">                warn(&quot;Aggregation query used on multiple partition keys (IN restriction)&quot;);</span>
            }
        }

        // We can't properly do post-query ordering if we page (see #6722)
        // For GROUP BY or aggregation queries we always page internally even if the user has turned paging off
<span class="nc bnc" id="L409" title="All 4 branches missed.">        checkFalse(pageSize &gt; 0 &amp;&amp; needsPostQueryOrdering(),</span>
                  &quot;Cannot page queries with both ORDER BY and a IN restriction on the partition key;&quot;
                  + &quot; you must either remove the ORDER BY or the IN and sort client side, or disable paging for this query&quot;);

        ResultMessage.Rows msg;
<span class="nc" id="L414">        try (PartitionIterator page = pager.fetchPage(pageSize, queryStartNanoTime))</span>
        {
<span class="nc" id="L416">            msg = processResults(page, options, nowInSec, userLimit);</span>
        }

        // Please note that the isExhausted state of the pager only gets updated when we've closed the page, so this
        // shouldn't be moved inside the 'try' above.
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (!pager.isExhausted())</span>
<span class="nc" id="L422">            msg.result.metadata.setHasMorePages(pager.state());</span>

<span class="nc" id="L424">        return msg;</span>
    }

    private void warn(String msg)
    {
<span class="nc" id="L429">        logger.warn(msg);</span>
<span class="nc" id="L430">        ClientWarn.instance.warn(msg);</span>
<span class="nc" id="L431">    }</span>

    private ResultMessage.Rows processResults(PartitionIterator partitions,
                                              QueryOptions options,
                                              int nowInSec,
                                              int userLimit) throws RequestValidationException
    {
<span class="fc" id="L438">        ResultSet rset = process(partitions, options, nowInSec, userLimit);</span>
<span class="fc" id="L439">        return new ResultMessage.Rows(rset);</span>
    }

    public ResultMessage.Rows executeInternal(QueryState state, QueryOptions options) throws RequestExecutionException, RequestValidationException
    {
<span class="fc" id="L444">        return executeInternal(state, options, FBUtilities.nowInSeconds(), System.nanoTime());</span>
    }

    public ResultMessage.Rows executeInternal(QueryState state, QueryOptions options, int nowInSec, long queryStartNanoTime) throws RequestExecutionException, RequestValidationException
    {
<span class="fc" id="L449">        int userLimit = getLimit(options);</span>
<span class="fc" id="L450">        int userPerPartitionLimit = getPerPartitionLimit(options);</span>
<span class="fc" id="L451">        int pageSize = options.getPageSize();</span>
<span class="fc" id="L452">        ReadQuery query = getQuery(options, nowInSec, userLimit, userPerPartitionLimit, pageSize);</span>

<span class="fc" id="L454">        try (ReadExecutionController executionController = query.executionController())</span>
        {
<span class="pc bpc" id="L456" title="4 of 6 branches missed.">            if (aggregationSpec == null &amp;&amp; (pageSize &lt;= 0 || (query.limits().count() &lt;= pageSize)))</span>
            {
<span class="fc" id="L458">                try (PartitionIterator data = query.executeInternal(executionController))</span>
                {
<span class="fc" id="L460">                    return processResults(data, options, nowInSec, userLimit);</span>
                }
            }
            else
            {
<span class="nc" id="L465">                QueryPager pager = getPager(query, options);</span>

<span class="nc" id="L467">                return execute(Pager.forInternalQuery(pager, executionController), options, pageSize, nowInSec, userLimit, queryStartNanoTime);</span>
            }
        }
    }

    private QueryPager getPager(ReadQuery query, QueryOptions options)
    {
<span class="nc" id="L474">        QueryPager pager = query.getPager(options.getPagingState(), options.getProtocolVersion());</span>

<span class="nc bnc" id="L476" title="All 4 branches missed.">        if (aggregationSpec == null || query == ReadQuery.EMPTY)</span>
<span class="nc" id="L477">            return pager;</span>

<span class="nc" id="L479">        return new AggregationQueryPager(pager, query.limits());</span>
    }

    public ResultSet process(PartitionIterator partitions, int nowInSec) throws InvalidRequestException
    {
<span class="fc" id="L484">        return process(partitions, QueryOptions.DEFAULT, nowInSec, getLimit(QueryOptions.DEFAULT));</span>
    }

    public String keyspace()
    {
<span class="fc" id="L489">        return cfm.ksName;</span>
    }

    public String columnFamily()
    {
<span class="fc" id="L494">        return cfm.cfName;</span>
    }

    /**
     * May be used by custom QueryHandler implementations
     */
    public Selection getSelection()
    {
<span class="nc" id="L502">        return selection;</span>
    }

    /**
     * May be used by custom QueryHandler implementations
     */
    public StatementRestrictions getRestrictions()
    {
<span class="nc" id="L510">        return restrictions;</span>
    }

    private ReadQuery getSliceCommands(QueryOptions options, DataLimits limit, int nowInSec) throws RequestValidationException
    {
<span class="fc" id="L515">        Collection&lt;ByteBuffer&gt; keys = restrictions.getPartitionKeys(options);</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        if (keys.isEmpty())</span>
<span class="nc" id="L517">            return ReadQuery.EMPTY;</span>

<span class="fc" id="L519">        ClusteringIndexFilter filter = makeClusteringIndexFilter(options);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (filter == null)</span>
<span class="fc" id="L521">            return ReadQuery.EMPTY;</span>

<span class="fc" id="L523">        RowFilter rowFilter = getRowFilter(options);</span>

        // Note that we use the total limit for every key, which is potentially inefficient.
        // However, IN + LIMIT is not a very sensible choice.
<span class="fc" id="L527">        List&lt;SinglePartitionReadCommand&gt; commands = new ArrayList&lt;&gt;(keys.size());</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (ByteBuffer key : keys)</span>
        {
<span class="fc" id="L530">            QueryProcessor.validateKey(key);</span>
<span class="fc" id="L531">            DecoratedKey dk = cfm.decorateKey(ByteBufferUtil.clone(key));</span>
<span class="pc bpc" id="L532" title="3 of 4 branches missed.">            ColumnFilter cf = (cfm.isSuper() &amp;&amp; cfm.isDense()) ? SuperColumnCompatibility.getColumnFilter(cfm, options, restrictions.getSuperColumnRestrictions()) : queriedColumns;</span>
<span class="fc" id="L533">            commands.add(SinglePartitionReadCommand.create(cfm, nowInSec, cf, rowFilter, limit, dk, filter));</span>
<span class="fc" id="L534">        }</span>

<span class="fc" id="L536">        return new SinglePartitionReadCommand.Group(commands, limit);</span>
    }

    /**
     * Returns the slices fetched by this SELECT, assuming an internal call (no bound values in particular).
     * &lt;p&gt;
     * Note that if the SELECT intrinsically selects rows by names, we convert them into equivalent slices for
     * the purpose of this method. This is used for MVs to restrict what needs to be read when we want to read
     * everything that could be affected by a given view (and so, if the view SELECT statement has restrictions
     * on the clustering columns, we can restrict what we read).
     */
    public Slices clusteringIndexFilterAsSlices()
    {
<span class="nc" id="L549">        QueryOptions options = QueryOptions.forInternalCalls(Collections.emptyList());</span>
<span class="nc" id="L550">        ClusteringIndexFilter filter = makeClusteringIndexFilter(options);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (filter instanceof ClusteringIndexSliceFilter)</span>
<span class="nc" id="L552">            return ((ClusteringIndexSliceFilter)filter).requestedSlices();</span>

<span class="nc" id="L554">        Slices.Builder builder = new Slices.Builder(cfm.comparator);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">        for (Clustering clustering: ((ClusteringIndexNamesFilter)filter).requestedRows())</span>
<span class="nc" id="L556">            builder.add(Slice.make(clustering));</span>
<span class="nc" id="L557">        return builder.build();</span>
    }

    /**
     * Returns a read command that can be used internally to query all the rows queried by this SELECT for a
     * give key (used for materialized views).
     */
    public SinglePartitionReadCommand internalReadForView(DecoratedKey key, int nowInSec)
    {
<span class="nc" id="L566">        QueryOptions options = QueryOptions.forInternalCalls(Collections.emptyList());</span>
<span class="nc" id="L567">        ClusteringIndexFilter filter = makeClusteringIndexFilter(options);</span>
<span class="nc" id="L568">        RowFilter rowFilter = getRowFilter(options);</span>
<span class="nc" id="L569">        return SinglePartitionReadCommand.create(cfm, nowInSec, queriedColumns, rowFilter, DataLimits.NONE, key, filter);</span>
    }

    /**
     * The {@code RowFilter} for this SELECT, assuming an internal call (no bound values in particular).
     */
    public RowFilter rowFilterForInternalCalls()
    {
<span class="nc" id="L577">        return getRowFilter(QueryOptions.forInternalCalls(Collections.emptyList()));</span>
    }

    private ReadQuery getRangeCommand(QueryOptions options, DataLimits limit, int nowInSec) throws RequestValidationException
    {
<span class="fc" id="L582">        ClusteringIndexFilter clusteringIndexFilter = makeClusteringIndexFilter(options);</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (clusteringIndexFilter == null)</span>
<span class="nc" id="L584">            return ReadQuery.EMPTY;</span>

<span class="fc" id="L586">        RowFilter rowFilter = getRowFilter(options);</span>

        // The LIMIT provided by the user is the number of CQL row he wants returned.
        // We want to have getRangeSlice to count the number of columns, not the number of keys.
<span class="fc" id="L590">        AbstractBounds&lt;PartitionPosition&gt; keyBounds = restrictions.getPartitionKeyBounds(options);</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">        if (keyBounds == null)</span>
<span class="nc" id="L592">            return ReadQuery.EMPTY;</span>

<span class="fc" id="L594">        PartitionRangeReadCommand command =</span>
<span class="fc" id="L595">            PartitionRangeReadCommand.create(false, cfm, nowInSec, queriedColumns, rowFilter, limit, new DataRange(keyBounds, clusteringIndexFilter));</span>

        // If there's a secondary index that the command can use, have it validate the request parameters.
<span class="fc" id="L598">        command.maybeValidateIndex();</span>

<span class="fc" id="L600">        return command;</span>
    }

    private ClusteringIndexFilter makeClusteringIndexFilter(QueryOptions options)
    throws InvalidRequestException
    {
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">        if (parameters.isDistinct)</span>
        {
            // We need to be able to distinguish between partition having live rows and those that don't. But
            // doing so is not trivial since &quot;having a live row&quot; depends potentially on
            //   1) when the query is performed, due to TTLs
            //   2) how thing reconcile together between different nodes
            // so that it's hard to really optimize properly internally. So to keep it simple, we simply query
            // for the first row of the partition and hence uses Slices.ALL. We'll limit it to the first live
            // row however in getLimit().
<span class="nc" id="L615">            return new ClusteringIndexSliceFilter(Slices.ALL, false);</span>
        }

<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (restrictions.isColumnRange())</span>
        {
<span class="fc" id="L620">            Slices slices = makeSlices(options);</span>
<span class="pc bpc" id="L621" title="3 of 4 branches missed.">            if (slices == Slices.NONE &amp;&amp; !selection.containsStaticColumns())</span>
<span class="nc" id="L622">                return null;</span>

<span class="fc" id="L624">            return new ClusteringIndexSliceFilter(slices, isReversed);</span>
        }
        else
        {
<span class="fc" id="L628">            NavigableSet&lt;Clustering&gt; clusterings = getRequestedRows(options);</span>
            // We can have no clusterings if either we're only selecting the static columns, or if we have
            // a 'IN ()' for clusterings. In that case, we still want to query if some static columns are
            // queried. But we're fine otherwise.
<span class="fc bfc" id="L632" title="All 4 branches covered.">            if (clusterings.isEmpty() &amp;&amp; queriedColumns.fetchedColumns().statics.isEmpty())</span>
<span class="fc" id="L633">                return null;</span>

<span class="fc" id="L635">            return new ClusteringIndexNamesFilter(clusterings, isReversed);</span>
        }
    }

    private Slices makeSlices(QueryOptions options)
    throws InvalidRequestException
    {
<span class="fc" id="L642">        SortedSet&lt;ClusteringBound&gt; startBounds = restrictions.getClusteringColumnsBounds(Bound.START, options);</span>
<span class="fc" id="L643">        SortedSet&lt;ClusteringBound&gt; endBounds = restrictions.getClusteringColumnsBounds(Bound.END, options);</span>
<span class="pc bpc" id="L644" title="2 of 4 branches missed.">        assert startBounds.size() == endBounds.size();</span>

        // The case where startBounds == 1 is common enough that it's worth optimizing
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">        if (startBounds.size() == 1)</span>
        {
<span class="fc" id="L649">            ClusteringBound start = startBounds.first();</span>
<span class="fc" id="L650">            ClusteringBound end = endBounds.first();</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">            return cfm.comparator.compare(start, end) &gt; 0</span>
                 ? Slices.NONE
<span class="fc" id="L653">                 : Slices.with(cfm.comparator, Slice.make(start, end));</span>
        }

<span class="nc" id="L656">        Slices.Builder builder = new Slices.Builder(cfm.comparator, startBounds.size());</span>
<span class="nc" id="L657">        Iterator&lt;ClusteringBound&gt; startIter = startBounds.iterator();</span>
<span class="nc" id="L658">        Iterator&lt;ClusteringBound&gt; endIter = endBounds.iterator();</span>
<span class="nc bnc" id="L659" title="All 4 branches missed.">        while (startIter.hasNext() &amp;&amp; endIter.hasNext())</span>
        {
<span class="nc" id="L661">            ClusteringBound start = startIter.next();</span>
<span class="nc" id="L662">            ClusteringBound end = endIter.next();</span>

            // Ignore slices that are nonsensical
<span class="nc bnc" id="L665" title="All 2 branches missed.">            if (cfm.comparator.compare(start, end) &gt; 0)</span>
<span class="nc" id="L666">                continue;</span>

<span class="nc" id="L668">            builder.add(start, end);</span>
<span class="nc" id="L669">        }</span>

<span class="nc" id="L671">        return builder.build();</span>
    }

    private DataLimits getDataLimits(int userLimit, int perPartitionLimit, int pageSize)
    {
<span class="fc" id="L676">        int cqlRowLimit = DataLimits.NO_LIMIT;</span>
<span class="fc" id="L677">        int cqlPerPartitionLimit = DataLimits.NO_LIMIT;</span>

        // If we do post ordering we need to get all the results sorted before we can trim them.
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        if (aggregationSpec != AggregationSpecification.AGGREGATE_EVERYTHING)</span>
        {
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">            if (!needsPostQueryOrdering())</span>
<span class="fc" id="L683">                cqlRowLimit = userLimit;</span>
<span class="fc" id="L684">            cqlPerPartitionLimit = perPartitionLimit;</span>
        }

        // Group by and aggregation queries will always be paged internally to avoid OOM.
        // If the user provided a pageSize we'll use that to page internally (because why not), otherwise we use our default
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">        if (pageSize &lt;= 0)</span>
<span class="fc" id="L690">            pageSize = DEFAULT_PAGE_SIZE;</span>

        // Aggregation queries work fine on top of the group by paging but to maintain
        // backward compatibility we need to use the old way.
<span class="pc bpc" id="L694" title="3 of 4 branches missed.">        if (aggregationSpec != null &amp;&amp; aggregationSpec != AggregationSpecification.AGGREGATE_EVERYTHING)</span>
        {
<span class="nc bnc" id="L696" title="All 2 branches missed.">            if (parameters.isDistinct)</span>
<span class="nc" id="L697">                return DataLimits.distinctLimits(cqlRowLimit);</span>

<span class="nc" id="L699">            return DataLimits.groupByLimits(cqlRowLimit,</span>
                                            cqlPerPartitionLimit,
                                            pageSize,
                                            aggregationSpec);
        }

<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        if (parameters.isDistinct)</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            return cqlRowLimit == DataLimits.NO_LIMIT ? DataLimits.DISTINCT_NONE : DataLimits.distinctLimits(cqlRowLimit);</span>

<span class="fc" id="L708">        return DataLimits.cqlLimits(cqlRowLimit, cqlPerPartitionLimit);</span>
    }

    /**
     * Returns the limit specified by the user.
     * May be used by custom QueryHandler implementations
     *
     * @return the limit specified by the user or &lt;code&gt;DataLimits.NO_LIMIT&lt;/code&gt; if no value
     * as been specified.
     */
    public int getLimit(QueryOptions options)
    {
<span class="fc" id="L720">        return getLimit(limit, options);</span>
    }

    /**
     * Returns the per partition limit specified by the user.
     * May be used by custom QueryHandler implementations
     *
     * @return the per partition limit specified by the user or &lt;code&gt;DataLimits.NO_LIMIT&lt;/code&gt; if no value
     * as been specified.
     */
    public int getPerPartitionLimit(QueryOptions options)
    {
<span class="fc" id="L732">        return getLimit(perPartitionLimit, options);</span>
    }

    private int getLimit(Term limit, QueryOptions options)
    {
<span class="fc" id="L737">        int userLimit = DataLimits.NO_LIMIT;</span>

<span class="fc bfc" id="L739" title="All 2 branches covered.">        if (limit != null)</span>
        {
<span class="fc" id="L741">            ByteBuffer b = checkNotNull(limit.bindAndGet(options), &quot;Invalid null value of limit&quot;);</span>
            // treat UNSET limit value as 'unlimited'
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">            if (b != UNSET_BYTE_BUFFER)</span>
            {
                try
                {
<span class="fc" id="L747">                    Int32Type.instance.validate(b);</span>
<span class="fc" id="L748">                    userLimit = Int32Type.instance.compose(b);</span>
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">                    checkTrue(userLimit &gt; 0, &quot;LIMIT must be strictly positive&quot;);</span>
                }
<span class="nc" id="L751">                catch (MarshalException e)</span>
                {
<span class="nc" id="L753">                    throw new InvalidRequestException(&quot;Invalid limit value&quot;);</span>
<span class="fc" id="L754">                }</span>
            }
        }
<span class="fc" id="L757">        return userLimit;</span>
    }

    private NavigableSet&lt;Clustering&gt; getRequestedRows(QueryOptions options) throws InvalidRequestException
    {
        // Note: getRequestedColumns don't handle static columns, but due to CASSANDRA-5762
        // we always do a slice for CQL3 tables, so it's ok to ignore them here
<span class="pc bpc" id="L764" title="2 of 4 branches missed.">        assert !restrictions.isColumnRange();</span>
<span class="fc" id="L765">        return restrictions.getClusteringColumns(options);</span>
    }

    /**
     * May be used by custom QueryHandler implementations
     */
    public RowFilter getRowFilter(QueryOptions options) throws InvalidRequestException
    {
<span class="fc" id="L773">        ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(columnFamily());</span>
<span class="fc" id="L774">        SecondaryIndexManager secondaryIndexManager = cfs.indexManager;</span>
<span class="fc" id="L775">        RowFilter filter = restrictions.getRowFilter(secondaryIndexManager, options);</span>
<span class="fc" id="L776">        return filter;</span>
    }

    private ResultSet process(PartitionIterator partitions,
                              QueryOptions options,
                              int nowInSec,
                              int userLimit) throws InvalidRequestException
    {
<span class="fc" id="L784">        Selection.ResultSetBuilder result = selection.resultSetBuilder(options, parameters.isJson, aggregationSpec);</span>

<span class="fc bfc" id="L786" title="All 2 branches covered.">        while (partitions.hasNext())</span>
        {
<span class="fc" id="L788">            try (RowIterator partition = partitions.next())</span>
            {
<span class="fc" id="L790">                processPartition(partition, options, result, nowInSec);</span>
<span class="fc" id="L791">            }</span>
        }

<span class="fc" id="L794">        ResultSet cqlRows = result.build();</span>

<span class="fc" id="L796">        orderResults(cqlRows);</span>

<span class="fc" id="L798">        cqlRows.trim(userLimit);</span>

<span class="fc" id="L800">        return cqlRows;</span>
    }

    public static ByteBuffer[] getComponents(CFMetaData cfm, DecoratedKey dk)
    {
<span class="fc" id="L805">        ByteBuffer key = dk.getKey();</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">        if (cfm.getKeyValidator() instanceof CompositeType)</span>
        {
<span class="nc" id="L808">            return ((CompositeType)cfm.getKeyValidator()).split(key);</span>
        }
        else
        {
<span class="fc" id="L812">            return new ByteBuffer[]{ key };</span>
        }
    }

    // Used by ModificationStatement for CAS operations
    void processPartition(RowIterator partition, QueryOptions options, Selection.ResultSetBuilder result, int nowInSec)
    throws InvalidRequestException
    {
<span class="pc bpc" id="L820" title="3 of 4 branches missed.">        if (cfm.isSuper() &amp;&amp; cfm.isDense())</span>
        {
<span class="nc" id="L822">            SuperColumnCompatibility.processPartition(cfm, selection, partition, result, options.getProtocolVersion(), restrictions.getSuperColumnRestrictions(), options);</span>
<span class="nc" id="L823">            return;</span>
        }

<span class="fc" id="L826">        ProtocolVersion protocolVersion = options.getProtocolVersion();</span>

<span class="fc" id="L828">        ByteBuffer[] keyComponents = getComponents(cfm, partition.partitionKey());</span>

<span class="fc" id="L830">        Row staticRow = partition.staticRow();</span>
        // If there is no rows, and there's no restriction on clustering/regular columns,
        // then provided the select was a full partition selection (either by partition key and/or by static column),
        // we want to include static columns and we're done.
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">        if (!partition.hasNext())</span>
        {
<span class="nc bnc" id="L836" title="All 6 branches missed.">            if (!staticRow.isEmpty() &amp;&amp; (queriesFullPartitions() || cfm.isStaticCompactTable()))</span>
            {
<span class="nc" id="L838">                result.newRow(partition.partitionKey(), staticRow.clustering());</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">                for (ColumnDefinition def : selection.getColumns())</span>
                {
<span class="nc bnc" id="L841" title="All 3 branches missed.">                    switch (def.kind)</span>
                    {
                        case PARTITION_KEY:
<span class="nc" id="L844">                            result.add(keyComponents[def.position()]);</span>
<span class="nc" id="L845">                            break;</span>
                        case STATIC:
<span class="nc" id="L847">                            addValue(result, def, staticRow, nowInSec, protocolVersion);</span>
<span class="nc" id="L848">                            break;</span>
                        default:
<span class="nc" id="L850">                            result.add((ByteBuffer)null);</span>
                    }
<span class="nc" id="L852">                }</span>
            }
<span class="nc" id="L854">            return;</span>
        }

<span class="fc bfc" id="L857" title="All 2 branches covered.">        while (partition.hasNext())</span>
        {
<span class="fc" id="L859">            Row row = partition.next();</span>
<span class="fc" id="L860">            result.newRow( partition.partitionKey(), row.clustering());</span>
            // Respect selection order
<span class="fc bfc" id="L862" title="All 2 branches covered.">            for (ColumnDefinition def : selection.getColumns())</span>
            {
<span class="pc bpc" id="L864" title="2 of 5 branches missed.">                switch (def.kind)</span>
                {
                    case PARTITION_KEY:
<span class="fc" id="L867">                        result.add(keyComponents[def.position()]);</span>
<span class="fc" id="L868">                        break;</span>
                    case CLUSTERING:
<span class="fc" id="L870">                        result.add(row.clustering().get(def.position()));</span>
<span class="fc" id="L871">                        break;</span>
                    case REGULAR:
<span class="fc" id="L873">                        addValue(result, def, row, nowInSec, protocolVersion);</span>
<span class="fc" id="L874">                        break;</span>
                    case STATIC:
<span class="nc" id="L876">                        addValue(result, def, staticRow, nowInSec, protocolVersion);</span>
                        break;
                }
<span class="fc" id="L879">            }</span>
<span class="fc" id="L880">        }</span>
<span class="fc" id="L881">    }</span>

    /**
     * Checks if the query is a full partitions selection.
     * @return {@code true} if the query is a full partitions selection, {@code false} otherwise.
     */
    private boolean queriesFullPartitions()
    {
<span class="nc bnc" id="L889" title="All 4 branches missed.">        return !restrictions.hasClusteringColumnsRestrictions() &amp;&amp; !restrictions.hasRegularColumnsRestrictions();</span>
    }

    private static void addValue(Selection.ResultSetBuilder result, ColumnDefinition def, Row row, int nowInSec, ProtocolVersion protocolVersion)
    {
<span class="fc bfc" id="L894" title="All 2 branches covered.">        if (def.isComplex())</span>
        {
<span class="pc bpc" id="L896" title="2 of 4 branches missed.">            assert def.type.isMultiCell();</span>
<span class="fc" id="L897">            ComplexColumnData complexData = row.getComplexColumnData(def);</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">            if (complexData == null)</span>
<span class="fc" id="L899">                result.add(null);</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">            else if (def.type.isCollection())</span>
<span class="fc" id="L901">                result.add(((CollectionType) def.type).serializeForNativeProtocol(complexData.iterator(), protocolVersion));</span>
            else
<span class="nc" id="L903">                result.add(((UserType) def.type).serializeForNativeProtocol(complexData.iterator(), protocolVersion));</span>
<span class="fc" id="L904">        }</span>
        else
        {
<span class="fc" id="L907">            result.add(row.getCell(def), nowInSec);</span>
        }
<span class="fc" id="L909">    }</span>

    private boolean needsPostQueryOrdering()
    {
        // We need post-query ordering only for queries with IN on the partition key and an ORDER BY.
<span class="pc bpc" id="L914" title="1 of 4 branches missed.">        return restrictions.keyIsInRelation() &amp;&amp; !parameters.orderings.isEmpty();</span>
    }

    /**
     * Orders results when multiple keys are selected (using IN)
     */
    private void orderResults(ResultSet cqlRows)
    {
<span class="pc bpc" id="L922" title="1 of 4 branches missed.">        if (cqlRows.size() == 0 || !needsPostQueryOrdering())</span>
<span class="fc" id="L923">            return;</span>

<span class="nc" id="L925">        Collections.sort(cqlRows.rows, orderingComparator);</span>
<span class="nc" id="L926">    }</span>

<span class="pc bpc" id="L928" title="1 of 2 branches missed.">    public static class RawStatement extends CFStatement</span>
    {
        public final Parameters parameters;
        public final List&lt;RawSelector&gt; selectClause;
        public final WhereClause whereClause;
        public final Term.Raw limit;
        public final Term.Raw perPartitionLimit;

        public RawStatement(CFName cfName, Parameters parameters,
                            List&lt;RawSelector&gt; selectClause,
                            WhereClause whereClause,
                            Term.Raw limit,
                            Term.Raw perPartitionLimit)
        {
<span class="fc" id="L942">            super(cfName);</span>
<span class="fc" id="L943">            this.parameters = parameters;</span>
<span class="fc" id="L944">            this.selectClause = selectClause;</span>
<span class="fc" id="L945">            this.whereClause = whereClause;</span>
<span class="fc" id="L946">            this.limit = limit;</span>
<span class="fc" id="L947">            this.perPartitionLimit = perPartitionLimit;</span>
<span class="fc" id="L948">        }</span>

        public ParsedStatement.Prepared prepare(ClientState clientState) throws InvalidRequestException
        {
<span class="fc" id="L952">            return prepare(false, clientState);</span>
        }

        public ParsedStatement.Prepared prepare(boolean forView, ClientState clientState) throws InvalidRequestException
        {
<span class="fc" id="L957">            CFMetaData cfm = ThriftValidation.validateColumnFamilyWithCompactMode(keyspace(), columnFamily(), clientState.isNoCompactMode());</span>
<span class="fc" id="L958">            VariableSpecifications boundNames = getBoundVariables();</span>

<span class="fc" id="L960">            Selection selection = prepareSelection(cfm, boundNames);</span>

<span class="fc" id="L962">            StatementRestrictions restrictions = prepareRestrictions(cfm, boundNames, selection, forView);</span>

<span class="pc bpc" id="L964" title="1 of 2 branches missed.">            if (parameters.isDistinct)</span>
            {
<span class="nc" id="L966">                checkNull(perPartitionLimit, &quot;PER PARTITION LIMIT is not allowed with SELECT DISTINCT queries&quot;);</span>
<span class="nc" id="L967">                validateDistinctSelection(cfm, selection, restrictions);</span>
            }

<span class="fc" id="L970">            AggregationSpecification aggregationSpec = getAggregationSpecification(cfm,</span>
                                                                                   selection,
                                                                                   restrictions,
                                                                                   parameters.isDistinct);

<span class="pc bpc" id="L975" title="3 of 4 branches missed.">            checkFalse(aggregationSpec == AggregationSpecification.AGGREGATE_EVERYTHING &amp;&amp; perPartitionLimit != null,</span>
                       &quot;PER PARTITION LIMIT is not allowed with aggregate queries.&quot;);

<span class="fc" id="L978">            Comparator&lt;List&lt;ByteBuffer&gt;&gt; orderingComparator = null;</span>
<span class="fc" id="L979">            boolean isReversed = false;</span>

<span class="pc bpc" id="L981" title="1 of 2 branches missed.">            if (!parameters.orderings.isEmpty())</span>
            {
<span class="nc bnc" id="L983" title="All 4 branches missed.">                assert !forView;</span>
<span class="nc" id="L984">                verifyOrderingIsAllowed(restrictions);</span>
<span class="nc" id="L985">                orderingComparator = getOrderingComparator(cfm, selection, restrictions, parameters.isJson);</span>
<span class="nc" id="L986">                isReversed = isReversed(cfm);</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">                if (isReversed)</span>
<span class="nc" id="L988">                    orderingComparator = Collections.reverseOrder(orderingComparator);</span>
            }

<span class="fc" id="L991">            checkNeedsFiltering(restrictions);</span>

<span class="fc" id="L993">            SelectStatement stmt = new SelectStatement(cfm,</span>
<span class="fc" id="L994">                                                       boundNames.size(),</span>
                                                       parameters,
                                                       selection,
                                                       restrictions,
                                                       isReversed,
                                                       aggregationSpec,
                                                       orderingComparator,
<span class="fc" id="L1001">                                                       prepareLimit(boundNames, limit, keyspace(), limitReceiver()),</span>
<span class="fc" id="L1002">                                                       prepareLimit(boundNames, perPartitionLimit, keyspace(), perPartitionLimitReceiver()));</span>

<span class="fc" id="L1004">            return new ParsedStatement.Prepared(stmt, boundNames, boundNames.getPartitionKeyBindIndexes(cfm));</span>
        }

        /**
         * Prepares the selection to use for the statement.
         *
         * @param cfm the table metadata
         * @param boundNames the bound names
         * @return the selection to use for the statement
         */
        private Selection prepareSelection(CFMetaData cfm, VariableSpecifications boundNames)
        {
<span class="pc bpc" id="L1016" title="1 of 2 branches missed.">            boolean hasGroupBy = !parameters.groups.isEmpty();</span>

<span class="fc bfc" id="L1018" title="All 2 branches covered.">            if (selectClause.isEmpty())</span>
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">                return hasGroupBy ? Selection.wildcardWithGroupBy(cfm, boundNames) : Selection.wildcard(cfm);</span>

<span class="fc" id="L1021">            return Selection.fromSelectors(cfm, selectClause, boundNames, hasGroupBy);</span>
        }

        /**
         * Prepares the restrictions.
         *
         * @param cfm the column family meta data
         * @param boundNames the variable specifications
         * @param selection the selection
         * @return the restrictions
         * @throws InvalidRequestException if a problem occurs while building the restrictions
         */
        private StatementRestrictions prepareRestrictions(CFMetaData cfm,
                                                          VariableSpecifications boundNames,
                                                          Selection selection,
                                                          boolean forView) throws InvalidRequestException
        {
<span class="fc" id="L1038">            return new StatementRestrictions(StatementType.SELECT,</span>
                                             cfm,
                                             whereClause,
                                             boundNames,
<span class="fc" id="L1042">                                             selection.containsOnlyStaticColumns(),</span>
<span class="fc" id="L1043">                                             selection.containsAComplexColumn(),</span>
                                             parameters.allowFiltering,
                                             forView);
        }

        /** Returns a Term for the limit or null if no limit is set */
        private Term prepareLimit(VariableSpecifications boundNames, Term.Raw limit,
                                  String keyspace, ColumnSpecification limitReceiver) throws InvalidRequestException
        {
<span class="fc bfc" id="L1052" title="All 2 branches covered.">            if (limit == null)</span>
<span class="fc" id="L1053">                return null;</span>

<span class="fc" id="L1055">            Term prepLimit = limit.prepare(keyspace, limitReceiver);</span>
<span class="fc" id="L1056">            prepLimit.collectMarkerSpecification(boundNames);</span>
<span class="fc" id="L1057">            return prepLimit;</span>
        }

        private static void verifyOrderingIsAllowed(StatementRestrictions restrictions) throws InvalidRequestException
        {
<span class="nc" id="L1062">            checkFalse(restrictions.usesSecondaryIndexing(), &quot;ORDER BY with 2ndary indexes is not supported.&quot;);</span>
<span class="nc" id="L1063">            checkFalse(restrictions.isKeyRange(), &quot;ORDER BY is only supported when the partition key is restricted by an EQ or an IN.&quot;);</span>
<span class="nc" id="L1064">        }</span>

        private static void validateDistinctSelection(CFMetaData cfm,
                                                      Selection selection,
                                                      StatementRestrictions restrictions)
                                                      throws InvalidRequestException
        {
<span class="nc bnc" id="L1071" title="All 2 branches missed.">            checkFalse(restrictions.hasClusteringColumnsRestrictions() ||</span>
<span class="nc bnc" id="L1072" title="All 4 branches missed.">                       (restrictions.hasNonPrimaryKeyRestrictions() &amp;&amp; !restrictions.nonPKRestrictedColumns(true).stream().allMatch(ColumnDefinition::isStatic)),</span>
                       &quot;SELECT DISTINCT with WHERE clause only supports restriction by partition key and/or static columns.&quot;);

<span class="nc" id="L1075">            Collection&lt;ColumnDefinition&gt; requestedColumns = selection.getColumns();</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">            for (ColumnDefinition def : requestedColumns)</span>
<span class="nc bnc" id="L1077" title="All 4 branches missed.">                checkFalse(!def.isPartitionKey() &amp;&amp; !def.isStatic(),</span>
                           &quot;SELECT DISTINCT queries must only request partition key columns and/or static columns (not %s)&quot;,
                           def.name);

            // If it's a key range, we require that all partition key columns are selected so we don't have to bother
            // with post-query grouping.
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            if (!restrictions.isKeyRange())</span>
<span class="nc" id="L1084">                return;</span>

<span class="nc bnc" id="L1086" title="All 2 branches missed.">            for (ColumnDefinition def : cfm.partitionKeyColumns())</span>
<span class="nc" id="L1087">                checkTrue(requestedColumns.contains(def),</span>
                          &quot;SELECT DISTINCT queries must request all the partition key columns (missing %s)&quot;, def.name);
<span class="nc" id="L1089">        }</span>

        /**
         * Creates the &lt;code&gt;AggregationSpecification&lt;/code&gt;s used to make the aggregates.
         *
         * @param cfm the column family metadata
         * @param selection the selection
         * @param restrictions the restrictions
         * @param isDistinct &lt;code&gt;true&lt;/code&gt; if the query is a DISTINCT one. 
         * @return the &lt;code&gt;AggregationSpecification&lt;/code&gt;s used to make the aggregates
         */
        private AggregationSpecification getAggregationSpecification(CFMetaData cfm,
                                                                     Selection selection,
                                                                     StatementRestrictions restrictions,
                                                                     boolean isDistinct)
        {
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">            if (parameters.groups.isEmpty())</span>
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">                return selection.isAggregate() ? AggregationSpecification.AGGREGATE_EVERYTHING</span>
                                               : null;

<span class="nc" id="L1109">            int clusteringPrefixSize = 0;</span>

<span class="nc" id="L1111">            Iterator&lt;ColumnDefinition&gt; pkColumns = cfm.primaryKeyColumns().iterator();</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">            for (ColumnDefinition.Raw raw : parameters.groups)</span>
            {
<span class="nc" id="L1114">                ColumnDefinition def = raw.prepare(cfm);</span>

<span class="nc bnc" id="L1116" title="All 4 branches missed.">                checkTrue(def.isPartitionKey() || def.isClusteringColumn(),</span>
                          &quot;Group by is currently only supported on the columns of the PRIMARY KEY, got %s&quot;, def.name);

                while (true)
                {
<span class="nc" id="L1121">                    checkTrue(pkColumns.hasNext(),</span>
                              &quot;Group by currently only support groups of columns following their declared order in the PRIMARY KEY&quot;);

<span class="nc" id="L1124">                    ColumnDefinition pkColumn = pkColumns.next();</span>

<span class="nc bnc" id="L1126" title="All 2 branches missed.">                    if (pkColumn.isClusteringColumn())</span>
<span class="nc" id="L1127">                        clusteringPrefixSize++;</span>

                    // As we do not support grouping on only part of the partition key, we only need to know
                    // which clustering columns need to be used to build the groups
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                    if (pkColumn.equals(def))</span>
<span class="nc" id="L1132">                        break;</span>

<span class="nc" id="L1134">                    checkTrue(restrictions.isColumnRestrictedByEq(pkColumn),</span>
                              &quot;Group by currently only support groups of columns following their declared order in the PRIMARY KEY&quot;);
<span class="nc" id="L1136">                }</span>
<span class="nc" id="L1137">            }</span>

<span class="nc bnc" id="L1139" title="All 4 branches missed.">            checkFalse(pkColumns.hasNext() &amp;&amp; pkColumns.next().isPartitionKey(),</span>
                       &quot;Group by is not supported on only a part of the partition key&quot;);

<span class="nc bnc" id="L1142" title="All 4 branches missed.">            checkFalse(clusteringPrefixSize &gt; 0 &amp;&amp; isDistinct,</span>
                       &quot;Grouping on clustering columns is not allowed for SELECT DISTINCT queries&quot;);

<span class="nc" id="L1145">            return AggregationSpecification.aggregatePkPrefix(cfm.comparator, clusteringPrefixSize);</span>
        }

        private Comparator&lt;List&lt;ByteBuffer&gt;&gt; getOrderingComparator(CFMetaData cfm,
                                                                   Selection selection,
                                                                   StatementRestrictions restrictions,
                                                                   boolean isJson)
                                                                   throws InvalidRequestException
        {
<span class="nc bnc" id="L1154" title="All 2 branches missed.">            if (!restrictions.keyIsInRelation())</span>
<span class="nc" id="L1155">                return null;</span>

<span class="nc" id="L1157">            Map&lt;ColumnDefinition, Integer&gt; orderingIndexes = getOrderingIndex(cfm, selection, isJson);</span>

<span class="nc" id="L1159">            List&lt;Integer&gt; idToSort = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L1160">            List&lt;Comparator&lt;ByteBuffer&gt;&gt; sorters = new ArrayList&lt;Comparator&lt;ByteBuffer&gt;&gt;();</span>

<span class="nc bnc" id="L1162" title="All 2 branches missed.">            for (ColumnDefinition.Raw raw : parameters.orderings.keySet())</span>
            {
<span class="nc" id="L1164">                ColumnDefinition orderingColumn = raw.prepare(cfm);</span>
<span class="nc" id="L1165">                idToSort.add(orderingIndexes.get(orderingColumn));</span>
<span class="nc" id="L1166">                sorters.add(orderingColumn.type);</span>
<span class="nc" id="L1167">            }</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">            return idToSort.size() == 1 ? new SingleColumnComparator(idToSort.get(0), sorters.get(0))</span>
                    : new CompositeComparator(sorters, idToSort);
        }

        private Map&lt;ColumnDefinition, Integer&gt; getOrderingIndex(CFMetaData cfm, Selection selection, boolean isJson)
                throws InvalidRequestException
        {
            // If we order post-query (see orderResults), the sorted column needs to be in the ResultSet for sorting,
            // even if we don't
            // ultimately ship them to the client (CASSANDRA-4911).
<span class="nc bnc" id="L1178" title="All 2 branches missed.">            for (ColumnDefinition.Raw raw : parameters.orderings.keySet())</span>
            {
<span class="nc" id="L1180">                final ColumnDefinition def = raw.prepare(cfm);</span>
<span class="nc" id="L1181">                selection.addColumnForOrdering(def);</span>
<span class="nc" id="L1182">            }</span>
<span class="nc" id="L1183">            return selection.getOrderingIndex(isJson);</span>
        }

        private boolean isReversed(CFMetaData cfm) throws InvalidRequestException
        {
<span class="nc" id="L1188">            Boolean[] reversedMap = new Boolean[cfm.clusteringColumns().size()];</span>
<span class="nc" id="L1189">            int i = 0;</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">            for (Map.Entry&lt;ColumnDefinition.Raw, Boolean&gt; entry : parameters.orderings.entrySet())</span>
            {
<span class="nc" id="L1192">                ColumnDefinition def = entry.getKey().prepare(cfm);</span>
<span class="nc" id="L1193">                boolean reversed = entry.getValue();</span>

<span class="nc" id="L1195">                checkTrue(def.isClusteringColumn(),</span>
                          &quot;Order by is currently only supported on the clustered columns of the PRIMARY KEY, got %s&quot;, def.name);

<span class="nc bnc" id="L1198" title="All 2 branches missed.">                checkTrue(i++ == def.position(),</span>
                          &quot;Order by currently only support the ordering of columns following their declared order in the PRIMARY KEY&quot;);

<span class="nc bnc" id="L1201" title="All 2 branches missed.">                reversedMap[def.position()] = (reversed != def.isReversedType());</span>
<span class="nc" id="L1202">            }</span>

            // Check that all boolean in reversedMap, if set, agrees
<span class="nc" id="L1205">            Boolean isReversed = null;</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">            for (Boolean b : reversedMap)</span>
            {
                // Column on which order is specified can be in any order
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                if (b == null)</span>
<span class="nc" id="L1210">                    continue;</span>

<span class="nc bnc" id="L1212" title="All 2 branches missed.">                if (isReversed == null)</span>
                {
<span class="nc" id="L1214">                    isReversed = b;</span>
<span class="nc" id="L1215">                    continue;</span>
                }
<span class="nc" id="L1217">                checkTrue(isReversed.equals(b), &quot;Unsupported order by relation&quot;);</span>
            }
<span class="nc bnc" id="L1219" title="All 4 branches missed.">            assert isReversed != null;</span>
<span class="nc" id="L1220">            return isReversed;</span>
        }

        /** If ALLOW FILTERING was not specified, this verifies that it is not needed */
        private void checkNeedsFiltering(StatementRestrictions restrictions) throws InvalidRequestException
        {
            // non-key-range non-indexed queries cannot involve filtering underneath
<span class="pc bpc" id="L1227" title="2 of 6 branches missed.">            if (!parameters.allowFiltering &amp;&amp; (restrictions.isKeyRange() || restrictions.usesSecondaryIndexing()))</span>
            {
                // We will potentially filter data if either:
                //  - Have more than one IndexExpression
                //  - Have no index expression and the row filter is not the identity
<span class="fc" id="L1232">                checkFalse(restrictions.needFiltering(), StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE);</span>
            }
<span class="fc" id="L1234">        }</span>

        private ColumnSpecification limitReceiver()
        {
<span class="fc" id="L1238">            return new ColumnSpecification(keyspace(), columnFamily(), new ColumnIdentifier(&quot;[limit]&quot;, true), Int32Type.instance);</span>
        }

        private ColumnSpecification perPartitionLimitReceiver()
        {
<span class="fc" id="L1243">            return new ColumnSpecification(keyspace(), columnFamily(), new ColumnIdentifier(&quot;[per_partition_limit]&quot;, true), Int32Type.instance);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L1249">            return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L1250">                              .add(&quot;name&quot;, cfName)</span>
<span class="nc" id="L1251">                              .add(&quot;selectClause&quot;, selectClause)</span>
<span class="nc" id="L1252">                              .add(&quot;whereClause&quot;, whereClause)</span>
<span class="nc" id="L1253">                              .add(&quot;isDistinct&quot;, parameters.isDistinct)</span>
<span class="nc" id="L1254">                              .toString();</span>
        }
    }

    public static class Parameters
    {
        // Public because CASSANDRA-9858
        public final Map&lt;ColumnDefinition.Raw, Boolean&gt; orderings;
        public final List&lt;ColumnDefinition.Raw&gt; groups;
        public final boolean isDistinct;
        public final boolean allowFiltering;
        public final boolean isJson;

        public Parameters(Map&lt;ColumnDefinition.Raw, Boolean&gt; orderings,
                          List&lt;ColumnDefinition.Raw&gt; groups,
                          boolean isDistinct,
                          boolean allowFiltering,
                          boolean isJson)
<span class="fc" id="L1272">        {</span>
<span class="fc" id="L1273">            this.orderings = orderings;</span>
<span class="fc" id="L1274">            this.groups = groups;</span>
<span class="fc" id="L1275">            this.isDistinct = isDistinct;</span>
<span class="fc" id="L1276">            this.allowFiltering = allowFiltering;</span>
<span class="fc" id="L1277">            this.isJson = isJson;</span>
<span class="fc" id="L1278">        }</span>
    }

    private static abstract class ColumnComparator&lt;T&gt; implements Comparator&lt;T&gt;
    {
        protected final int compare(Comparator&lt;ByteBuffer&gt; comparator, ByteBuffer aValue, ByteBuffer bValue)
        {
<span class="nc bnc" id="L1285" title="All 2 branches missed.">            if (aValue == null)</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">                return bValue == null ? 0 : -1;</span>

<span class="nc bnc" id="L1288" title="All 2 branches missed.">            return bValue == null ? 1 : comparator.compare(aValue, bValue);</span>
        }
    }

    /**
     * Used in orderResults(...) method when single 'ORDER BY' condition where given
     */
    private static class SingleColumnComparator extends ColumnComparator&lt;List&lt;ByteBuffer&gt;&gt;
    {
        private final int index;
        private final Comparator&lt;ByteBuffer&gt; comparator;

        public SingleColumnComparator(int columnIndex, Comparator&lt;ByteBuffer&gt; orderer)
<span class="nc" id="L1301">        {</span>
<span class="nc" id="L1302">            index = columnIndex;</span>
<span class="nc" id="L1303">            comparator = orderer;</span>
<span class="nc" id="L1304">        }</span>

        public int compare(List&lt;ByteBuffer&gt; a, List&lt;ByteBuffer&gt; b)
        {
<span class="nc" id="L1308">            return compare(comparator, a.get(index), b.get(index));</span>
        }
    }

    /**
     * Used in orderResults(...) method when multiple 'ORDER BY' conditions where given
     */
    private static class CompositeComparator extends ColumnComparator&lt;List&lt;ByteBuffer&gt;&gt;
    {
        private final List&lt;Comparator&lt;ByteBuffer&gt;&gt; orderTypes;
        private final List&lt;Integer&gt; positions;

        private CompositeComparator(List&lt;Comparator&lt;ByteBuffer&gt;&gt; orderTypes, List&lt;Integer&gt; positions)
<span class="nc" id="L1321">        {</span>
<span class="nc" id="L1322">            this.orderTypes = orderTypes;</span>
<span class="nc" id="L1323">            this.positions = positions;</span>
<span class="nc" id="L1324">        }</span>

        public int compare(List&lt;ByteBuffer&gt; a, List&lt;ByteBuffer&gt; b)
        {
<span class="nc bnc" id="L1328" title="All 2 branches missed.">            for (int i = 0; i &lt; positions.size(); i++)</span>
            {
<span class="nc" id="L1330">                Comparator&lt;ByteBuffer&gt; type = orderTypes.get(i);</span>
<span class="nc" id="L1331">                int columnPos = positions.get(i);</span>

<span class="nc" id="L1333">                int comparison = compare(type, a.get(columnPos), b.get(columnPos));</span>

<span class="nc bnc" id="L1335" title="All 2 branches missed.">                if (comparison != 0)</span>
<span class="nc" id="L1336">                    return comparison;</span>
            }

<span class="nc" id="L1339">            return 0;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>