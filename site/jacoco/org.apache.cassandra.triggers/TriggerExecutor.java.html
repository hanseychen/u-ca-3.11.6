<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TriggerExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.triggers</a> &gt; <span class="el_source">TriggerExecutor.java</span></div><h1>TriggerExecutor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cassandra.triggers;

import java.io.File;
import java.nio.ByteBuffer;
import java.util.*;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Maps;

import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.exceptions.CassandraException;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.schema.TriggerMetadata;
import org.apache.cassandra.schema.Triggers;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.Pair;

public class TriggerExecutor
{
<span class="fc" id="L43">    public static final TriggerExecutor instance = new TriggerExecutor();</span>

<span class="fc" id="L45">    private final Map&lt;String, ITrigger&gt; cachedTriggers = Maps.newConcurrentMap();</span>
<span class="fc" id="L46">    private final ClassLoader parent = Thread.currentThread().getContextClassLoader();</span>
    private volatile ClassLoader customClassLoader;

    private TriggerExecutor()
<span class="fc" id="L50">    {</span>
<span class="fc" id="L51">        reloadClasses();</span>
<span class="fc" id="L52">    }</span>

    /**
     * Reload the triggers which is already loaded, Invoking this will update
     * the class loader so new jars can be loaded.
     */
    public void reloadClasses()
    {
<span class="fc" id="L60">        File triggerDirectory = FBUtilities.cassandraTriggerDir();</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (triggerDirectory == null)</span>
<span class="fc" id="L62">            return;</span>
<span class="nc" id="L63">        customClassLoader = new CustomClassLoader(parent, triggerDirectory);</span>
<span class="nc" id="L64">        cachedTriggers.clear();</span>
<span class="nc" id="L65">    }</span>

    /**
     * Augment a partition update by executing triggers to generate an intermediate
     * set of mutations, then merging the update from each mutation with those
     * supplied. This is called from @{link org.apache.cassandra.service.StorageProxy#cas}
     * which is scoped for a single partition. For that reason, any mutations generated
     * by triggers are checked to ensure that they are for the same table and partition
     * key as the primary update; if not, InvalidRequestException is thrown. If no
     * additional mutations are generated, the original updates are returned unmodified.
     *
     * @param updates partition update to be applied, contains the merge of the original
     *                update and any generated mutations
     * @return the final update to be applied, the original update merged with any
     * additional  mutations generated by configured triggers
     * @throws InvalidRequestException if any mutation generated by a trigger does not
     * apply to the exact same partition as the initial update
     */
    public PartitionUpdate execute(PartitionUpdate updates) throws InvalidRequestException
    {
<span class="nc" id="L85">        List&lt;Mutation&gt; intermediate = executeInternal(updates);</span>
<span class="nc bnc" id="L86" title="All 4 branches missed.">        if (intermediate == null || intermediate.isEmpty())</span>
<span class="nc" id="L87">            return updates;</span>

<span class="nc" id="L89">        List&lt;PartitionUpdate&gt; augmented = validateForSinglePartition(updates.metadata().cfId,</span>
<span class="nc" id="L90">                                                                     updates.partitionKey(),</span>
                                                                     intermediate);
        // concatenate augmented and origin
<span class="nc" id="L93">        augmented.add(updates);</span>
<span class="nc" id="L94">        return PartitionUpdate.merge(augmented);</span>
    }

    /**
     * Takes a collection of mutations and possibly augments it by adding extra mutations
     * generated by configured triggers. If no additional mutations are created
     * this returns null, signalling to the caller that only the initial set of
     * mutations should be applied. If additional mutations &lt;i&gt;are&lt;/i&gt; generated,
     * the total set (i.e. the original plus the additional mutations) are applied
     * together in a logged batch. Should this not be possible because the initial
     * mutations contain counter updates, InvalidRequestException is thrown.
     *
     * @param mutations initial collection of mutations
     * @return augmented mutations. Either the union of the initial and additional
     * mutations or null if no additional mutations were generated
     * @throws InvalidRequestException if additional mutations were generated, but
     * the initial mutations contains counter updates
     */
    public Collection&lt;Mutation&gt; execute(Collection&lt;? extends IMutation&gt; mutations) throws InvalidRequestException
    {
<span class="fc" id="L114">        boolean hasCounters = false;</span>
<span class="fc" id="L115">        List&lt;Mutation&gt; augmentedMutations = null;</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">        for (IMutation mutation : mutations)</span>
        {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">            if (mutation instanceof CounterMutation)</span>
<span class="nc" id="L120">                hasCounters = true;</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">            for (PartitionUpdate upd : mutation.getPartitionUpdates())</span>
            {
<span class="fc" id="L124">                List&lt;Mutation&gt; augmentations = executeInternal(upd);</span>
<span class="pc bpc" id="L125" title="3 of 4 branches missed.">                if (augmentations == null || augmentations.isEmpty())</span>
<span class="nc" id="L126">                    continue;</span>

<span class="nc" id="L128">                validate(augmentations);</span>

<span class="nc bnc" id="L130" title="All 2 branches missed.">                if (augmentedMutations == null)</span>
<span class="nc" id="L131">                    augmentedMutations = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L132">                augmentedMutations.addAll(augmentations);</span>
<span class="nc" id="L133">            }</span>
<span class="fc" id="L134">        }</span>

<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (augmentedMutations == null)</span>
<span class="fc" id="L137">            return null;</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (hasCounters)</span>
<span class="nc" id="L140">            throw new InvalidRequestException(&quot;Counter mutations and trigger mutations cannot be applied together atomically.&quot;);</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L143">        Collection&lt;Mutation&gt; originalMutations = (Collection&lt;Mutation&gt;) mutations;</span>

<span class="nc" id="L145">        return mergeMutations(Iterables.concat(originalMutations, augmentedMutations));</span>
    }

    private Collection&lt;Mutation&gt; mergeMutations(Iterable&lt;Mutation&gt; mutations)
    {
<span class="nc" id="L150">        ListMultimap&lt;Pair&lt;String, ByteBuffer&gt;, Mutation&gt; groupedMutations = ArrayListMultimap.create();</span>

<span class="nc bnc" id="L152" title="All 2 branches missed.">        for (Mutation mutation : mutations)</span>
        {
<span class="nc" id="L154">            Pair&lt;String, ByteBuffer&gt; key = Pair.create(mutation.getKeyspaceName(), mutation.key().getKey());</span>
<span class="nc" id="L155">            groupedMutations.put(key, mutation);</span>
<span class="nc" id="L156">        }</span>

<span class="nc" id="L158">        List&lt;Mutation&gt; merged = new ArrayList&lt;&gt;(groupedMutations.size());</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (Pair&lt;String, ByteBuffer&gt; key : groupedMutations.keySet())</span>
<span class="nc" id="L160">            merged.add(Mutation.merge(groupedMutations.get(key)));</span>

<span class="nc" id="L162">        return merged;</span>
    }

    private List&lt;PartitionUpdate&gt; validateForSinglePartition(UUID cfId,
                                                                   DecoratedKey key,
                                                                   Collection&lt;Mutation&gt; tmutations)
    throws InvalidRequestException
    {
<span class="nc" id="L170">        validate(tmutations);</span>

<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (tmutations.size() == 1)</span>
        {
<span class="nc" id="L174">            List&lt;PartitionUpdate&gt; updates = Lists.newArrayList(Iterables.getOnlyElement(tmutations).getPartitionUpdates());</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (updates.size() &gt; 1)</span>
<span class="nc" id="L176">                throw new InvalidRequestException(&quot;The updates generated by triggers are not all for the same partition&quot;);</span>
<span class="nc" id="L177">            validateSamePartition(cfId, key, Iterables.getOnlyElement(updates));</span>
<span class="nc" id="L178">            return updates;</span>
        }

<span class="nc" id="L181">        ArrayList&lt;PartitionUpdate&gt; updates = new ArrayList&lt;&gt;(tmutations.size());</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        for (Mutation mutation : tmutations)</span>
        {
<span class="nc bnc" id="L184" title="All 2 branches missed.">            for (PartitionUpdate update : mutation.getPartitionUpdates())</span>
            {
<span class="nc" id="L186">                validateSamePartition(cfId, key, update);</span>
<span class="nc" id="L187">                updates.add(update);</span>
<span class="nc" id="L188">            }</span>
<span class="nc" id="L189">        }</span>
<span class="nc" id="L190">        return updates;</span>
    }

    private void validateSamePartition(UUID cfId, DecoratedKey key, PartitionUpdate update)
    throws InvalidRequestException
    {
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (!key.equals(update.partitionKey()))</span>
<span class="nc" id="L197">            throw new InvalidRequestException(&quot;Partition key of additional mutation does not match primary update key&quot;);</span>

<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (!cfId.equals(update.metadata().cfId))</span>
<span class="nc" id="L200">            throw new InvalidRequestException(&quot;table of additional mutation does not match primary update table&quot;);</span>
<span class="nc" id="L201">    }</span>

    private void validate(Collection&lt;Mutation&gt; tmutations) throws InvalidRequestException
    {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        for (Mutation mutation : tmutations)</span>
        {
<span class="nc" id="L207">            QueryProcessor.validateKey(mutation.key().getKey());</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">            for (PartitionUpdate update : mutation.getPartitionUpdates())</span>
<span class="nc" id="L209">                update.validate();</span>
<span class="nc" id="L210">        }</span>
<span class="nc" id="L211">    }</span>

    /**
     * Switch class loader before using the triggers for the column family, if
     * not loaded them with the custom class loader.
     */
    private List&lt;Mutation&gt; executeInternal(PartitionUpdate update)
    {
<span class="fc" id="L219">        Triggers triggers = update.metadata().getTriggers();</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (triggers.isEmpty())</span>
<span class="fc" id="L221">            return null;</span>
<span class="nc" id="L222">        List&lt;Mutation&gt; tmutations = Lists.newLinkedList();</span>
<span class="nc" id="L223">        Thread.currentThread().setContextClassLoader(customClassLoader);</span>
        try
        {
<span class="nc bnc" id="L226" title="All 2 branches missed.">            for (TriggerMetadata td : triggers)</span>
            {
<span class="nc" id="L228">                ITrigger trigger = cachedTriggers.get(td.classOption);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">                if (trigger == null)</span>
                {
<span class="nc" id="L231">                    trigger = loadTriggerInstance(td.classOption);</span>
<span class="nc" id="L232">                    cachedTriggers.put(td.classOption, trigger);</span>
                }
<span class="nc" id="L234">                Collection&lt;Mutation&gt; temp = trigger.augment(update);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                if (temp != null)</span>
<span class="nc" id="L236">                    tmutations.addAll(temp);</span>
<span class="nc" id="L237">            }</span>
<span class="nc" id="L238">            return tmutations;</span>
        }
<span class="nc" id="L240">        catch (CassandraException ex)</span>
        {
<span class="nc" id="L242">            throw ex;</span>
        }
<span class="nc" id="L244">        catch (Exception ex)</span>
        {
<span class="nc" id="L246">            throw new RuntimeException(String.format(&quot;Exception while executing trigger on table with ID: %s&quot;, update.metadata().cfId), ex);</span>
        }
        finally
        {
<span class="nc" id="L250">            Thread.currentThread().setContextClassLoader(parent);</span>
        }
    }

    public synchronized ITrigger loadTriggerInstance(String triggerName) throws Exception
    {
        // double check.
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (cachedTriggers.get(triggerName) != null)</span>
<span class="nc" id="L258">            return cachedTriggers.get(triggerName);</span>
<span class="nc" id="L259">        return (ITrigger) customClassLoader.loadClass(triggerName).getConstructor().newInstance();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>