<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Row.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.rows</a> &gt; <span class="el_source">Row.java</span></div><h1>Row.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.rows;

import java.util.*;
import java.security.MessageDigest;
import java.util.function.Consumer;

import com.google.common.base.Predicate;

import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.ColumnDefinition;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.service.paxos.Commit;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.MergeIterator;
import org.apache.cassandra.utils.SearchIterator;
import org.apache.cassandra.utils.btree.BTree;
import org.apache.cassandra.utils.btree.UpdateFunction;

/**
 * Storage engine representation of a row.
 *
 * A row mainly contains the following informations:
 *   1) Its {@code Clustering}, which holds the values for the clustering columns identifying the row.
 *   2) Its row level informations: the primary key liveness infos and the row deletion (see
 *      {@link #primaryKeyLivenessInfo()} and {@link #deletion()} for more details).
 *   3) Data for the columns it contains, or in other words, it's a (sorted) collection of
 *      {@code ColumnData}.
 *
 * Also note that as for every other storage engine object, a {@code Row} object cannot shadow
 * it's own data. For instance, a {@code Row} cannot contains a cell that is deleted by its own
 * row deletion.
 */
public interface Row extends Unfiltered, Iterable&lt;ColumnData&gt;
{
    /**
     * The clustering values for this row.
     */
    @Override
    public Clustering clustering();

    /**
     * An in-natural-order collection of the columns for which data (incl. simple tombstones)
     * is present in this row.
     */
    public Collection&lt;ColumnDefinition&gt; columns();


    /**
     * The number of columns for which data (incl. simple tombstones) is present in this row.
     */
    public int columnCount();

    /**
     * The row deletion.
     *
     * This correspond to the last row deletion done on this row.
     *
     * @return the row deletion.
     */
    public Deletion deletion();

    /**
     * Liveness information for the primary key columns of this row.
     * &lt;p&gt;
     * As a row is uniquely identified by its primary key, all its primary key columns
     * share the same {@code LivenessInfo}. This liveness information is what allows us
     * to distinguish between a dead row (it has no live cells and its primary key liveness
     * info is empty) and a live row but where all non PK columns are null (it has no
     * live cells, but its primary key liveness is not empty). Please note that the liveness
     * info (including it's eventually ttl/local deletion time) only apply to the primary key
     * columns and has no impact on the row content.
     * &lt;p&gt;
     * Note in particular that a row may have live cells but no PK liveness info, because the
     * primary key liveness informations are only set on {@code INSERT} (which makes sense
     * in itself, see #6782) but live cells can be added through {@code UPDATE} even if the row
     * wasn't pre-existing (which users are encouraged not to do, but we can't validate).
     */
    public LivenessInfo primaryKeyLivenessInfo();

    /**
     * Whether the row correspond to a static row or not.
     *
     * @return whether the row correspond to a static row or not.
     */
    public boolean isStatic();

    /**
     * Whether the row has no information whatsoever. This means no PK liveness info, no row
     * deletion, no cells and no complex deletion info.
     *
     * @return {@code true} if the row has no data, {@code false} otherwise.
     */
    public boolean isEmpty();

    /**
     * Whether the row has some live information (i.e. it's not just deletion informations).
     * 
     * @param nowInSec the current time to decide what is deleted and what isn't
     * @param enforceStrictLiveness whether the row should be purged if there is no PK liveness info,
     *                              normally retrieved from {@link CFMetaData#enforceStrictLiveness()}
     * @return true if there is some live information
     */
    public boolean hasLiveData(int nowInSec, boolean enforceStrictLiveness);

    /**
     * Returns a cell for a simple column.
     *
     * @param c the simple column for which to fetch the cell.
     * @return the corresponding cell or {@code null} if the row has no such cell.
     */
    public Cell getCell(ColumnDefinition c);

    /**
     * Return a cell for a given complex column and cell path.
     *
     * @param c the complex column for which to fetch the cell.
     * @param path the cell path for which to fetch the cell.
     * @return the corresponding cell or {@code null} if the row has no such cell.
     */
    public Cell getCell(ColumnDefinition c, CellPath path);

    /**
     * The data for a complex column.
     * &lt;p&gt;
     * The returned object groups all the cells for the column, as well as it's complex deletion (if relevant).
     *
     * @param c the complex column for which to return the complex data.
     * @return the data for {@code c} or {@code null} if the row has no data for this column.
     */
    public ComplexColumnData getComplexColumnData(ColumnDefinition c);

    /**
     * An iterable over the cells of this row.
     * &lt;p&gt;
     * The iterable guarantees that cells are returned in order of {@link Cell#comparator}.
     *
     * @return an iterable over the cells of this row.
     */
    public Iterable&lt;Cell&gt; cells();

    /**
     * A collection of the ColumnData representation of this row, for columns with some data (possibly not live) present
     * &lt;p&gt;
     * The data is returned in column order.
     *
     * @return a Collection of the non-empty ColumnData for this row.
     */
    public Collection&lt;ColumnData&gt; columnData();

    /**
     * An iterable over the cells of this row that return cells in &quot;legacy order&quot;.
     * &lt;p&gt;
     * In 3.0+, columns are sorted so that all simple columns are before all complex columns. Previously
     * however, the cells where just sorted by the column name. This iterator return cells in that
     * legacy order. It's only ever meaningful for backward/thrift compatibility code.
     *
     * @param metadata the table this is a row of.
     * @param reversed if cells should returned in reverse order.
     * @return an iterable over the cells of this row in &quot;legacy order&quot;.
     */
    public Iterable&lt;Cell&gt; cellsInLegacyOrder(CFMetaData metadata, boolean reversed);

    /**
     * Whether the row stores any (non-live) complex deletion for any complex column.
     */
    public boolean hasComplexDeletion();

    /**
     * Whether the row stores any (non-RT) data for any complex column.
     */
    boolean hasComplex();

    /**
     * Whether the row has any deletion info (row deletion, cell tombstone, expired cell or complex deletion).
     *
     * @param nowInSec the current time in seconds to decid if a cell is expired.
     */
    public boolean hasDeletion(int nowInSec);

    /**
     * An iterator to efficiently search data for a given column.
     *
     * @return a search iterator for the cells of this row.
     */
    public SearchIterator&lt;ColumnDefinition, ColumnData&gt; searchIterator();

    /**
     * Returns a copy of this row that:
     *   1) only includes the data for the column included by {@code filter}.
     *   2) doesn't include any data that belongs to a dropped column (recorded in {@code metadata}).
     */
    public Row filter(ColumnFilter filter, CFMetaData metadata);

    /**
     * Returns a copy of this row that:
     *   1) only includes the data for the column included by {@code filter}.
     *   2) doesn't include any data that belongs to a dropped column (recorded in {@code metadata}).
     *   3) doesn't include any data that is shadowed/deleted by {@code activeDeletion}.
     *   4) uses {@code activeDeletion} as row deletion iff {@code setActiveDeletionToRow} and {@code activeDeletion} supersedes the row deletion.
     */
    public Row filter(ColumnFilter filter, DeletionTime activeDeletion, boolean setActiveDeletionToRow, CFMetaData metadata);

    /**
     * Returns a copy of this row without any deletion info that should be purged according to {@code purger}.
     *
     * @param purger the {@code DeletionPurger} to use to decide what can be purged.
     * @param nowInSec the current time to decide what is deleted and what isn't (in the case of expired cells).
     * @param enforceStrictLiveness whether the row should be purged if there is no PK liveness info,
     *                              normally retrieved from {@link CFMetaData#enforceStrictLiveness()}
     *
     *        When enforceStrictLiveness is set, rows with empty PK liveness info
     *        and no row deletion are purged.
     *
     *        Currently this is only used by views with normal base column as PK column
     *        so updates to other base columns do not make the row live when the PK column
     *        is not live. See CASSANDRA-11500.
     *
     * @return this row but without any deletion info purged by {@code purger}. If the purged row is empty, returns
     * {@code null}.
     */
    public Row purge(DeletionPurger purger, int nowInSec, boolean enforceStrictLiveness);

    /**
     * Returns a copy of this row which only include the data queried by {@code filter}, excluding anything _fetched_ for
     * internal reasons but not queried by the user (see {@link ColumnFilter} for details).
     *
     * @param filter the {@code ColumnFilter} to use when deciding what is user queried. This should be the filter
     * that was used when querying the row on which this method is called.
     * @return the row but with all data that wasn't queried by the user skipped.
     */
    public Row withOnlyQueriedData(ColumnFilter filter);

    /**
     * Returns a copy of this row where all counter cells have they &quot;local&quot; shard marked for clearing.
     */
    public Row markCounterLocalToBeCleared();

    /**
     * Returns a copy of this row where all live timestamp have been replaced by {@code newTimestamp} and every deletion
     * timestamp by {@code newTimestamp - 1}.
     *
     * @param newTimestamp the timestamp to use for all live data in the returned row.
     *
     * @see Commit for why we need this.
     */
    public Row updateAllTimestamp(long newTimestamp);

    /**
     * Returns a copy of this row with the new deletion as row deletion if it is more recent
     * than the current row deletion.
     * &lt;p&gt;
     * WARNING: this method &lt;b&gt;does not&lt;/b&gt; check that nothing in the row is shadowed by the provided
     * deletion and if that is the case, the created row will be &lt;b&gt;invalid&lt;/b&gt;. It is thus up to the
     * caller to verify that this is not the case and the only reasonable use case of this is probably
     * when the row and the deletion comes from the same {@code UnfilteredRowIterator} since that gives
     * use this guarantee.
     */
    public Row withRowDeletion(DeletionTime deletion);

    public int dataSize();

    public long unsharedHeapSizeExcludingData();

    public String toString(CFMetaData metadata, boolean fullDetails);

    /**
     * Apply a function to every column in a row
     */
    public void apply(Consumer&lt;ColumnData&gt; function, boolean reverse);

    /**
     * Apply a funtion to every column in a row until a stop condition is reached
     */
    public void apply(Consumer&lt;ColumnData&gt; function, Predicate&lt;ColumnData&gt; stopCondition, boolean reverse);

    /**
     * A row deletion/tombstone.
     * &lt;p&gt;
     * A row deletion mostly consists of the time of said deletion, but there is 2 variants: shadowable
     * and regular row deletion.
     * &lt;p&gt;
     * A shadowable row deletion only exists if the row has no timestamp. In other words, the deletion is only
     * valid as long as no newer insert is done (thus setting a row timestamp; note that if the row timestamp set
     * is lower than the deletion, it is shadowed (and thus ignored) as usual).
     * &lt;p&gt;
     * That is, if a row has a shadowable deletion with timestamp A and an update is made to that row with a
     * timestamp B such that {@code B &gt; A} (and that update sets the row timestamp), then the shadowable deletion is 'shadowed'
     * by that update. A concrete consequence is that if said update has cells with timestamp lower than A, then those
     * cells are preserved(since the deletion is removed), and this is contrary to a normal (regular) deletion where the
     * deletion is preserved and such cells are removed.
     * &lt;p&gt;
     * Currently, the only use of shadowable row deletions is Materialized Views, see CASSANDRA-10261.
     */
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">    public static class Deletion</span>
    {
<span class="fc" id="L314">        public static final Deletion LIVE = new Deletion(DeletionTime.LIVE, false);</span>

        private final DeletionTime time;
        private final boolean isShadowable;

        public Deletion(DeletionTime time, boolean isShadowable)
<span class="fc" id="L320">        {</span>
<span class="pc bpc" id="L321" title="3 of 6 branches missed.">            assert !time.isLive() || !isShadowable;</span>
<span class="fc" id="L322">            this.time = time;</span>
<span class="fc" id="L323">            this.isShadowable = isShadowable;</span>
<span class="fc" id="L324">        }</span>

        public static Deletion regular(DeletionTime time)
        {
<span class="nc bnc" id="L328" title="All 2 branches missed.">            return time.isLive() ? LIVE : new Deletion(time, false);</span>
        }

        @Deprecated
        public static Deletion shadowable(DeletionTime time)
        {
<span class="nc" id="L334">            return new Deletion(time, true);</span>
        }

        /**
         * The time of the row deletion.
         *
         * @return the time of the row deletion.
         */
        public DeletionTime time()
        {
<span class="fc" id="L344">            return time;</span>
        }

        /**
         * Whether the deletion is a shadowable one or not.
         *
         * @return whether the deletion is a shadowable one. Note that if {@code isLive()}, then this is
         * guarantee to return {@code false}.
         */
        public boolean isShadowable()
        {
<span class="fc" id="L355">            return isShadowable;</span>
        }

        /**
         * Wether the deletion is live or not, that is if its an actual deletion or not.
         *
         * @return {@code true} if this represents no deletion of the row, {@code false} if that's an actual
         * deletion.
         */
        public boolean isLive()
        {
<span class="fc" id="L366">            return time().isLive();</span>
        }

        public boolean supersedes(DeletionTime that)
        {
<span class="fc" id="L371">            return time.supersedes(that);</span>
        }

        public boolean supersedes(Deletion that)
        {
<span class="fc" id="L376">            return time.supersedes(that.time);</span>
        }

        public boolean isShadowedBy(LivenessInfo primaryKeyLivenessInfo)
        {
<span class="pc bpc" id="L381" title="3 of 4 branches missed.">            return isShadowable &amp;&amp; primaryKeyLivenessInfo.timestamp() &gt; time.markedForDeleteAt();</span>
        }

        public boolean deletes(LivenessInfo info)
        {
<span class="fc" id="L386">            return time.deletes(info);</span>
        }

        public boolean deletes(Cell cell)
        {
<span class="fc" id="L391">            return time.deletes(cell);</span>
        }

        public void digest(MessageDigest digest)
        {
<span class="fc" id="L396">            time.digest(digest);</span>
<span class="fc" id="L397">            FBUtilities.updateWithBoolean(digest, isShadowable);</span>
<span class="fc" id="L398">        }</span>

        public int dataSize()
        {
<span class="fc" id="L402">            return time.dataSize() + 1;</span>
        }

        @Override
        public boolean equals(Object o)
        {
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if(!(o instanceof Deletion))</span>
<span class="nc" id="L409">                return false;</span>
<span class="nc" id="L410">            Deletion that = (Deletion)o;</span>
<span class="nc bnc" id="L411" title="All 4 branches missed.">            return this.time.equals(that.time) &amp;&amp; this.isShadowable == that.isShadowable;</span>
        }

        @Override
        public final int hashCode()
        {
<span class="nc" id="L417">            return Objects.hash(time, isShadowable);</span>
        }

        @Override
        public String toString()
        {
<span class="nc bnc" id="L423" title="All 2 branches missed.">            return String.format(&quot;%s%s&quot;, time, isShadowable ? &quot;(shadowable)&quot; : &quot;&quot;);</span>
        }
    }

    /**
     * Interface for building rows.
     * &lt;p&gt;
     * The builder of a row should always abid to the following rules:
     *   1) {@link #newRow} is always called as the first thing for the row.
     *   2) {@link #addPrimaryKeyLivenessInfo} and {@link #addRowDeletion}, if called, are called before
     *      any {@link #addCell}/{@link #addComplexDeletion} call.
     *   3) {@link #build} is called to construct the new row. The builder can then be reused.
     *
     * There is 2 variants of a builder: sorted and unsorted ones. A sorted builder expects user to abid to the
     * following additional rules:
     *   4) Calls to {@link #addCell}/{@link #addComplexDeletion} are done in strictly increasing column order.
     *      In other words, all calls to these methods for a give column {@code c} are done after any call for
     *      any column before {@code c} and before any call for any column after {@code c}.
     *   5) Calls to {@link #addCell} are further done in strictly increasing cell order (the one defined by
     *      {@link Cell#comparator}. That is, for a give column, cells are passed in {@code CellPath} order.
     *   6) No shadowed data should be added. Concretely, this means that if a a row deletion is added, it doesn't
     *      deletes the row timestamp or any cell added later, and similarly no cell added is deleted by the complex
     *      deletion of the column this is a cell of.
     *
     * An unsorted builder will not expect those last rules however: {@link #addCell} and {@link #addComplexDeletion}
     * can be done in any order. And in particular unsorted builder allows multiple calls for the same column/cell. In
     * that latter case, the result will follow the usual reconciliation rules (so equal cells are reconciled with
     * {@link Cells#reconcile} and the &quot;biggest&quot; of multiple complex deletion for the same column wins).
     */
    public interface Builder
    {
        /**
         * Creates a copy of this {@code Builder}.
         * @return a copy of this {@code Builder}
         */
        public Builder copy();

        /**
         * Whether the builder is a sorted one or not.
         *
         * @return if the builder requires calls to be done in sorted order or not (see above).
         */
        public boolean isSorted();

        /**
         * Prepares the builder to build a new row of clustering {@code clustering}.
         * &lt;p&gt;
         * This should always be the first call for a given row.
         *
         * @param clustering the clustering for the new row.
         */
        public void newRow(Clustering clustering);

        /**
         * The clustering for the row that is currently being built.
         *
         * @return the clustering for the row that is currently being built, or {@code null} if {@link #newRow} hasn't
         * yet been called.
         */
        public Clustering clustering();

        /**
         * Adds the liveness information for the partition key columns of this row.
         *
         * This call is optional (skipping it is equivalent to calling {@code addPartitionKeyLivenessInfo(LivenessInfo.NONE)}).
         *
         * @param info the liveness information for the partition key columns of the built row.
         */
        public void addPrimaryKeyLivenessInfo(LivenessInfo info);

        /**
         * Adds the deletion information for this row.
         *
         * This call is optional and can be skipped if the row is not deleted.
         *
         * @param deletion the row deletion time, or {@code Deletion.LIVE} if the row isn't deleted.
         */
        public void addRowDeletion(Deletion deletion);

        /**
         * Adds a cell to this builder.
         *
         * @param cell the cell to add.
         */
        public void addCell(Cell cell);

        /**
         * Adds a complex deletion.
         *
         * @param column the column for which to add the {@code complexDeletion}.
         * @param complexDeletion the complex deletion time to add.
         */
        public void addComplexDeletion(ColumnDefinition column, DeletionTime complexDeletion);

        /**
         * Builds and return built row.
         *
         * @return the last row built by this builder.
         */
        public Row build();
    }

    /**
     * Row builder interface geared towards human.
     * &lt;p&gt;
     * Where the {@link Builder} deals with building rows efficiently from internal objects ({@code Cell}, {@code
     * LivenessInfo}, ...), the {@code SimpleBuilder} is geared towards building rows from string column name and
     * 'native' values (string for text, ints for numbers, et...). In particular, it is meant to be convenient, not
     * efficient, and should be used only in place where performance is not of the utmost importance (it is used to
     * build schema mutation for instance).
     * &lt;p&gt;
     * Also note that contrarily to {@link Builder}, the {@code SimpleBuilder} API has no {@code newRow()} method: it is
     * expected that the clustering of the row built is provided by the constructor of the builder.
     */
    public interface SimpleBuilder
    {
        /**
         * Sets the timestamp to use for the following additions.
         * &lt;p&gt;
         * Note that the for non-compact tables, this method must be called before any column addition for this
         * timestamp to be used for the row {@code LivenessInfo}.
         *
         * @param timestamp the timestamp to use for following additions. If that timestamp hasn't been set, the current
         * time in microseconds will be used.
         * @return this builder.
         */
        public SimpleBuilder timestamp(long timestamp);

        /**
         * Sets the ttl to use for the following additions.
         * &lt;p&gt;
         * Note that the for non-compact tables, this method must be called before any column addition for this
         * ttl to be used for the row {@code LivenessInfo}.
         *
         * @param ttl the ttl to use for following additions. If that ttl hasn't been set, no ttl will be used.
         * @return this builder.
         */
        public SimpleBuilder ttl(int ttl);

        /**
         * Adds a value to a given column.
         *
         * @param columnName the name of the column for which to add a new value.
         * @param value the value to add, which must be of the proper type for {@code columnName}. This can be {@code
         * null} in which case the this is equivalent to {@code delete(columnName)}.
         * @return this builder.
         */
        public SimpleBuilder add(String columnName, Object value);

        /**
         * Appends new values to a given non-frozen collection column.
         * &lt;p&gt;
         * This method is similar to {@code add()} but the collection elements added through this method are &quot;appended&quot;
         * to any pre-exising elements. In other words, this is like {@code add()} except that it doesn't delete the
         * previous value of the collection. This can only be called on non-frozen collection columns.
         * &lt;p&gt;
         * Note that this method can be used in replacement of {@code add()} if you know that there can't be any
         * pre-existing value for that column, in which case this is slightly less expensive as it avoid the collection
         * tombstone inherent to {@code add()}.
         *
         * @param columnName the name of the column for which to add a new value, which must be a non-frozen collection.
         * @param value the value to add, which must be of the proper type for {@code columnName} (in other words, it
         * &lt;b&gt;must&lt;/b&gt; be a collection).
         * @return this builder.
         *
         * @throws IllegalArgumentException if columnName is not a non-frozen collection column.
         */
        public SimpleBuilder appendAll(String columnName, Object value);

        /**
         * Deletes the whole row.
         * &lt;p&gt;
         * If called, this is generally the only method called on the builder (outside of {@code timestamp()}.
         *
         * @return this builder.
         */
        public SimpleBuilder delete();

        /**
         * Removes the value for a given column (creating a tombstone).
         *
         * @param columnName the name of the column to delete.
         * @return this builder.
         */
        public SimpleBuilder delete(String columnName);

        /**
         * Don't include any primary key {@code LivenessInfo} in the built row.
         *
         * @return this builder.
         */
        public SimpleBuilder noPrimaryKeyLivenessInfo();

        /**
         * Returns the built row.
         *
         * @return the built row.
         */
        public Row build();
    }

    /**
     * Utility class to help merging rows from multiple inputs (UnfilteredRowIterators).
     */
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">    public static class Merger</span>
    {
        private final Row[] rows;
        private final List&lt;Iterator&lt;ColumnData&gt;&gt; columnDataIterators;

        private Clustering clustering;
        private int rowsToMerge;
<span class="fc" id="L634">        private int lastRowSet = -1;</span>

<span class="fc" id="L636">        private final List&lt;ColumnData&gt; dataBuffer = new ArrayList&lt;&gt;();</span>
        private final ColumnDataReducer columnDataReducer;

        public Merger(int size, int nowInSec, boolean hasComplex)
<span class="fc" id="L640">        {</span>
<span class="fc" id="L641">            this.rows = new Row[size];</span>
<span class="fc" id="L642">            this.columnDataIterators = new ArrayList&lt;&gt;(size);</span>
<span class="fc" id="L643">            this.columnDataReducer = new ColumnDataReducer(size, nowInSec, hasComplex);</span>
<span class="fc" id="L644">        }</span>

        public void clear()
        {
<span class="nc" id="L648">            dataBuffer.clear();</span>
<span class="nc" id="L649">            Arrays.fill(rows, null);</span>
<span class="nc" id="L650">            columnDataIterators.clear();</span>
<span class="nc" id="L651">            rowsToMerge = 0;</span>
<span class="nc" id="L652">            lastRowSet = -1;</span>
<span class="nc" id="L653">        }</span>

        public void add(int i, Row row)
        {
<span class="fc" id="L657">            clustering = row.clustering();</span>
<span class="fc" id="L658">            rows[i] = row;</span>
<span class="fc" id="L659">            ++rowsToMerge;</span>
<span class="fc" id="L660">            lastRowSet = i;</span>
<span class="fc" id="L661">        }</span>

        public Row merge(DeletionTime activeDeletion)
        {
            // If for this clustering we have only one row version and have no activeDeletion (i.e. nothing to filter out),
            // then we can just return that single row
<span class="pc bpc" id="L667" title="3 of 4 branches missed.">            if (rowsToMerge == 1 &amp;&amp; activeDeletion.isLive())</span>
            {
<span class="nc" id="L669">                Row row = rows[lastRowSet];</span>
<span class="nc bnc" id="L670" title="All 4 branches missed.">                assert row != null;</span>
<span class="nc" id="L671">                return row;</span>
            }

<span class="fc" id="L674">            LivenessInfo rowInfo = LivenessInfo.EMPTY;</span>
<span class="fc" id="L675">            Deletion rowDeletion = Deletion.LIVE;</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">            for (Row row : rows)</span>
            {
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                if (row == null)</span>
<span class="nc" id="L679">                    continue;</span>

<span class="fc bfc" id="L681" title="All 2 branches covered.">                if (row.primaryKeyLivenessInfo().supersedes(rowInfo))</span>
<span class="fc" id="L682">                    rowInfo = row.primaryKeyLivenessInfo();</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">                if (row.deletion().supersedes(rowDeletion))</span>
<span class="nc" id="L684">                    rowDeletion = row.deletion();</span>
            }

<span class="pc bpc" id="L687" title="1 of 2 branches missed.">            if (rowDeletion.isShadowedBy(rowInfo))</span>
<span class="nc" id="L688">                rowDeletion = Deletion.LIVE;</span>

<span class="pc bpc" id="L690" title="1 of 2 branches missed.">            if (rowDeletion.supersedes(activeDeletion))</span>
<span class="nc" id="L691">                activeDeletion = rowDeletion.time();</span>
            else
<span class="fc" id="L693">                rowDeletion = Deletion.LIVE;</span>

<span class="pc bpc" id="L695" title="1 of 2 branches missed.">            if (activeDeletion.deletes(rowInfo))</span>
<span class="nc" id="L696">                rowInfo = LivenessInfo.EMPTY;</span>

<span class="fc bfc" id="L698" title="All 2 branches covered.">            for (Row row : rows)</span>
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">                columnDataIterators.add(row == null ? Collections.emptyIterator() : row.iterator());</span>

<span class="fc" id="L701">            columnDataReducer.setActiveDeletion(activeDeletion);</span>
<span class="fc" id="L702">            Iterator&lt;ColumnData&gt; merged = MergeIterator.get(columnDataIterators, ColumnData.comparator, columnDataReducer);</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">            while (merged.hasNext())</span>
            {
<span class="fc" id="L705">                ColumnData data = merged.next();</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">                if (data != null)</span>
<span class="fc" id="L707">                    dataBuffer.add(data);</span>
<span class="fc" id="L708">            }</span>

            // Because some data might have been shadowed by the 'activeDeletion', we could have an empty row
<span class="pc bpc" id="L711" title="5 of 6 branches missed.">            return rowInfo.isEmpty() &amp;&amp; rowDeletion.isLive() &amp;&amp; dataBuffer.isEmpty()</span>
                 ? null
<span class="fc" id="L713">                 : BTreeRow.create(clustering, rowInfo, rowDeletion, BTree.build(dataBuffer, UpdateFunction.&lt;ColumnData&gt;noOp()));</span>
        }

        public Clustering mergedClustering()
        {
<span class="nc" id="L718">            return clustering;</span>
        }

        public Row[] mergedRows()
        {
<span class="nc" id="L723">            return rows;</span>
        }

        private static class ColumnDataReducer extends MergeIterator.Reducer&lt;ColumnData, ColumnData&gt;
        {
            private final int nowInSec;

            private ColumnDefinition column;
            private final List&lt;ColumnData&gt; versions;

            private DeletionTime activeDeletion;

            private final ComplexColumnData.Builder complexBuilder;
            private final List&lt;Iterator&lt;Cell&gt;&gt; complexCells;
            private final CellReducer cellReducer;

            public ColumnDataReducer(int size, int nowInSec, boolean hasComplex)
<span class="fc" id="L740">            {</span>
<span class="fc" id="L741">                this.nowInSec = nowInSec;</span>
<span class="fc" id="L742">                this.versions = new ArrayList&lt;&gt;(size);</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">                this.complexBuilder = hasComplex ? ComplexColumnData.builder() : null;</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">                this.complexCells = hasComplex ? new ArrayList&lt;&gt;(size) : null;</span>
<span class="fc" id="L745">                this.cellReducer = new CellReducer(nowInSec);</span>
<span class="fc" id="L746">            }</span>

            public void setActiveDeletion(DeletionTime activeDeletion)
            {
<span class="fc" id="L750">                this.activeDeletion = activeDeletion;</span>
<span class="fc" id="L751">            }</span>

            public void reduce(int idx, ColumnData data)
            {
<span class="fc bfc" id="L755" title="All 2 branches covered.">                if (useColumnDefinition(data.column()))</span>
<span class="fc" id="L756">                    column = data.column();</span>

<span class="fc" id="L758">                versions.add(data);</span>
<span class="fc" id="L759">            }</span>

            /**
             * Determines it the {@code ColumnDefinition} is the one that should be used.
             * @param dataColumn the {@code ColumnDefinition} to use.
             * @return {@code true} if the {@code ColumnDefinition} is the one that should be used, {@code false} otherwise.
             */
            private boolean useColumnDefinition(ColumnDefinition dataColumn)
            {
<span class="fc bfc" id="L768" title="All 2 branches covered.">                if (column == null)</span>
<span class="fc" id="L769">                    return true;</span>

<span class="pc bpc" id="L771" title="1 of 2 branches missed.">                return ColumnDefinitionVersionComparator.INSTANCE.compare(column, dataColumn) &lt; 0;</span>
            }

            protected ColumnData getReduced()
            {
<span class="fc bfc" id="L776" title="All 2 branches covered.">                if (column.isSimple())</span>
                {
<span class="fc" id="L778">                    Cell merged = null;</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">                    for (ColumnData data : versions)</span>
                    {
<span class="fc" id="L781">                        Cell cell = (Cell)data;</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">                        if (!activeDeletion.deletes(cell))</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">                            merged = merged == null ? cell : Cells.reconcile(merged, cell, nowInSec);</span>
<span class="fc" id="L784">                    }</span>
<span class="fc" id="L785">                    return merged;</span>
                }
                else
                {
<span class="fc" id="L789">                    complexBuilder.newColumn(column);</span>
<span class="fc" id="L790">                    complexCells.clear();</span>
<span class="fc" id="L791">                    DeletionTime complexDeletion = DeletionTime.LIVE;</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">                    for (ColumnData data : versions)</span>
                    {
<span class="fc" id="L794">                        ComplexColumnData cd = (ComplexColumnData)data;</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">                        if (cd.complexDeletion().supersedes(complexDeletion))</span>
<span class="fc" id="L796">                            complexDeletion = cd.complexDeletion();</span>
<span class="fc" id="L797">                        complexCells.add(cd.iterator());</span>
<span class="fc" id="L798">                    }</span>

<span class="fc bfc" id="L800" title="All 2 branches covered.">                    if (complexDeletion.supersedes(activeDeletion))</span>
                    {
<span class="fc" id="L802">                        cellReducer.setActiveDeletion(complexDeletion);</span>
<span class="fc" id="L803">                        complexBuilder.addComplexDeletion(complexDeletion);</span>
                    }
                    else
                    {
<span class="fc" id="L807">                        cellReducer.setActiveDeletion(activeDeletion);</span>
                    }

<span class="fc" id="L810">                    Iterator&lt;Cell&gt; cells = MergeIterator.get(complexCells, Cell.comparator, cellReducer);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">                    while (cells.hasNext())</span>
                    {
<span class="fc" id="L813">                        Cell merged = cells.next();</span>
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">                        if (merged != null)</span>
<span class="fc" id="L815">                            complexBuilder.addCell(merged);</span>
<span class="fc" id="L816">                    }</span>
<span class="fc" id="L817">                    return complexBuilder.build();</span>
                }
            }

            protected void onKeyChange()
            {
<span class="fc" id="L823">                column = null;</span>
<span class="fc" id="L824">                versions.clear();</span>
<span class="fc" id="L825">            }</span>
        }

        private static class CellReducer extends MergeIterator.Reducer&lt;Cell, Cell&gt;
        {
            private final int nowInSec;

            private DeletionTime activeDeletion;
            private Cell merged;

            public CellReducer(int nowInSec)
<span class="fc" id="L836">            {</span>
<span class="fc" id="L837">                this.nowInSec = nowInSec;</span>
<span class="fc" id="L838">            }</span>

            public void setActiveDeletion(DeletionTime activeDeletion)
            {
<span class="fc" id="L842">                this.activeDeletion = activeDeletion;</span>
<span class="fc" id="L843">                onKeyChange();</span>
<span class="fc" id="L844">            }</span>

            public void reduce(int idx, Cell cell)
            {
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">                if (!activeDeletion.deletes(cell))</span>
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">                    merged = merged == null ? cell : Cells.reconcile(merged, cell, nowInSec);</span>
<span class="fc" id="L850">            }</span>

            protected Cell getReduced()
            {
<span class="fc" id="L854">                return merged;</span>
            }

            protected void onKeyChange()
            {
<span class="fc" id="L859">                merged = null;</span>
<span class="fc" id="L860">            }</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>