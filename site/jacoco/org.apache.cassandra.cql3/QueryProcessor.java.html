<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">QueryProcessor.java</span></div><h1>QueryProcessor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.primitives.Ints;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.googlecode.concurrentlinkedhashmap.ConcurrentLinkedHashMap;
import org.antlr.runtime.*;
import org.apache.cassandra.concurrent.ScheduledExecutors;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.Schema;
import org.apache.cassandra.config.SchemaConstants;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.cql3.functions.FunctionName;
import org.apache.cassandra.cql3.statements.*;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.rows.RowIterator;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.partitions.PartitionIterators;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.exceptions.*;
import org.apache.cassandra.metrics.CQLMetrics;
import org.apache.cassandra.service.*;
import org.apache.cassandra.service.pager.QueryPager;
import org.apache.cassandra.thrift.ThriftClientState;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.transport.messages.ResultMessage;
import org.apache.cassandra.utils.*;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;

<span class="pc bpc" id="L61" title="1 of 2 branches missed.">public class QueryProcessor implements QueryHandler</span>
{
<span class="fc" id="L63">    public static final CassandraVersion CQL_VERSION = new CassandraVersion(&quot;3.4.4&quot;);</span>

<span class="fc" id="L65">    public static final QueryProcessor instance = new QueryProcessor();</span>

<span class="fc" id="L67">    private static final Logger logger = LoggerFactory.getLogger(QueryProcessor.class);</span>

    private static final ConcurrentLinkedHashMap&lt;MD5Digest, ParsedStatement.Prepared&gt; preparedStatements;
    private static final ConcurrentLinkedHashMap&lt;Integer, ParsedStatement.Prepared&gt; thriftPreparedStatements;

    // A map for prepared statements used internally (which we don't want to mix with user statement, in particular we don't
    // bother with expiration on those.
<span class="fc" id="L74">    private static final ConcurrentMap&lt;String, ParsedStatement.Prepared&gt; internalStatements = new ConcurrentHashMap&lt;&gt;();</span>

    // Direct calls to processStatement do not increment the preparedStatementsExecuted/regularStatementsExecuted
    // counters. Callers of processStatement are responsible for correctly notifying metrics
<span class="fc" id="L78">    public static final CQLMetrics metrics = new CQLMetrics();</span>

<span class="fc" id="L80">    private static final AtomicInteger lastMinuteEvictionsCount = new AtomicInteger(0);</span>
<span class="fc" id="L81">    private static final AtomicInteger thriftLastMinuteEvictionsCount = new AtomicInteger(0);</span>

    static
    {
<span class="fc" id="L85">        preparedStatements = new ConcurrentLinkedHashMap.Builder&lt;MD5Digest, ParsedStatement.Prepared&gt;()</span>
<span class="fc" id="L86">                             .maximumWeightedCapacity(capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))</span>
<span class="fc" id="L87">                             .weigher(QueryProcessor::measure)</span>
<span class="fc" id="L88">                             .listener((md5Digest, prepared) -&gt; {</span>
<span class="nc" id="L89">                                 metrics.preparedStatementsEvicted.inc();</span>
<span class="nc" id="L90">                                 lastMinuteEvictionsCount.incrementAndGet();</span>
<span class="nc" id="L91">                                 SystemKeyspace.removePreparedStatement(md5Digest);</span>
<span class="pc" id="L92">                             }).build();</span>

<span class="fc" id="L94">        thriftPreparedStatements = new ConcurrentLinkedHashMap.Builder&lt;Integer, ParsedStatement.Prepared&gt;()</span>
<span class="fc" id="L95">                                   .maximumWeightedCapacity(capacityToBytes(DatabaseDescriptor.getThriftPreparedStatementsCacheSizeMB()))</span>
<span class="fc" id="L96">                                   .weigher(QueryProcessor::measure)</span>
<span class="fc" id="L97">                                   .listener((integer, prepared) -&gt; {</span>
<span class="nc" id="L98">                                       metrics.preparedStatementsEvicted.inc();</span>
<span class="nc" id="L99">                                       thriftLastMinuteEvictionsCount.incrementAndGet();</span>
<span class="nc" id="L100">                                   })</span>
<span class="fc" id="L101">                                   .build();</span>

<span class="fc" id="L103">        ScheduledExecutors.scheduledTasks.scheduleAtFixedRate(() -&gt; {</span>
<span class="nc" id="L104">            long count = lastMinuteEvictionsCount.getAndSet(0);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (count &gt; 0)</span>
<span class="nc" id="L106">                logger.warn(&quot;{} prepared statements discarded in the last minute because cache limit reached ({} MB)&quot;,</span>
<span class="nc" id="L107">                            count,</span>
<span class="nc" id="L108">                            DatabaseDescriptor.getPreparedStatementsCacheSizeMB());</span>
<span class="nc" id="L109">            count = thriftLastMinuteEvictionsCount.getAndSet(0);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (count &gt; 0)</span>
<span class="nc" id="L111">                logger.warn(&quot;{} prepared Thrift statements discarded in the last minute because cache limit reached ({} MB)&quot;,</span>
<span class="nc" id="L112">                            count,</span>
<span class="nc" id="L113">                            DatabaseDescriptor.getThriftPreparedStatementsCacheSizeMB());</span>
<span class="nc" id="L114">        }, 1, 1, TimeUnit.MINUTES);</span>

<span class="fc" id="L116">        logger.info(&quot;Initialized prepared statement caches with {} MB (native) and {} MB (Thrift)&quot;,</span>
<span class="fc" id="L117">                    DatabaseDescriptor.getPreparedStatementsCacheSizeMB(),</span>
<span class="fc" id="L118">                    DatabaseDescriptor.getThriftPreparedStatementsCacheSizeMB());</span>
<span class="fc" id="L119">    }</span>

    private static long capacityToBytes(long cacheSizeMB)
    {
<span class="fc" id="L123">        return cacheSizeMB * 1024 * 1024;</span>
    }

    public static int preparedStatementsCount()
    {
<span class="nc" id="L128">        return preparedStatements.size() + thriftPreparedStatements.size();</span>
    }

    // Work around initialization dependency
<span class="fc" id="L132">    private static enum InternalStateInstance</span>
    {
<span class="fc" id="L134">        INSTANCE;</span>

        private final QueryState queryState;

        InternalStateInstance()
<span class="fc" id="L139">        {</span>
<span class="fc" id="L140">            ClientState state = ClientState.forInternalCalls();</span>
<span class="fc" id="L141">            state.setKeyspace(SchemaConstants.SYSTEM_KEYSPACE_NAME);</span>
<span class="fc" id="L142">            this.queryState = new QueryState(state);</span>
<span class="fc" id="L143">        }</span>
    }

    public static void preloadPreparedStatement()
    {
<span class="fc" id="L148">        ClientState clientState = ClientState.forInternalCalls();</span>
<span class="fc" id="L149">        int count = 0;</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        for (Pair&lt;String, String&gt; useKeyspaceAndCQL : SystemKeyspace.loadPreparedStatements())</span>
        {
            try
            {
<span class="nc" id="L154">                clientState.setKeyspace(useKeyspaceAndCQL.left);</span>
<span class="nc" id="L155">                prepare(useKeyspaceAndCQL.right, clientState, false);</span>
<span class="nc" id="L156">                count++;</span>
            }
<span class="nc" id="L158">            catch (RequestValidationException e)</span>
            {
<span class="nc" id="L160">                logger.warn(&quot;prepared statement recreation error: {}&quot;, useKeyspaceAndCQL.right, e);</span>
<span class="nc" id="L161">            }</span>
<span class="nc" id="L162">        }</span>
<span class="fc" id="L163">        logger.info(&quot;Preloaded {} prepared statements&quot;, count);</span>
<span class="fc" id="L164">    }</span>

    /**
     * Clears the prepared statement cache.
     * @param memoryOnly {@code true} if only the in memory caches must be cleared, {@code false} otherwise.
     */
    @VisibleForTesting
    public static void clearPreparedStatements(boolean memoryOnly)
    {
<span class="nc" id="L173">        preparedStatements.clear();</span>
<span class="nc" id="L174">        thriftPreparedStatements.clear();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (!memoryOnly)</span>
<span class="nc" id="L176">            SystemKeyspace.resetPreparedStatements();</span>
<span class="nc" id="L177">    }</span>

    @VisibleForTesting
    public static QueryState internalQueryState()
    {
<span class="fc" id="L182">        return InternalStateInstance.INSTANCE.queryState;</span>
    }

    private QueryProcessor()
<span class="fc" id="L186">    {</span>
<span class="fc" id="L187">        MigrationManager.instance.register(new MigrationSubscriber());</span>
<span class="fc" id="L188">    }</span>

    public ParsedStatement.Prepared getPrepared(MD5Digest id)
    {
<span class="nc" id="L192">        return preparedStatements.get(id);</span>
    }

    public ParsedStatement.Prepared getPreparedForThrift(Integer id)
    {
<span class="nc" id="L197">        return thriftPreparedStatements.get(id);</span>
    }

    public static void validateKey(ByteBuffer key) throws InvalidRequestException
    {
<span class="pc bpc" id="L202" title="2 of 4 branches missed.">        if (key == null || key.remaining() == 0)</span>
        {
<span class="nc" id="L204">            throw new InvalidRequestException(&quot;Key may not be empty&quot;);</span>
        }
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (key == ByteBufferUtil.UNSET_BYTE_BUFFER)</span>
<span class="nc" id="L207">            throw new InvalidRequestException(&quot;Key may not be unset&quot;);</span>

        // check that key can be handled by FBUtilities.writeShortByteArray
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (key.remaining() &gt; FBUtilities.MAX_UNSIGNED_SHORT)</span>
        {
<span class="nc" id="L212">            throw new InvalidRequestException(&quot;Key length of &quot; + key.remaining() +</span>
                                              &quot; is longer than maximum of &quot; + FBUtilities.MAX_UNSIGNED_SHORT);
        }
<span class="fc" id="L215">    }</span>

    public ResultMessage processStatement(CQLStatement statement, QueryState queryState, QueryOptions options, long queryStartNanoTime)
    throws RequestExecutionException, RequestValidationException
    {
<span class="fc" id="L220">        logger.trace(&quot;Process {} @CL.{}&quot;, statement, options.getConsistency());</span>
<span class="fc" id="L221">        ClientState clientState = queryState.getClientState();</span>
<span class="fc" id="L222">        statement.checkAccess(clientState);</span>
<span class="fc" id="L223">        statement.validate(clientState);</span>

<span class="fc" id="L225">        ResultMessage result = statement.execute(queryState, options, queryStartNanoTime);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        return result == null ? new ResultMessage.Void() : result;</span>
    }

    public static ResultMessage process(String queryString, ConsistencyLevel cl, QueryState queryState, long queryStartNanoTime)
    throws RequestExecutionException, RequestValidationException
    {
<span class="nc" id="L232">        return instance.process(queryString, queryState, QueryOptions.forInternalCalls(cl, Collections.&lt;ByteBuffer&gt;emptyList()), queryStartNanoTime);</span>
    }

    public ResultMessage process(String query,
                                 QueryState state,
                                 QueryOptions options,
                                 Map&lt;String, ByteBuffer&gt; customPayload,
                                 long queryStartNanoTime) throws RequestExecutionException, RequestValidationException
    {
<span class="nc" id="L241">        return process(query, state, options, queryStartNanoTime);</span>
    }

    public ResultMessage process(String queryString, QueryState queryState, QueryOptions options, long queryStartNanoTime)
    throws RequestExecutionException, RequestValidationException
    {
<span class="fc" id="L247">        ParsedStatement.Prepared p = getStatement(queryString, queryState.getClientState());</span>
<span class="fc" id="L248">        options.prepare(p.boundNames);</span>
<span class="fc" id="L249">        CQLStatement prepared = p.statement;</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (prepared.getBoundTerms() != options.getValues().size())</span>
<span class="nc" id="L251">            throw new InvalidRequestException(&quot;Invalid amount of bind variables&quot;);</span>

<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (!queryState.getClientState().isInternal)</span>
<span class="nc" id="L254">            metrics.regularStatementsExecuted.inc();</span>

<span class="fc" id="L256">        return processStatement(prepared, queryState, options, queryStartNanoTime);</span>
    }

    public static ParsedStatement.Prepared parseStatement(String queryStr, QueryState queryState) throws RequestValidationException
    {
<span class="fc" id="L261">        return getStatement(queryStr, queryState.getClientState());</span>
    }

    public static UntypedResultSet process(String query, ConsistencyLevel cl) throws RequestExecutionException
    {
<span class="fc" id="L266">        return process(query, cl, Collections.&lt;ByteBuffer&gt;emptyList());</span>
    }

    public static UntypedResultSet process(String query, ConsistencyLevel cl, List&lt;ByteBuffer&gt; values) throws RequestExecutionException
    {
<span class="fc" id="L271">        ResultMessage result = instance.process(query, QueryState.forInternalCalls(), QueryOptions.forInternalCalls(cl, values), System.nanoTime());</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (result instanceof ResultMessage.Rows)</span>
<span class="fc" id="L273">            return UntypedResultSet.create(((ResultMessage.Rows)result).result);</span>
        else
<span class="fc" id="L275">            return null;</span>
    }

    @VisibleForTesting
    public static QueryOptions makeInternalOptions(ParsedStatement.Prepared prepared, Object[] values)
    {
<span class="fc" id="L281">        return makeInternalOptions(prepared, values, ConsistencyLevel.ONE);</span>
    }

    private static QueryOptions makeInternalOptions(ParsedStatement.Prepared prepared, Object[] values, ConsistencyLevel cl)
    {
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (prepared.boundNames.size() != values.length)</span>
<span class="nc" id="L287">            throw new IllegalArgumentException(String.format(&quot;Invalid number of values. Expecting %d but got %d&quot;, prepared.boundNames.size(), values.length));</span>

<span class="fc" id="L289">        List&lt;ByteBuffer&gt; boundValues = new ArrayList&lt;&gt;(values.length);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++)</span>
        {
<span class="fc" id="L292">            Object value = values[i];</span>
<span class="fc" id="L293">            AbstractType type = prepared.boundNames.get(i).type;</span>
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">            boundValues.add(value instanceof ByteBuffer || value == null ? (ByteBuffer)value : type.decompose(value));</span>
        }
<span class="fc" id="L296">        return QueryOptions.forInternalCalls(cl, boundValues);</span>
    }

    public static ParsedStatement.Prepared prepareInternal(String query) throws RequestValidationException
    {
<span class="fc" id="L301">        ParsedStatement.Prepared prepared = internalStatements.get(query);</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (prepared != null)</span>
<span class="fc" id="L303">            return prepared;</span>

        // Note: if 2 threads prepare the same query, we'll live so don't bother synchronizing
<span class="fc" id="L306">        prepared = parseStatement(query, internalQueryState());</span>
<span class="fc" id="L307">        prepared.statement.validate(internalQueryState().getClientState());</span>
<span class="fc" id="L308">        internalStatements.putIfAbsent(query, prepared);</span>
<span class="fc" id="L309">        return prepared;</span>
    }

    public static UntypedResultSet executeInternal(String query, Object... values)
    {
<span class="fc" id="L314">        ParsedStatement.Prepared prepared = prepareInternal(query);</span>
<span class="fc" id="L315">        ResultMessage result = prepared.statement.executeInternal(internalQueryState(), makeInternalOptions(prepared, values));</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (result instanceof ResultMessage.Rows)</span>
<span class="fc" id="L317">            return UntypedResultSet.create(((ResultMessage.Rows)result).result);</span>
        else
<span class="fc" id="L319">            return null;</span>
    }

    public static UntypedResultSet execute(String query, ConsistencyLevel cl, Object... values)
    throws RequestExecutionException
    {
<span class="nc" id="L325">        return execute(query, cl, internalQueryState(), values);</span>
    }

    public static UntypedResultSet execute(String query, ConsistencyLevel cl, QueryState state, Object... values)
    throws RequestExecutionException
    {
        try
        {
<span class="nc" id="L333">            ParsedStatement.Prepared prepared = prepareInternal(query);</span>
<span class="nc" id="L334">            ResultMessage result = prepared.statement.execute(state, makeInternalOptions(prepared, values, cl), System.nanoTime());</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (result instanceof ResultMessage.Rows)</span>
<span class="nc" id="L336">                return UntypedResultSet.create(((ResultMessage.Rows)result).result);</span>
            else
<span class="nc" id="L338">                return null;</span>
        }
<span class="nc" id="L340">        catch (RequestValidationException e)</span>
        {
<span class="nc" id="L342">            throw new RuntimeException(&quot;Error validating &quot; + query, e);</span>
        }
    }

    public static UntypedResultSet executeInternalWithPaging(String query, int pageSize, Object... values)
    {
<span class="fc" id="L348">        ParsedStatement.Prepared prepared = prepareInternal(query);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (!(prepared.statement instanceof SelectStatement))</span>
<span class="nc" id="L350">            throw new IllegalArgumentException(&quot;Only SELECTs can be paged&quot;);</span>

<span class="fc" id="L352">        SelectStatement select = (SelectStatement)prepared.statement;</span>
<span class="fc" id="L353">        QueryPager pager = select.getQuery(makeInternalOptions(prepared, values), FBUtilities.nowInSeconds()).getPager(null, ProtocolVersion.CURRENT);</span>
<span class="fc" id="L354">        return UntypedResultSet.create(select, pager, pageSize);</span>
    }

    /**
     * Same than executeInternal, but to use for queries we know are only executed once so that the
     * created statement object is not cached.
     */
    public static UntypedResultSet executeOnceInternal(String query, Object... values)
    {
<span class="fc" id="L363">        ParsedStatement.Prepared prepared = parseStatement(query, internalQueryState());</span>
<span class="fc" id="L364">        prepared.statement.validate(internalQueryState().getClientState());</span>
<span class="fc" id="L365">        ResultMessage result = prepared.statement.executeInternal(internalQueryState(), makeInternalOptions(prepared, values));</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (result instanceof ResultMessage.Rows)</span>
<span class="fc" id="L367">            return UntypedResultSet.create(((ResultMessage.Rows)result).result);</span>
        else
<span class="fc" id="L369">            return null;</span>
    }

    /**
     * A special version of executeInternal that takes the time used as &quot;now&quot; for the query in argument.
     * Note that this only make sense for Selects so this only accept SELECT statements and is only useful in rare
     * cases.
     */
    public static UntypedResultSet executeInternalWithNow(int nowInSec, long queryStartNanoTime, String query, Object... values)
    {
<span class="nc" id="L379">        ParsedStatement.Prepared prepared = prepareInternal(query);</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">        assert prepared.statement instanceof SelectStatement;</span>
<span class="nc" id="L381">        SelectStatement select = (SelectStatement)prepared.statement;</span>
<span class="nc" id="L382">        ResultMessage result = select.executeInternal(internalQueryState(), makeInternalOptions(prepared, values), nowInSec, queryStartNanoTime);</span>
<span class="nc bnc" id="L383" title="All 4 branches missed.">        assert result instanceof ResultMessage.Rows;</span>
<span class="nc" id="L384">        return UntypedResultSet.create(((ResultMessage.Rows)result).result);</span>
    }

    public static UntypedResultSet resultify(String query, RowIterator partition)
    {
<span class="nc" id="L389">        return resultify(query, PartitionIterators.singletonIterator(partition));</span>
    }

    public static UntypedResultSet resultify(String query, PartitionIterator partitions)
    {
<span class="nc" id="L394">        try (PartitionIterator iter = partitions)</span>
        {
<span class="nc" id="L396">            SelectStatement ss = (SelectStatement) getStatement(query, null).statement;</span>
<span class="nc" id="L397">            ResultSet cqlRows = ss.process(iter, FBUtilities.nowInSeconds());</span>
<span class="nc" id="L398">            return UntypedResultSet.create(cqlRows);</span>
        }
    }

    public ResultMessage.Prepared prepare(String query,
                                          QueryState state,
                                          Map&lt;String, ByteBuffer&gt; customPayload) throws RequestValidationException
    {
<span class="nc" id="L406">        return prepare(query, state);</span>
    }

    public ResultMessage.Prepared prepare(String queryString, QueryState queryState)
    {
<span class="nc" id="L411">        ClientState cState = queryState.getClientState();</span>
<span class="nc" id="L412">        return prepare(queryString, cState, cState instanceof ThriftClientState);</span>
    }

    public static ResultMessage.Prepared prepare(String queryString, ClientState clientState, boolean forThrift)
    {
<span class="nc" id="L417">        ResultMessage.Prepared existing = getStoredPreparedStatement(queryString, clientState.getRawKeyspace(), forThrift);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (existing != null)</span>
<span class="nc" id="L419">            return existing;</span>

<span class="nc" id="L421">        ParsedStatement.Prepared prepared = getStatement(queryString, clientState);</span>
<span class="nc" id="L422">        prepared.rawCQLStatement = queryString;</span>
<span class="nc" id="L423">        int boundTerms = prepared.statement.getBoundTerms();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (boundTerms &gt; FBUtilities.MAX_UNSIGNED_SHORT)</span>
<span class="nc" id="L425">            throw new InvalidRequestException(String.format(&quot;Too many markers(?). %d markers exceed the allowed maximum of %d&quot;, boundTerms, FBUtilities.MAX_UNSIGNED_SHORT));</span>
<span class="nc bnc" id="L426" title="All 4 branches missed.">        assert boundTerms == prepared.boundNames.size();</span>

<span class="nc" id="L428">        return storePreparedStatement(queryString, clientState.getRawKeyspace(), prepared, forThrift);</span>
    }

    private static MD5Digest computeId(String queryString, String keyspace)
    {
<span class="nc bnc" id="L433" title="All 2 branches missed.">        String toHash = keyspace == null ? queryString : keyspace + queryString;</span>
<span class="nc" id="L434">        return MD5Digest.compute(toHash);</span>
    }

    private static Integer computeThriftId(String queryString, String keyspace)
    {
<span class="nc bnc" id="L439" title="All 2 branches missed.">        String toHash = keyspace == null ? queryString : keyspace + queryString;</span>
<span class="nc" id="L440">        return toHash.hashCode();</span>
    }

    private static ResultMessage.Prepared getStoredPreparedStatement(String queryString, String keyspace, boolean forThrift)
    throws InvalidRequestException
    {
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (forThrift)</span>
        {
<span class="nc" id="L448">            Integer thriftStatementId = computeThriftId(queryString, keyspace);</span>
<span class="nc" id="L449">            ParsedStatement.Prepared existing = thriftPreparedStatements.get(thriftStatementId);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (existing == null)</span>
<span class="nc" id="L451">                return null;</span>

<span class="nc" id="L453">            checkTrue(queryString.equals(existing.rawCQLStatement),</span>
<span class="nc" id="L454">                      String.format(&quot;MD5 hash collision: query with the same MD5 hash was already prepared. \n Existing: '%s'&quot;, existing.rawCQLStatement));</span>
<span class="nc" id="L455">            return ResultMessage.Prepared.forThrift(thriftStatementId, existing.boundNames);</span>
        }
        else
        {
<span class="nc" id="L459">            MD5Digest statementId = computeId(queryString, keyspace);</span>
<span class="nc" id="L460">            ParsedStatement.Prepared existing = preparedStatements.get(statementId);</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            if (existing == null)</span>
<span class="nc" id="L462">                return null;</span>

<span class="nc" id="L464">            checkTrue(queryString.equals(existing.rawCQLStatement),</span>
<span class="nc" id="L465">                      String.format(&quot;MD5 hash collision: query with the same MD5 hash was already prepared. \n Existing: '%s'&quot;, existing.rawCQLStatement));</span>
<span class="nc" id="L466">            return new ResultMessage.Prepared(statementId, existing);</span>
        }
    }

    private static ResultMessage.Prepared storePreparedStatement(String queryString, String keyspace, ParsedStatement.Prepared prepared, boolean forThrift)
    throws InvalidRequestException
    {
        // Concatenate the current keyspace so we don't mix prepared statements between keyspace (#5352).
        // (if the keyspace is null, queryString has to have a fully-qualified keyspace so it's fine.
<span class="nc" id="L475">        long statementSize = ObjectSizes.measureDeep(prepared.statement);</span>
        // don't execute the statement if it's bigger than the allowed threshold
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (forThrift)</span>
        {
<span class="nc bnc" id="L479" title="All 2 branches missed.">            if (statementSize &gt; capacityToBytes(DatabaseDescriptor.getThriftPreparedStatementsCacheSizeMB()))</span>
<span class="nc" id="L480">                throw new InvalidRequestException(String.format(&quot;Prepared statement of size %d bytes is larger than allowed maximum of %d MB: %s...&quot;,</span>
<span class="nc" id="L481">                                                                statementSize,</span>
<span class="nc" id="L482">                                                                DatabaseDescriptor.getThriftPreparedStatementsCacheSizeMB(),</span>
<span class="nc" id="L483">                                                                queryString.substring(0, 200)));</span>
<span class="nc" id="L484">            Integer statementId = computeThriftId(queryString, keyspace);</span>
<span class="nc" id="L485">            thriftPreparedStatements.put(statementId, prepared);</span>
<span class="nc" id="L486">            return ResultMessage.Prepared.forThrift(statementId, prepared.boundNames);</span>
        }
        else
        {
<span class="nc bnc" id="L490" title="All 2 branches missed.">            if (statementSize &gt; capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))</span>
<span class="nc" id="L491">                throw new InvalidRequestException(String.format(&quot;Prepared statement of size %d bytes is larger than allowed maximum of %d MB: %s...&quot;,</span>
<span class="nc" id="L492">                                                                statementSize,</span>
<span class="nc" id="L493">                                                                DatabaseDescriptor.getPreparedStatementsCacheSizeMB(),</span>
<span class="nc" id="L494">                                                                queryString.substring(0, 200)));</span>
<span class="nc" id="L495">            MD5Digest statementId = computeId(queryString, keyspace);</span>
<span class="nc" id="L496">            preparedStatements.put(statementId, prepared);</span>
<span class="nc" id="L497">            SystemKeyspace.writePreparedStatement(keyspace, statementId, queryString);</span>
<span class="nc" id="L498">            return new ResultMessage.Prepared(statementId, prepared);</span>
        }
    }

    public ResultMessage processPrepared(CQLStatement statement,
                                         QueryState state,
                                         QueryOptions options,
                                         Map&lt;String, ByteBuffer&gt; customPayload,
                                         long queryStartNanoTime)
                                                 throws RequestExecutionException, RequestValidationException
    {
<span class="nc" id="L509">        return processPrepared(statement, state, options, queryStartNanoTime);</span>
    }

    public ResultMessage processPrepared(CQLStatement statement, QueryState queryState, QueryOptions options, long queryStartNanoTime)
    throws RequestExecutionException, RequestValidationException
    {
<span class="nc" id="L515">        List&lt;ByteBuffer&gt; variables = options.getValues();</span>
        // Check to see if there are any bound variables to verify
<span class="nc bnc" id="L517" title="All 4 branches missed.">        if (!(variables.isEmpty() &amp;&amp; (statement.getBoundTerms() == 0)))</span>
        {
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (variables.size() != statement.getBoundTerms())</span>
<span class="nc" id="L520">                throw new InvalidRequestException(String.format(&quot;there were %d markers(?) in CQL but %d bound variables&quot;,</span>
<span class="nc" id="L521">                                                                statement.getBoundTerms(),</span>
<span class="nc" id="L522">                                                                variables.size()));</span>

            // at this point there is a match in count between markers and variables that is non-zero

<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (logger.isTraceEnabled())</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                for (int i = 0; i &lt; variables.size(); i++)</span>
<span class="nc" id="L528">                    logger.trace(&quot;[{}] '{}'&quot;, i+1, variables.get(i));</span>
        }

<span class="nc" id="L531">        metrics.preparedStatementsExecuted.inc();</span>
<span class="nc" id="L532">        return processStatement(statement, queryState, options, queryStartNanoTime);</span>
    }

    public ResultMessage processBatch(BatchStatement statement,
                                      QueryState state,
                                      BatchQueryOptions options,
                                      Map&lt;String, ByteBuffer&gt; customPayload,
                                      long queryStartNanoTime)
                                              throws RequestExecutionException, RequestValidationException
    {
<span class="nc" id="L542">        return processBatch(statement, state, options, queryStartNanoTime);</span>
    }

    public ResultMessage processBatch(BatchStatement batch, QueryState queryState, BatchQueryOptions options, long queryStartNanoTime)
    throws RequestExecutionException, RequestValidationException
    {
<span class="nc" id="L548">        ClientState clientState = queryState.getClientState();</span>
<span class="nc" id="L549">        batch.checkAccess(clientState);</span>
<span class="nc" id="L550">        batch.validate();</span>
<span class="nc" id="L551">        batch.validate(clientState);</span>
<span class="nc" id="L552">        return batch.execute(queryState, options, queryStartNanoTime);</span>
    }

    public static ParsedStatement.Prepared getStatement(String queryStr, ClientState clientState)
    throws RequestValidationException
    {
<span class="fc" id="L558">        Tracing.trace(&quot;Parsing {}&quot;, queryStr);</span>
<span class="fc" id="L559">        ParsedStatement statement = parseStatement(queryStr);</span>

        // Set keyspace for statement that require login
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">        if (statement instanceof CFStatement)</span>
<span class="fc" id="L563">            ((CFStatement)statement).prepareKeyspace(clientState);</span>

<span class="fc" id="L565">        Tracing.trace(&quot;Preparing statement&quot;);</span>
<span class="fc" id="L566">        return statement.prepare(clientState);</span>
    }

    public static &lt;T extends ParsedStatement&gt; T parseStatement(String queryStr, Class&lt;T&gt; klass, String type) throws SyntaxException
    {
        try
        {
<span class="nc" id="L573">            ParsedStatement stmt = parseStatement(queryStr);</span>

<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (!klass.isAssignableFrom(stmt.getClass()))</span>
<span class="nc" id="L576">                throw new IllegalArgumentException(&quot;Invalid query, must be a &quot; + type + &quot; statement but was: &quot; + stmt.getClass());</span>

<span class="nc" id="L578">            return klass.cast(stmt);</span>
        }
<span class="nc" id="L580">        catch (RequestValidationException e)</span>
        {
<span class="nc" id="L582">            throw new IllegalArgumentException(e.getMessage(), e);</span>
        }
    }
    public static ParsedStatement parseStatement(String queryStr) throws SyntaxException
    {
        try
        {
<span class="fc" id="L589">            return CQLFragmentParser.parseAnyUnhandled(CqlParser::query, queryStr);</span>
        }
<span class="nc" id="L591">        catch (CassandraException ce)</span>
        {
<span class="nc" id="L593">            throw ce;</span>
        }
<span class="nc" id="L595">        catch (RuntimeException re)</span>
        {
<span class="nc" id="L597">            logger.error(String.format(&quot;The statement: [%s] could not be parsed.&quot;, queryStr), re);</span>
<span class="nc" id="L598">            throw new SyntaxException(String.format(&quot;Failed parsing statement: [%s] reason: %s %s&quot;,</span>
                                                    queryStr,
<span class="nc" id="L600">                                                    re.getClass().getSimpleName(),</span>
<span class="nc" id="L601">                                                    re.getMessage()));</span>
        }
<span class="nc" id="L603">        catch (RecognitionException e)</span>
        {
<span class="nc" id="L605">            throw new SyntaxException(&quot;Invalid or malformed CQL query string: &quot; + e.getMessage());</span>
        }
    }

    private static int measure(Object key, ParsedStatement.Prepared value)
    {
<span class="nc" id="L611">        return Ints.checkedCast(ObjectSizes.measureDeep(key) + ObjectSizes.measureDeep(value));</span>
    }

    /**
     * Clear our internal statmeent cache for test purposes.
     */
    @VisibleForTesting
    public static void clearInternalStatementsCache()
    {
<span class="nc" id="L620">        internalStatements.clear();</span>
<span class="nc" id="L621">    }</span>

    private static class MigrationSubscriber extends MigrationListener
    {
        private static void removeInvalidPreparedStatements(String ksName, String cfName)
        {
<span class="nc" id="L627">            removeInvalidPreparedStatements(internalStatements.values().iterator(), ksName, cfName);</span>
<span class="nc" id="L628">            removeInvalidPersistentPreparedStatements(preparedStatements.entrySet().iterator(), ksName, cfName);</span>
<span class="nc" id="L629">            removeInvalidPreparedStatements(thriftPreparedStatements.values().iterator(), ksName, cfName);</span>
<span class="nc" id="L630">        }</span>

        private static void removeInvalidPreparedStatementsForFunction(String ksName, String functionName)
        {
<span class="nc bnc" id="L634" title="All 4 branches missed.">            Predicate&lt;Function&gt; matchesFunction = f -&gt; ksName.equals(f.name().keyspace) &amp;&amp; functionName.equals(f.name().name);</span>

<span class="nc" id="L636">            for (Iterator&lt;Map.Entry&lt;MD5Digest, ParsedStatement.Prepared&gt;&gt; iter = preparedStatements.entrySet().iterator();</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">                 iter.hasNext();)</span>
            {
<span class="nc" id="L639">                Map.Entry&lt;MD5Digest, ParsedStatement.Prepared&gt; pstmt = iter.next();</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">                if (Iterables.any(pstmt.getValue().statement.getFunctions(), matchesFunction))</span>
                {
<span class="nc" id="L642">                    SystemKeyspace.removePreparedStatement(pstmt.getKey());</span>
<span class="nc" id="L643">                    iter.remove();</span>
                }
<span class="nc" id="L645">            }</span>


<span class="nc" id="L648">            Iterators.removeIf(internalStatements.values().iterator(),</span>
<span class="nc" id="L649">                               statement -&gt; Iterables.any(statement.statement.getFunctions(), matchesFunction));</span>

<span class="nc" id="L651">            Iterators.removeIf(thriftPreparedStatements.values().iterator(),</span>
<span class="nc" id="L652">                               statement -&gt; Iterables.any(statement.statement.getFunctions(), matchesFunction));</span>
<span class="nc" id="L653">        }</span>

        private static void removeInvalidPersistentPreparedStatements(Iterator&lt;Map.Entry&lt;MD5Digest, ParsedStatement.Prepared&gt;&gt; iterator,
                                                                      String ksName, String cfName)
        {
<span class="nc bnc" id="L658" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L660">                Map.Entry&lt;MD5Digest, ParsedStatement.Prepared&gt; entry = iterator.next();</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (shouldInvalidate(ksName, cfName, entry.getValue().statement))</span>
                {
<span class="nc" id="L663">                    SystemKeyspace.removePreparedStatement(entry.getKey());</span>
<span class="nc" id="L664">                    iterator.remove();</span>
                }
<span class="nc" id="L666">            }</span>
<span class="nc" id="L667">        }</span>

        private static void removeInvalidPreparedStatements(Iterator&lt;ParsedStatement.Prepared&gt; iterator, String ksName, String cfName)
        {
<span class="nc bnc" id="L671" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc bnc" id="L673" title="All 2 branches missed.">                if (shouldInvalidate(ksName, cfName, iterator.next().statement))</span>
<span class="nc" id="L674">                    iterator.remove();</span>
            }
<span class="nc" id="L676">        }</span>

        private static boolean shouldInvalidate(String ksName, String cfName, CQLStatement statement)
        {
            String statementKsName;
            String statementCfName;

<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (statement instanceof ModificationStatement)</span>
            {
<span class="nc" id="L685">                ModificationStatement modificationStatement = ((ModificationStatement) statement);</span>
<span class="nc" id="L686">                statementKsName = modificationStatement.keyspace();</span>
<span class="nc" id="L687">                statementCfName = modificationStatement.columnFamily();</span>
<span class="nc" id="L688">            }</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">            else if (statement instanceof SelectStatement)</span>
            {
<span class="nc" id="L691">                SelectStatement selectStatement = ((SelectStatement) statement);</span>
<span class="nc" id="L692">                statementKsName = selectStatement.keyspace();</span>
<span class="nc" id="L693">                statementCfName = selectStatement.columnFamily();</span>
<span class="nc" id="L694">            }</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            else if (statement instanceof BatchStatement)</span>
            {
<span class="nc" id="L697">                BatchStatement batchStatement = ((BatchStatement) statement);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">                for (ModificationStatement stmt : batchStatement.getStatements())</span>
                {
<span class="nc bnc" id="L700" title="All 2 branches missed.">                    if (shouldInvalidate(ksName, cfName, stmt))</span>
<span class="nc" id="L701">                        return true;</span>
<span class="nc" id="L702">                }</span>
<span class="nc" id="L703">                return false;</span>
            }
            else
            {
<span class="nc" id="L707">                return false;</span>
            }

<span class="nc bnc" id="L710" title="All 6 branches missed.">            return ksName.equals(statementKsName) &amp;&amp; (cfName == null || cfName.equals(statementCfName));</span>
        }

        public void onCreateFunction(String ksName, String functionName, List&lt;AbstractType&lt;?&gt;&gt; argTypes)
        {
<span class="nc" id="L715">            onCreateFunctionInternal(ksName, functionName, argTypes);</span>
<span class="nc" id="L716">        }</span>

        public void onCreateAggregate(String ksName, String aggregateName, List&lt;AbstractType&lt;?&gt;&gt; argTypes)
        {
<span class="nc" id="L720">            onCreateFunctionInternal(ksName, aggregateName, argTypes);</span>
<span class="nc" id="L721">        }</span>

        private static void onCreateFunctionInternal(String ksName, String functionName, List&lt;AbstractType&lt;?&gt;&gt; argTypes)
        {
            // in case there are other overloads, we have to remove all overloads since argument type
            // matching may change (due to type casting)
<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (Schema.instance.getKSMetaData(ksName).functions.get(new FunctionName(ksName, functionName)).size() &gt; 1)</span>
<span class="nc" id="L728">                removeInvalidPreparedStatementsForFunction(ksName, functionName);</span>
<span class="nc" id="L729">        }</span>

        public void onUpdateColumnFamily(String ksName, String cfName, boolean affectsStatements)
        {
<span class="nc" id="L733">            logger.trace(&quot;Column definitions for {}.{} changed, invalidating related prepared statements&quot;, ksName, cfName);</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">            if (affectsStatements)</span>
<span class="nc" id="L735">                removeInvalidPreparedStatements(ksName, cfName);</span>
<span class="nc" id="L736">        }</span>

        public void onUpdateFunction(String ksName, String functionName, List&lt;AbstractType&lt;?&gt;&gt; argTypes)
        {
            // Updating a function may imply we've changed the body of the function, so we need to invalid statements so that
            // the new definition is picked (the function is resolved at preparation time).
            // TODO: if the function has multiple overload, we could invalidate only the statement refering to the overload
            // that was updated. This requires a few changes however and probably doesn't matter much in practice.
<span class="nc" id="L744">            removeInvalidPreparedStatementsForFunction(ksName, functionName);</span>
<span class="nc" id="L745">        }</span>

        public void onUpdateAggregate(String ksName, String aggregateName, List&lt;AbstractType&lt;?&gt;&gt; argTypes)
        {
            // Updating a function may imply we've changed the body of the function, so we need to invalid statements so that
            // the new definition is picked (the function is resolved at preparation time).
            // TODO: if the function has multiple overload, we could invalidate only the statement refering to the overload
            // that was updated. This requires a few changes however and probably doesn't matter much in practice.
<span class="nc" id="L753">            removeInvalidPreparedStatementsForFunction(ksName, aggregateName);</span>
<span class="nc" id="L754">        }</span>

        public void onDropKeyspace(String ksName)
        {
<span class="nc" id="L758">            logger.trace(&quot;Keyspace {} was dropped, invalidating related prepared statements&quot;, ksName);</span>
<span class="nc" id="L759">            removeInvalidPreparedStatements(ksName, null);</span>
<span class="nc" id="L760">        }</span>

        public void onDropColumnFamily(String ksName, String cfName)
        {
<span class="nc" id="L764">            logger.trace(&quot;Table {}.{} was dropped, invalidating related prepared statements&quot;, ksName, cfName);</span>
<span class="nc" id="L765">            removeInvalidPreparedStatements(ksName, cfName);</span>
<span class="nc" id="L766">        }</span>

        public void onDropFunction(String ksName, String functionName, List&lt;AbstractType&lt;?&gt;&gt; argTypes)
        {
<span class="nc" id="L770">            removeInvalidPreparedStatementsForFunction(ksName, functionName);</span>
<span class="nc" id="L771">        }</span>

        public void onDropAggregate(String ksName, String aggregateName, List&lt;AbstractType&lt;?&gt;&gt; argTypes)
        {
<span class="nc" id="L775">            removeInvalidPreparedStatementsForFunction(ksName, aggregateName);</span>
<span class="nc" id="L776">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>