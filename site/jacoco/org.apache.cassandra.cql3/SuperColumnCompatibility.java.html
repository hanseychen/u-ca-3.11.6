<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SuperColumnCompatibility.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">SuperColumnCompatibility.java</span></div><h1>SuperColumnCompatibility.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.cql3;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.ColumnDefinition;
import org.apache.cassandra.cql3.restrictions.SingleColumnRestriction;
import org.apache.cassandra.cql3.restrictions.SingleRestriction;
import org.apache.cassandra.cql3.restrictions.TermSlice;
import org.apache.cassandra.cql3.selection.Selection;
import org.apache.cassandra.cql3.statements.Bound;
import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.Columns;
import org.apache.cassandra.db.CompactTables;
import org.apache.cassandra.db.PartitionColumns;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.MapType;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.CellPath;
import org.apache.cassandra.db.rows.ComplexColumnData;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.RowIterator;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.Pair;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkNotNull;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
import static org.apache.cassandra.cql3.statements.SelectStatement.getComponents;

/**
 * Class incapsulating the helper logic to handle SELECT / UPDATE / INSERT special-cases related
 * to SuperColumn tables in applicable scenarios.
 *
 * SuperColumn families have a special layout and are represented as a Map internally. These tables
 * have two special columns (called `column2` and `value` by default):
 *
 *   * `column2`, {@link CFMetaData#superCfValueColumn}, a key of the SuperColumn map, exposed as a
 *   REGULAR column, but stored in schema tables as a CLUSTERING column to make a distinction from
 *   the SC value column in case of renames.
 *   * `value`, {@link CFMetaData#compactValueColumn()}, a value of the SuperColumn map, exposed and
 *   stored as a REGULAR column
 *
 * These columns have to be translated to this internal representation as key and value, correspondingly.
 *
 * In CQL terms, the SuperColumn families is encoded with:
 *
 *   CREATE TABLE super (
 *      key [key_validation_class],
 *      super_column_name [comparator],
 *      [column_metadata_1] [type1],
 *      ...,
 *      [column_metadata_n] [type1],
 *      &quot;&quot; map&lt;[sub_comparator], [default_validation_class]&gt;
 *      PRIMARY KEY (key, super_column_name)
 *   )
 *
 * In other words, every super column is encoded by a row. That row has one column for each defined
 * &quot;column_metadata&quot;, but it also has a special map column (whose name is the empty string as this is
 * guaranteed to never conflict with a user-defined &quot;column_metadata&quot;) which stores the super column
 * &quot;dynamic&quot; sub-columns.
 *
 * On write path, `column2` and `value` columns are translated to the key and value of the
 * underlying map. During the read, the inverse conversion is done. Deletes are converted into
 * discards by the key in the underlying map. Counters are handled by translating an update to a
 * counter update with a cell path. See {@link SuperColumnRestrictions} for the details.
 *
 * Since non-dense SuperColumn families do not modify the contents of the internal map through in CQL
 * and do not expose this via CQL either, reads, writes and deletes are handled normally.
 *
 * Sidenote: a _dense_ SuperColumn Familiy is the one that has no added REGULAR columns.
 */
<span class="nc bnc" id="L104" title="All 2 branches missed.">public class SuperColumnCompatibility</span>
{
    // We use an empty value for the 1) this can't conflict with a user-defined column and 2) this actually
    // validate with any comparator which makes it convenient for columnDefinitionComparator().
<span class="nc" id="L108">    public static final ByteBuffer SUPER_COLUMN_MAP_COLUMN = ByteBufferUtil.EMPTY_BYTE_BUFFER;</span>
<span class="nc" id="L109">    public static final String SUPER_COLUMN_MAP_COLUMN_STR = UTF8Type.instance.compose(SUPER_COLUMN_MAP_COLUMN);</span>

    /**
     * Dense flag might have been incorrectly set if the node was upgraded from 2.x before CASSANDRA-12373.
     *
     * For 3.x created tables, the flag is set correctly in ThriftConversion code.
     */
    public static boolean recalculateIsDense(Columns columns)
    {
<span class="nc bnc" id="L118" title="All 4 branches missed.">        return columns.size() == 1 &amp;&amp; columns.getComplex(0).name.toString().isEmpty();</span>
    }

    /**
     * For _dense_ SuperColumn Families, the supercolumn key column has to be translated to the collection subselection
     * query in order to avoid reading an entire collection and then filtering out the results.
     */
    public static ColumnFilter getColumnFilter(CFMetaData cfm, QueryOptions queryOptions, SuperColumnRestrictions restrictions)
    {
<span class="nc bnc" id="L127" title="All 6 branches missed.">        assert cfm.isSuper() &amp;&amp; cfm.isDense();</span>

<span class="nc" id="L129">        ColumnFilter.Builder builder = ColumnFilter.selectionBuilder();</span>
<span class="nc" id="L130">        builder.add(cfm.compactValueColumn());</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (restrictions.keySliceRestriction != null)</span>
        {
<span class="nc" id="L134">            SingleColumnRestriction.SuperColumnKeySliceRestriction restriction = restrictions.keySliceRestriction;</span>
<span class="nc" id="L135">            TermSlice slice = restriction.slice;</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">            ByteBuffer start = slice.hasBound(Bound.START) ? slice.bound(Bound.START).bindAndGet(queryOptions) : null;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            ByteBuffer end = slice.hasBound(Bound.END) ? slice.bound(Bound.END).bindAndGet(queryOptions) : null;</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">            builder.slice(cfm.compactValueColumn(),</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                          start == null ? CellPath.BOTTOM : CellPath.create(start),</span>
<span class="nc" id="L142">                          end == null ? CellPath.TOP : CellPath.create(end));</span>
<span class="nc" id="L143">        }</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        else if (restrictions.keyEQRestriction != null)</span>
        {
<span class="nc" id="L146">            SingleColumnRestriction.SuperColumnKeyEQRestriction restriction = restrictions.keyEQRestriction;</span>
<span class="nc" id="L147">            ByteBuffer value = restriction.bindValue(queryOptions);</span>
<span class="nc" id="L148">            builder.select(cfm.compactValueColumn(), CellPath.create(value));</span>
<span class="nc" id="L149">        }</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        else if (restrictions.keyINRestriction != null)</span>
        {
<span class="nc" id="L152">            SingleColumnRestriction.SuperColumnKeyINRestriction cast = restrictions.keyINRestriction;</span>
<span class="nc" id="L153">            Set&lt;ByteBuffer&gt; keyINRestrictionValues = new TreeSet&lt;ByteBuffer&gt;(((MapType) cfm.compactValueColumn().type).getKeysType());</span>
<span class="nc" id="L154">            keyINRestrictionValues.addAll(cast.getValues(queryOptions));</span>

<span class="nc bnc" id="L156" title="All 2 branches missed.">            for (ByteBuffer value : keyINRestrictionValues)</span>
<span class="nc" id="L157">                builder.select(cfm.compactValueColumn(), CellPath.create(value));</span>
<span class="nc" id="L158">        }</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        else if (restrictions.multiEQRestriction != null)</span>
        {
<span class="nc" id="L161">            SingleColumnRestriction.SuperColumnMultiEQRestriction restriction = restrictions.multiEQRestriction;</span>
<span class="nc" id="L162">            ByteBuffer value = restriction.secondValue;</span>
<span class="nc" id="L163">            builder.select(cfm.compactValueColumn(), CellPath.create(value));</span>
        }

<span class="nc" id="L166">        return builder.build();</span>
    }

    /**
     * For _dense_ SuperColumn Families.
     *
     * On read path, instead of writing row per map, we have to write a row per key/value pair in map.
     *
     * For example:
     *
     *   | partition-key | clustering-key | { key1: value1, key2: value2 } |
     *
     * Will be translated to:
     *
     *   | partition-key | clustering-key | key1 | value1 |
     *   | partition-key | clustering-key | key2 | value2 |
     *
     */
    public static void processPartition(CFMetaData cfm, Selection selection, RowIterator partition, Selection.ResultSetBuilder result, ProtocolVersion protocolVersion,
                                        SuperColumnRestrictions restrictions, QueryOptions queryOptions)
    {
<span class="nc bnc" id="L187" title="All 4 branches missed.">        assert cfm.isDense();</span>
<span class="nc" id="L188">        ByteBuffer[] keyComponents = getComponents(cfm, partition.partitionKey());</span>

<span class="nc" id="L190">        int nowInSeconds = FBUtilities.nowInSeconds();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        while (partition.hasNext())</span>
        {
<span class="nc" id="L193">            Row row = partition.next();</span>

<span class="nc" id="L195">            ComplexColumnData ccd = row.getComplexColumnData(cfm.compactValueColumn());</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (ccd == null)</span>
<span class="nc" id="L198">                continue;</span>

<span class="nc" id="L200">            Iterator&lt;Cell&gt; cellIter = ccd.iterator();</span>

            outer:
<span class="nc bnc" id="L203" title="All 2 branches missed.">            while (cellIter.hasNext())</span>
            {
<span class="nc" id="L205">                Cell cell = cellIter.next();</span>
<span class="nc" id="L206">                ByteBuffer superColumnKey = cell.path().get(0);</span>

<span class="nc bnc" id="L208" title="All 2 branches missed.">                if (restrictions != null)</span>
                {
                    // Slice on SuperColumn key
<span class="nc bnc" id="L211" title="All 2 branches missed.">                    if (restrictions.keySliceRestriction != null)</span>
                    {
<span class="nc bnc" id="L213" title="All 2 branches missed.">                        for (Bound bound : Bound.values())</span>
                        {
<span class="nc bnc" id="L215" title="All 2 branches missed.">                            if (restrictions.keySliceRestriction.hasBound(bound) &amp;&amp;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                                !restrictions.keySliceRestriction.isInclusive(bound))</span>
                            {
<span class="nc" id="L218">                                ByteBuffer excludedValue = restrictions.keySliceRestriction.bindValue(queryOptions);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                                if (excludedValue.equals(superColumnKey))</span>
<span class="nc" id="L220">                                    continue outer;</span>
                            }
                        }
                    }

                    // Multi-column restriction on clustering+SuperColumn key
<span class="nc bnc" id="L226" title="All 2 branches missed.">                    if (restrictions.multiSliceRestriction != null &amp;&amp;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                        cfm.comparator.compare(row.clustering(), Clustering.make(restrictions.multiSliceRestriction.firstValue)) == 0)</span>
                    {
<span class="nc" id="L229">                        AbstractType t = ((MapType) cfm.compactValueColumn().type).getKeysType();</span>
<span class="nc" id="L230">                        int cmp = t.compare(superColumnKey, restrictions.multiSliceRestriction.secondValue);</span>

<span class="nc bnc" id="L232" title="All 4 branches missed.">                        if ((cmp == 0 &amp;&amp; !restrictions.multiSliceRestriction.trueInclusive) ||     // EQ</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">                            (restrictions.multiSliceRestriction.hasBound(Bound.END) &amp;&amp; cmp &gt; 0) || // LT</span>
<span class="nc bnc" id="L234" title="All 4 branches missed.">                            (restrictions.multiSliceRestriction.hasBound(Bound.START) &amp;&amp; cmp &lt; 0)) // GT</span>
<span class="nc" id="L235">                            continue outer;</span>
                    }
                }

<span class="nc" id="L239">                Row staticRow = partition.staticRow();</span>
<span class="nc" id="L240">                result.newRow(partition.partitionKey(), staticRow.clustering());</span>

<span class="nc bnc" id="L242" title="All 2 branches missed.">                for (ColumnDefinition def : selection.getColumns())</span>
                {
<span class="nc bnc" id="L244" title="All 2 branches missed.">                    if (cfm.isSuperColumnKeyColumn(def))</span>
                    {
<span class="nc" id="L246">                        result.add(superColumnKey);</span>
                    }
<span class="nc bnc" id="L248" title="All 2 branches missed.">                    else if (cfm.isSuperColumnValueColumn(def))</span>
                    {
<span class="nc" id="L250">                        result.add(cell, nowInSeconds);</span>
                    }
                    else
                    {
<span class="nc bnc" id="L254" title="All 4 branches missed.">                        switch (def.kind)</span>
                        {
                            case PARTITION_KEY:
<span class="nc" id="L257">                                result.add(keyComponents[def.position()]);</span>
<span class="nc" id="L258">                                break;</span>
                            case CLUSTERING:
<span class="nc" id="L260">                                result.add(row.clustering().get(def.position()));</span>
<span class="nc" id="L261">                                break;</span>
                            case REGULAR:
                            case STATIC:
<span class="nc" id="L264">                                throw new AssertionError(String.format(&quot;Invalid column '%s' found in SuperColumn table&quot;, def.name.toString()));</span>
                        }
                    }
<span class="nc" id="L267">                }</span>
<span class="nc" id="L268">            }</span>
<span class="nc" id="L269">        }</span>
<span class="nc" id="L270">    }</span>

    /**
     * For _dense_ SuperColumn Families.
     *
     * On the write path, we have to do combine the columns into a key/value pair:
     *
     * So inserting a row:
     *
     *     | partition-key | clustering-key | key1 | value1 |
     *
     * Would result into:
     *
     *     | partition-key | clustering-key | {key1: value1} |
     *
     * or adding / overwriting the value for `key1`.
     */
    public static void prepareInsertOperations(CFMetaData cfm,
                                               List&lt;ColumnDefinition.Raw&gt; columnNames,
                                               WhereClause.Builder whereClause,
                                               List&lt;Term.Raw&gt; columnValues,
                                               VariableSpecifications boundNames,
                                               Operations operations)
    {
<span class="nc" id="L294">        List&lt;ColumnDefinition&gt; defs = new ArrayList&lt;&gt;(columnNames.size());</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        for (int i = 0; i &lt; columnNames.size(); i++)</span>
        {
<span class="nc" id="L297">            ColumnDefinition id = columnNames.get(i).prepare(cfm);</span>
<span class="nc" id="L298">            defs.add(id);</span>
        }

<span class="nc" id="L301">        prepareInsertOperations(cfm, defs, boundNames, columnValues, whereClause, operations);</span>
<span class="nc" id="L302">    }</span>

    /**
     * For _dense_ SuperColumn Families.
     *
     * {@link #prepareInsertOperations(CFMetaData, List, VariableSpecifications, List, WhereClause.Builder, Operations)},
     * but for INSERT JSON queries
     */
    public static void prepareInsertJSONOperations(CFMetaData cfm,
                                                   List&lt;ColumnDefinition&gt; defs,
                                                   VariableSpecifications boundNames,
                                                   Json.Prepared prepared,
                                                   WhereClause.Builder whereClause,
                                                   Operations operations)
    {
<span class="nc" id="L317">        List&lt;Term.Raw&gt; columnValues = new ArrayList&lt;&gt;(defs.size());</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        for (ColumnDefinition def : defs)</span>
<span class="nc" id="L319">            columnValues.add(prepared.getRawTermForColumn(def, true));</span>

<span class="nc" id="L321">        prepareInsertOperations(cfm, defs, boundNames, columnValues, whereClause, operations);</span>
<span class="nc" id="L322">    }</span>

    private static void prepareInsertOperations(CFMetaData cfm,
                                                List&lt;ColumnDefinition&gt; defs,
                                                VariableSpecifications boundNames,
                                                List&lt;Term.Raw&gt; columnValues,
                                                WhereClause.Builder whereClause,
                                                Operations operations)
    {
<span class="nc bnc" id="L331" title="All 4 branches missed.">        assert cfm.isDense();</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">        assert defs.size() == columnValues.size();</span>

<span class="nc" id="L334">        Term.Raw superColumnKey = null;</span>
<span class="nc" id="L335">        Term.Raw superColumnValue = null;</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">        for (int i = 0, size = defs.size(); i &lt; size; i++)</span>
        {
<span class="nc" id="L339">            ColumnDefinition def = defs.get(i);</span>
<span class="nc" id="L340">            Term.Raw raw = columnValues.get(i);</span>

<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (cfm.isSuperColumnKeyColumn(def))</span>
            {
<span class="nc" id="L344">                superColumnKey = raw;</span>
<span class="nc" id="L345">                collectMarkerSpecifications(raw, boundNames, def);</span>
            }
<span class="nc bnc" id="L347" title="All 2 branches missed.">            else if (cfm.isSuperColumnValueColumn(def))</span>
            {
<span class="nc" id="L349">                superColumnValue = raw;</span>
<span class="nc" id="L350">                collectMarkerSpecifications(raw, boundNames, def);</span>
            }
<span class="nc bnc" id="L352" title="All 2 branches missed.">            else if (def.isPrimaryKeyColumn())</span>
            {
<span class="nc" id="L354">                whereClause.add(new SingleColumnRelation(ColumnDefinition.Raw.forColumn(def), Operator.EQ, raw));</span>
            }
            else
            {
<span class="nc" id="L358">                throw invalidRequest(&quot;Invalid column {} in where clause&quot;);</span>
            }
        }

<span class="nc bnc" id="L362" title="All 2 branches missed.">        checkTrue(superColumnValue != null,</span>
                  &quot;Column value is mandatory for SuperColumn tables&quot;);
<span class="nc bnc" id="L364" title="All 2 branches missed.">        checkTrue(superColumnKey != null,</span>
                  &quot;Column key is mandatory for SuperColumn tables&quot;);

<span class="nc" id="L367">        Operation operation = new Operation.SetElement(superColumnKey, superColumnValue).prepare(cfm, cfm.compactValueColumn());</span>
<span class="nc" id="L368">        operations.add(operation);</span>
<span class="nc" id="L369">    }</span>

    /**
     * Collect the marker specifications for the bound columns manually, since the operations on a column are
     * converted to the operations on the collection element.
     */
    private static void collectMarkerSpecifications(Term.Raw raw, VariableSpecifications boundNames, ColumnDefinition def)
    {
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (raw instanceof AbstractMarker.Raw)</span>
<span class="nc" id="L378">            boundNames.add(((AbstractMarker.Raw) raw).bindIndex(), def);</span>
<span class="nc" id="L379">    }</span>

    /**
     * For _dense_ SuperColumn Families.
     *
     * During UPDATE operation, the update by clustering (with correponding relation in WHERE clause)
     * has to be substituted with an update to the map that backs the given SuperColumn.
     *
     * For example, an update such as:
     *
     *     UPDATE ... SET value = 'value1' WHERE key = 'pk' AND column1 = 'ck' AND column2 = 'mk'
     *
     * Will update the value under key 'mk' in the map, backing the SuperColumn, located in the row
     * with clustering 'ck' in the partition with key 'pk'.
     */
    public static WhereClause prepareUpdateOperations(CFMetaData cfm,
                                                      WhereClause whereClause,
                                                      List&lt;Pair&lt;ColumnDefinition.Raw, Operation.RawUpdate&gt;&gt; updates,
                                                      VariableSpecifications boundNames,
                                                      Operations operations)
    {
<span class="nc bnc" id="L400" title="All 4 branches missed.">        assert cfm.isDense();</span>
<span class="nc" id="L401">        Term.Raw superColumnKey = null;</span>
<span class="nc" id="L402">        Term.Raw superColumnValue = null;</span>

<span class="nc" id="L404">        List&lt;Relation&gt; newRelations = new ArrayList&lt;&gt;(whereClause.relations.size());</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (int i = 0; i &lt; whereClause.relations.size(); i++)</span>
        {
<span class="nc" id="L407">            SingleColumnRelation relation = (SingleColumnRelation) whereClause.relations.get(i);</span>
<span class="nc" id="L408">            ColumnDefinition def = relation.getEntity().prepare(cfm);</span>

<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (cfm.isSuperColumnKeyColumn(def))</span>
            {
<span class="nc" id="L412">                superColumnKey = relation.getValue();</span>
<span class="nc" id="L413">                collectMarkerSpecifications(superColumnKey, boundNames, def);</span>
            }
            else
            {
<span class="nc" id="L417">                newRelations.add(relation);</span>
            }
        }

<span class="nc bnc" id="L421" title="All 2 branches missed.">        checkTrue(superColumnKey != null,</span>
                  &quot;Column key is mandatory for SuperColumn tables&quot;);

<span class="nc bnc" id="L424" title="All 2 branches missed.">        for (Pair&lt;ColumnDefinition.Raw, Operation.RawUpdate&gt; entry : updates)</span>
        {
<span class="nc" id="L426">            ColumnDefinition def = entry.left.prepare(cfm);</span>

<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (!cfm.isSuperColumnValueColumn(def))</span>
<span class="nc" id="L429">                throw invalidRequest(&quot;Column `%s` of type `%s` found in SET part&quot;, def.name, def.type.asCQL3Type());</span>

            Operation operation;

<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (entry.right instanceof Operation.Addition)</span>
            {
<span class="nc" id="L435">                Operation.Addition op = (Operation.Addition) entry.right;</span>
<span class="nc" id="L436">                superColumnValue = op.value();</span>

<span class="nc" id="L438">                operation = new Operation.ElementAddition(superColumnKey, superColumnValue).prepare(cfm, cfm.compactValueColumn());</span>
<span class="nc" id="L439">            }</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">            else if (entry.right instanceof Operation.Substraction)</span>
            {
<span class="nc" id="L442">                Operation.Substraction op = (Operation.Substraction) entry.right;</span>
<span class="nc" id="L443">                superColumnValue = op.value();</span>

<span class="nc" id="L445">                operation = new Operation.ElementSubtraction(superColumnKey, superColumnValue).prepare(cfm, cfm.compactValueColumn());</span>
<span class="nc" id="L446">            }</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            else if (entry.right instanceof Operation.SetValue)</span>
            {
<span class="nc" id="L449">                Operation.SetValue op = (Operation.SetValue) entry.right;</span>
<span class="nc" id="L450">                superColumnValue = op.value();</span>

<span class="nc" id="L452">                operation = new Operation.SetElement(superColumnKey, superColumnValue).prepare(cfm, cfm.compactValueColumn());</span>
<span class="nc" id="L453">            }</span>
            else
            {
<span class="nc" id="L456">                throw invalidRequest(&quot;Invalid operation `%s` on column `%s` of type `%s` found in SET part&quot;, entry.right, def.name, def.type.asCQL3Type());</span>
            }

<span class="nc" id="L459">            collectMarkerSpecifications(superColumnValue, boundNames, def);</span>
<span class="nc" id="L460">            operations.add(operation);</span>
<span class="nc" id="L461">        }</span>

<span class="nc bnc" id="L463" title="All 2 branches missed.">        checkTrue(superColumnValue != null,</span>
                  &quot;Column value is mandatory for SuperColumn tables&quot;);

<span class="nc bnc" id="L466" title="All 2 branches missed.">        return newRelations.size() != whereClause.relations.size() ? whereClause.copy(newRelations) : whereClause;</span>
    }

    /**
     * Rebuilds LWT conditions on SuperColumn _value_ column.
     *
     * Conditions have to be changed to correspond the internal representation of SuperColumn value, since it's not
     * a separate column, but a value in a hidden compact value column.
     */
    public static Conditions rebuildLWTColumnConditions(Conditions conditions, CFMetaData cfm, WhereClause whereClause)
    {
<span class="nc bnc" id="L477" title="All 6 branches missed.">        if (conditions.isEmpty() || conditions.isIfExists() || conditions.isIfNotExists())</span>
<span class="nc" id="L478">            return conditions;</span>

<span class="nc" id="L480">        ColumnConditions.Builder builder = ColumnConditions.newBuilder();</span>
<span class="nc" id="L481">        Collection&lt;ColumnCondition&gt; columnConditions = ((ColumnConditions) conditions).columnConditions();</span>

<span class="nc" id="L483">        Pair&lt;ColumnDefinition, Relation&gt; superColumnKeyRelation = SuperColumnCompatibility.getSuperColumnKeyRelation(whereClause.relations, cfm);</span>

<span class="nc" id="L485">        checkNotNull(superColumnKeyRelation,</span>
                     &quot;Lightweight transactions on SuperColumn tables are only supported with supplied SuperColumn key&quot;);

<span class="nc bnc" id="L488" title="All 2 branches missed.">        for (ColumnCondition columnCondition : columnConditions)</span>
        {
<span class="nc" id="L490">            checkTrue(cfm.isSuperColumnValueColumn(columnCondition.column),</span>
                      &quot;Lightweight transactions are only supported on the value column of SuperColumn tables&quot;);

<span class="nc" id="L493">            Term.Raw value = superColumnKeyRelation.right.getValue();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            Term collectionElemnt = value instanceof AbstractMarker.Raw ?</span>
<span class="nc" id="L495">                                    new Constants.Marker(((AbstractMarker.Raw) value).bindIndex(),</span>
                                                         superColumnKeyRelation.left) :
<span class="nc" id="L497">                                    value.prepare(cfm.ksName, superColumnKeyRelation.left);</span>
<span class="nc" id="L498">            builder.add(ColumnCondition.condition(cfm.compactValueColumn(),</span>
                                                  collectionElemnt,
<span class="nc" id="L500">                                                  columnCondition.value(), columnCondition.operator));</span>
<span class="nc" id="L501">        }</span>

<span class="nc" id="L503">        return builder.build();</span>
    }

    /**
     * Returns a relation on the SuperColumn key
     */
    private static Pair&lt;ColumnDefinition, Relation&gt; getSuperColumnKeyRelation(List&lt;Relation&gt; relations, CFMetaData cfm)
    {
<span class="nc bnc" id="L511" title="All 2 branches missed.">        for (int i = 0; i &lt; relations.size(); i++)</span>
        {
<span class="nc" id="L513">            SingleColumnRelation relation = (SingleColumnRelation) relations.get(i);</span>
<span class="nc" id="L514">            ColumnDefinition def = relation.getEntity().prepare(cfm);</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (cfm.isSuperColumnKeyColumn(def))</span>
<span class="nc" id="L517">                return Pair.create(def, relation);</span>
        }
<span class="nc" id="L519">        return null;</span>
    }

    /**
     * For _dense_ SuperColumn Families.
     *
     * Delete, when the &quot;regular&quot; columns are present, have to be translated into
     * deletion of value in the internal map by key.
     *
     * For example, delete such as:
     *
     *     DELETE FROM ... WHERE key = 'pk' AND column1 = 'ck' AND column2 = 'mk'
     *
     * Will delete a value under 'mk' from the map, located in the row with clustering key 'ck' in the partition
     * with key 'pk'.
     */
    public static WhereClause prepareDeleteOperations(CFMetaData cfm,
                                                      WhereClause whereClause,
                                                      VariableSpecifications boundNames,
                                                      Operations operations)
    {
<span class="nc bnc" id="L540" title="All 4 branches missed.">        assert cfm.isDense();</span>
<span class="nc" id="L541">        List&lt;Relation&gt; newRelations = new ArrayList&lt;&gt;(whereClause.relations.size());</span>

<span class="nc bnc" id="L543" title="All 2 branches missed.">        for (int i = 0; i &lt; whereClause.relations.size(); i++)</span>
        {
<span class="nc" id="L545">            Relation orig = whereClause.relations.get(i);</span>

<span class="nc" id="L547">            checkFalse(orig.isMultiColumn(),</span>
                       &quot;Multi-column relations cannot be used in WHERE clauses for UPDATE and DELETE statements: %s&quot;, orig);
<span class="nc" id="L549">            checkFalse(orig.onToken(),</span>
                       &quot;Token relations cannot be used in WHERE clauses for UPDATE and DELETE statements: %s&quot;, orig);

<span class="nc" id="L552">            SingleColumnRelation relation = (SingleColumnRelation) orig;</span>
<span class="nc" id="L553">            ColumnDefinition def = relation.getEntity().prepare(cfm);</span>

<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (cfm.isSuperColumnKeyColumn(def))</span>
            {
<span class="nc" id="L557">                Term.Raw value = relation.getValue();</span>

<span class="nc bnc" id="L559" title="All 2 branches missed.">                if (value instanceof AbstractMarker.Raw)</span>
<span class="nc" id="L560">                    boundNames.add(((AbstractMarker.Raw) value).bindIndex(), def);</span>

<span class="nc" id="L562">                Operation operation = new Maps.DiscarderByKey(cfm.compactValueColumn(), value.prepare(cfm.ksName, def));</span>
<span class="nc" id="L563">                operations.add(operation);</span>
<span class="nc" id="L564">            }</span>
            else
            {
<span class="nc" id="L567">                newRelations.add(relation);</span>
            }
        }

<span class="nc bnc" id="L571" title="All 2 branches missed.">        return newRelations.size() != whereClause.relations.size() ? whereClause.copy(newRelations) : whereClause;</span>
    }

    /**
     * Create a column name generator for SuperColumns
     */
    public static CompactTables.DefaultNames columnNameGenerator(List&lt;ColumnDefinition&gt; partitionKeyColumns,
                                                                 List&lt;ColumnDefinition&gt; clusteringColumns,
                                                                 PartitionColumns partitionColumns)
    {
<span class="nc" id="L581">        Set&lt;String&gt; names = new HashSet&lt;&gt;();</span>
        // If the clustering column was renamed, the supercolumn key's default nname still can't be `column1` (SuperColumn
        // key renames are handled separately by looking up an existing column).
<span class="nc" id="L584">        names.add(&quot;column1&quot;);</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        for (ColumnDefinition columnDefinition: partitionKeyColumns)</span>
<span class="nc" id="L586">            names.add(columnDefinition.name.toString());</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        for (ColumnDefinition columnDefinition: clusteringColumns)</span>
<span class="nc" id="L588">            names.add(columnDefinition.name.toString());</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        for (ColumnDefinition columnDefinition: partitionColumns)</span>
<span class="nc" id="L590">            names.add(columnDefinition.name.toString());</span>

<span class="nc" id="L592">        return CompactTables.defaultNameGenerator(names);</span>
    }

    /**
     * Find a SuperColumn key column if it's available (for example, when it was renamed) or create one with a default name.
     */
    public static ColumnDefinition getSuperCfKeyColumn(CFMetaData cfm, List&lt;ColumnDefinition&gt; clusteringColumns, CompactTables.DefaultNames defaultNames)
    {
<span class="nc bnc" id="L600" title="All 4 branches missed.">        assert cfm.isDense();</span>

<span class="nc" id="L602">        MapType mapType = (MapType) cfm.compactValueColumn().type;</span>
        // Pre CASSANDRA-12373 3.x-created supercolumn family
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (clusteringColumns.size() == 1)</span>
        {
            // create a new one with a default name
<span class="nc" id="L607">            ColumnIdentifier identifier = ColumnIdentifier.getInterned(defaultNames.defaultClusteringName(), true);</span>
<span class="nc" id="L608">            return new ColumnDefinition(cfm.ksName, cfm.cfName, identifier, mapType.getKeysType(), ColumnDefinition.NO_POSITION, ColumnDefinition.Kind.REGULAR);</span>
        }

        // Upgrade path: table created in 2.x, handle pre-created columns and/or renames.
<span class="nc bnc" id="L612" title="All 4 branches missed.">        assert clusteringColumns.size() == 2 : clusteringColumns;</span>
<span class="nc" id="L613">        ColumnDefinition cd = clusteringColumns.get(1);</span>

<span class="nc bnc" id="L615" title="All 4 branches missed.">        assert cd.type.equals(mapType.getKeysType()) : cd.type + &quot; != &quot; + mapType.getKeysType();</span>
<span class="nc" id="L616">        return new ColumnDefinition(cfm.ksName, cfm.cfName, cd.name, mapType.getKeysType(), ColumnDefinition.NO_POSITION, ColumnDefinition.Kind.REGULAR);</span>
    }

    /**
     * Find a SuperColumn value column if it's available (for example, when it was renamed) or create one with a default name.
     */
    public static ColumnDefinition getSuperCfValueColumn(CFMetaData cfm, PartitionColumns partitionColumns, ColumnDefinition superCfKeyColumn, CompactTables.DefaultNames defaultNames)
    {
<span class="nc bnc" id="L624" title="All 4 branches missed.">        assert cfm.isDense();</span>

<span class="nc" id="L626">        MapType mapType = (MapType) cfm.compactValueColumn().type;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">        for (ColumnDefinition def: partitionColumns.regulars)</span>
        {
<span class="nc bnc" id="L629" title="All 6 branches missed.">            if (!def.name.bytes.equals(SUPER_COLUMN_MAP_COLUMN) &amp;&amp; def.type.equals(mapType.getValuesType()) &amp;&amp; !def.equals(superCfKeyColumn))</span>
<span class="nc" id="L630">                return def;</span>
<span class="nc" id="L631">        }</span>

<span class="nc" id="L633">        ColumnIdentifier identifier = ColumnIdentifier.getInterned(defaultNames.defaultCompactValueName(), true);</span>
<span class="nc" id="L634">        return new ColumnDefinition(cfm.ksName, cfm.cfName, identifier, mapType.getValuesType(), ColumnDefinition.NO_POSITION, ColumnDefinition.Kind.REGULAR);</span>
    }

    /**
     * SuperColumn key is stored in {@link CFMetaData#columnMetadata} as a clustering column (to make sure we can make
     * a distinction between the SuperColumn key and SuperColumn value columns, especially when they have the same type
     * and were renamed), but exposed as {@link CFMetaData#superCfKeyColumn} as a regular column to be compatible with
     * the storage engine.
     *
     * This remapping is necessary to facilitate the column metadata part.
     */
    public static ColumnDefinition getSuperCfSschemaRepresentation(ColumnDefinition superCfKeyColumn)
    {
<span class="nc" id="L647">        return new ColumnDefinition(superCfKeyColumn.ksName, superCfKeyColumn.cfName, superCfKeyColumn.name, superCfKeyColumn.type, 1, ColumnDefinition.Kind.CLUSTERING);</span>
    }

    public static boolean isSuperColumnMapColumn(ColumnDefinition column)
    {
<span class="nc bnc" id="L652" title="All 4 branches missed.">        return column.isRegular() &amp;&amp; column.name.bytes.equals(SuperColumnCompatibility.SUPER_COLUMN_MAP_COLUMN);</span>
    }

    public static ColumnDefinition getCompactValueColumn(PartitionColumns columns)
    {
<span class="nc bnc" id="L657" title="All 2 branches missed.">        for (ColumnDefinition column : columns.regulars)</span>
        {
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (isSuperColumnMapColumn(column))</span>
<span class="nc" id="L660">                return column;</span>
<span class="nc" id="L661">        }</span>
<span class="nc" id="L662">        throw new AssertionError(&quot;Invalid super column table definition, no 'dynamic' map column&quot;);</span>
    }

    /**
     * Restrictions are the trickiest part of the SuperColumn integration.
     * See specific docs on each field. For the purpose of this doc, the &quot;default&quot; column names are used,
     * `column2` and `value`. Detailed description and semantics of these fields can be found in this class'
     * header comment.
     */
    public static class SuperColumnRestrictions
    {
        /**
         * Restrictions in the form of:
         *   ... AND (column1, column2) &gt; ('value1', 1)
         * Multi-column restrictions. `column1` will be handled normally by the clustering bounds,
         * and `column2` value has to be &quot;saved&quot; and filtered out in `processPartition`, as there's no
         * direct mapping of multi-column restrictions to clustering + cell path. The first row
         * is special-cased to make sure the semantics of multi-column restrictions are preserved.
         */
        private final SingleColumnRestriction.SuperColumnMultiSliceRestriction multiSliceRestriction;

        /**
         * Restrictions in the form of:
         *   ... AND (column1, column2) = ('value1', 1)
         * Multi-column restriction with EQ does have a direct mapping: `column1` will be handled
         * normally by the clustering bounds, and the `column2` will be special-cased by the
         * {@link #getColumnFilter(CFMetaData, QueryOptions, SuperColumnRestrictions)} as a collection path lookup.
         */
        private final SingleColumnRestriction.SuperColumnMultiEQRestriction multiEQRestriction;

        /**
         * Restrictions in the form of:
         *   ... AND column2 &gt;= 5
         * For non-filtering cases (when the preceding clustering column and a partition key are
         * restricted), will be handled in {@link #getColumnFilter(CFMetaData, QueryOptions, SuperColumnRestrictions)}
         * like an inclusive bounds lookup.
         *
         * For the restrictions taking a form of
         *   ... AND column2 &gt; 5
         * (non-inclusive ones), the items that match `=` will be filtered out
         * by {@link #processPartition(CFMetaData, Selection, RowIterator, Selection.ResultSetBuilder, ProtocolVersion, SuperColumnRestrictions, QueryOptions)}
         *
         * Unfortunately, there are no good ways to do it other than here:
         * {@link RowFilter} can't be used in this case, since the complex collection cells are not yet rows by that
         * point.
         * {@link ColumnFilter} (which is used for inclusive slices) can't be changed to support exclusive slices as it would
         * require a protocol change in order to add a Kind. So exclusive slices are a combination of inclusive plus
         * an ad-hoc filter.
         */
        private final SingleColumnRestriction.SuperColumnKeySliceRestriction keySliceRestriction;

        /**
         * Restrictions in the form of:
         *   ... AND column2 IN (1, 2, 3)
         * For non-filtering cases (when the preceeding clustering column and a partition key are
         * restricted), are handled in {@link #getColumnFilter(CFMetaData, QueryOptions, SuperColumnRestrictions)} by
         * adding multiple collection paths to the {@link ColumnFilter}
         */
        private final SingleColumnRestriction.SuperColumnKeyINRestriction keyINRestriction;

        /**
         * Restrictions in the form of:
         *   ... AND column2 = 1
         * For non-filtering cases (when the preceeding clustering column and a partition key are
         * restricted), will be handled by converting the restriction to the column filter on
         * the collection key in {@link #getColumnFilter(CFMetaData, QueryOptions, SuperColumnRestrictions)}
         */
        private final SingleColumnRestriction.SuperColumnKeyEQRestriction keyEQRestriction;

        public SuperColumnRestrictions(Iterator&lt;SingleRestriction&gt; restrictions)
<span class="nc" id="L732">        {</span>
            // In order to keep the fields final, assignments have to be done outside the loop
<span class="nc" id="L734">            SingleColumnRestriction.SuperColumnMultiSliceRestriction multiSliceRestriction = null;</span>
<span class="nc" id="L735">            SingleColumnRestriction.SuperColumnKeySliceRestriction keySliceRestriction = null;</span>
<span class="nc" id="L736">            SingleColumnRestriction.SuperColumnKeyINRestriction keyINRestriction = null;</span>
<span class="nc" id="L737">            SingleColumnRestriction.SuperColumnMultiEQRestriction multiEQRestriction = null;</span>
<span class="nc" id="L738">            SingleColumnRestriction.SuperColumnKeyEQRestriction keyEQRestriction = null;</span>

<span class="nc bnc" id="L740" title="All 2 branches missed.">            while (restrictions.hasNext())</span>
            {
<span class="nc" id="L742">                SingleRestriction restriction = restrictions.next();</span>

<span class="nc bnc" id="L744" title="All 2 branches missed.">                if (restriction instanceof SingleColumnRestriction.SuperColumnMultiSliceRestriction)</span>
<span class="nc" id="L745">                    multiSliceRestriction = (SingleColumnRestriction.SuperColumnMultiSliceRestriction) restriction;</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">                else if (restriction instanceof SingleColumnRestriction.SuperColumnKeySliceRestriction)</span>
<span class="nc" id="L747">                    keySliceRestriction = (SingleColumnRestriction.SuperColumnKeySliceRestriction) restriction;</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">                else if (restriction instanceof SingleColumnRestriction.SuperColumnKeyINRestriction)</span>
<span class="nc" id="L749">                    keyINRestriction = (SingleColumnRestriction.SuperColumnKeyINRestriction) restriction;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">                else if (restriction instanceof SingleColumnRestriction.SuperColumnMultiEQRestriction)</span>
<span class="nc" id="L751">                    multiEQRestriction = (SingleColumnRestriction.SuperColumnMultiEQRestriction) restriction;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">                else if (restriction instanceof SingleColumnRestriction.SuperColumnKeyEQRestriction)</span>
<span class="nc" id="L753">                    keyEQRestriction = (SingleColumnRestriction.SuperColumnKeyEQRestriction) restriction;</span>
<span class="nc" id="L754">            }</span>

<span class="nc" id="L756">            this.multiSliceRestriction = multiSliceRestriction;</span>
<span class="nc" id="L757">            this.keySliceRestriction = keySliceRestriction;</span>
<span class="nc" id="L758">            this.keyINRestriction = keyINRestriction;</span>
<span class="nc" id="L759">            this.multiEQRestriction = multiEQRestriction;</span>
<span class="nc" id="L760">            this.keyEQRestriction = keyEQRestriction;</span>
<span class="nc" id="L761">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>