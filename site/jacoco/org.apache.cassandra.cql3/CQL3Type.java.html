<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CQL3Type.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">CQL3Type.java</span></div><h1>CQL3Type.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.Schema;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.db.marshal.CollectionType.Kind;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.exceptions.SyntaxException;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.Types;
import org.apache.cassandra.serializers.CollectionSerializer;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;

public interface CQL3Type
{
<span class="fc" id="L42">    static final Logger logger = LoggerFactory.getLogger(CQL3Type.class);</span>

    default boolean isCollection()
    {
<span class="fc" id="L46">        return false;</span>
    }

    default boolean isUDT()
    {
<span class="fc" id="L51">        return false;</span>
    }

    public AbstractType&lt;?&gt; getType();

    /**
     * Generates CQL literal from a binary value of this type.
     *  @param buffer the value to convert to a CQL literal. This value must be
     * serialized with {@code version} of the native protocol.
     * @param version the native protocol version in which {@code buffer} is encoded.
     */
    public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version);

<span class="fc" id="L64">    public enum Native implements CQL3Type</span>
    {
<span class="fc" id="L66">        ASCII       (AsciiType.instance),</span>
<span class="fc" id="L67">        BIGINT      (LongType.instance),</span>
<span class="fc" id="L68">        BLOB        (BytesType.instance),</span>
<span class="fc" id="L69">        BOOLEAN     (BooleanType.instance),</span>
<span class="fc" id="L70">        COUNTER     (CounterColumnType.instance),</span>
<span class="fc" id="L71">        DATE        (SimpleDateType.instance),</span>
<span class="fc" id="L72">        DECIMAL     (DecimalType.instance),</span>
<span class="fc" id="L73">        DOUBLE      (DoubleType.instance),</span>
<span class="fc" id="L74">        DURATION    (DurationType.instance),</span>
<span class="fc" id="L75">        EMPTY       (EmptyType.instance),</span>
<span class="fc" id="L76">        FLOAT       (FloatType.instance),</span>
<span class="fc" id="L77">        INET        (InetAddressType.instance),</span>
<span class="fc" id="L78">        INT         (Int32Type.instance),</span>
<span class="fc" id="L79">        SMALLINT    (ShortType.instance),</span>
<span class="fc" id="L80">        TEXT        (UTF8Type.instance),</span>
<span class="fc" id="L81">        TIME        (TimeType.instance),</span>
<span class="fc" id="L82">        TIMESTAMP   (TimestampType.instance),</span>
<span class="fc" id="L83">        TIMEUUID    (TimeUUIDType.instance),</span>
<span class="fc" id="L84">        TINYINT     (ByteType.instance),</span>
<span class="fc" id="L85">        UUID        (UUIDType.instance),</span>
<span class="fc" id="L86">        VARCHAR     (UTF8Type.instance),</span>
<span class="fc" id="L87">        VARINT      (IntegerType.instance);</span>

        private final AbstractType&lt;?&gt; type;

        private Native(AbstractType&lt;?&gt; type)
<span class="fc" id="L92">        {</span>
<span class="fc" id="L93">            this.type = type;</span>
<span class="fc" id="L94">        }</span>

        public AbstractType&lt;?&gt; getType()
        {
<span class="fc" id="L98">            return type;</span>
        }

        /**
         * Delegate to
         * {@link org.apache.cassandra.serializers.TypeSerializer#toCQLLiteral(ByteBuffer)}
         * for native types as most CQL literal representations work fine with the default
         * {@link org.apache.cassandra.serializers.TypeSerializer#toString(Object)}
         * {@link org.apache.cassandra.serializers.TypeSerializer#deserialize(ByteBuffer)} implementations.
         */
        public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
        {
<span class="nc" id="L110">            return type.getSerializer().toCQLLiteral(buffer);</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L116">            return super.toString().toLowerCase();</span>
        }
    }

    public static class Custom implements CQL3Type
    {
        private final AbstractType&lt;?&gt; type;

        public Custom(AbstractType&lt;?&gt; type)
<span class="nc" id="L125">        {</span>
<span class="nc" id="L126">            this.type = type;</span>
<span class="nc" id="L127">        }</span>

        public Custom(String className) throws SyntaxException, ConfigurationException
        {
<span class="nc" id="L131">            this(TypeParser.parse(className));</span>
<span class="nc" id="L132">        }</span>

        public AbstractType&lt;?&gt; getType()
        {
<span class="nc" id="L136">            return type;</span>
        }

        public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
        {
            // *always* use the 'blob' syntax to express custom types in CQL
<span class="nc" id="L142">            return Native.BLOB.toCQLLiteral(buffer, version);</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if(!(o instanceof Custom))</span>
<span class="nc" id="L149">                return false;</span>

<span class="nc" id="L151">            Custom that = (Custom)o;</span>
<span class="nc" id="L152">            return type.equals(that.type);</span>
        }

        @Override
        public final int hashCode()
        {
<span class="nc" id="L158">            return type.hashCode();</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L164">            return &quot;'&quot; + type + '\'';</span>
        }
    }

    public static class Collection implements CQL3Type
    {
        private final CollectionType type;

        public Collection(CollectionType type)
<span class="fc" id="L173">        {</span>
<span class="fc" id="L174">            this.type = type;</span>
<span class="fc" id="L175">        }</span>

        public AbstractType&lt;?&gt; getType()
        {
<span class="fc" id="L179">            return type;</span>
        }

        public boolean isCollection()
        {
<span class="nc" id="L184">            return true;</span>
        }

        public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
        {
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (buffer == null)</span>
<span class="nc" id="L190">                return &quot;null&quot;;</span>

<span class="nc" id="L192">            StringBuilder target = new StringBuilder();</span>
<span class="nc" id="L193">            buffer = buffer.duplicate();</span>
<span class="nc" id="L194">            int size = CollectionSerializer.readCollectionSize(buffer, version);</span>

<span class="nc bnc" id="L196" title="All 4 branches missed.">            switch (type.kind)</span>
            {
                case LIST:
<span class="nc" id="L199">                    CQL3Type elements = ((ListType) type).getElementsType().asCQL3Type();</span>
<span class="nc" id="L200">                    target.append('[');</span>
<span class="nc" id="L201">                    generateSetOrListCQLLiteral(buffer, version, target, size, elements);</span>
<span class="nc" id="L202">                    target.append(']');</span>
<span class="nc" id="L203">                    break;</span>
                case SET:
<span class="nc" id="L205">                    elements = ((SetType) type).getElementsType().asCQL3Type();</span>
<span class="nc" id="L206">                    target.append('{');</span>
<span class="nc" id="L207">                    generateSetOrListCQLLiteral(buffer, version, target, size, elements);</span>
<span class="nc" id="L208">                    target.append('}');</span>
<span class="nc" id="L209">                    break;</span>
                case MAP:
<span class="nc" id="L211">                    target.append('{');</span>
<span class="nc" id="L212">                    generateMapCQLLiteral(buffer, version, target, size);</span>
<span class="nc" id="L213">                    target.append('}');</span>
                    break;
            }
<span class="nc" id="L216">            return target.toString();</span>
        }

        private void generateMapCQLLiteral(ByteBuffer buffer, ProtocolVersion version, StringBuilder target, int size)
        {
<span class="nc" id="L221">            CQL3Type keys = ((MapType) type).getKeysType().asCQL3Type();</span>
<span class="nc" id="L222">            CQL3Type values = ((MapType) type).getValuesType().asCQL3Type();</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++)</span>
            {
<span class="nc bnc" id="L225" title="All 2 branches missed.">                if (i &gt; 0)</span>
<span class="nc" id="L226">                    target.append(&quot;, &quot;);</span>
<span class="nc" id="L227">                ByteBuffer element = CollectionSerializer.readValue(buffer, version);</span>
<span class="nc" id="L228">                target.append(keys.toCQLLiteral(element, version));</span>
<span class="nc" id="L229">                target.append(&quot;: &quot;);</span>
<span class="nc" id="L230">                element = CollectionSerializer.readValue(buffer, version);</span>
<span class="nc" id="L231">                target.append(values.toCQLLiteral(element, version));</span>
            }
<span class="nc" id="L233">        }</span>

        private static void generateSetOrListCQLLiteral(ByteBuffer buffer, ProtocolVersion version, StringBuilder target, int size, CQL3Type elements)
        {
<span class="nc bnc" id="L237" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++)</span>
            {
<span class="nc bnc" id="L239" title="All 2 branches missed.">                if (i &gt; 0)</span>
<span class="nc" id="L240">                    target.append(&quot;, &quot;);</span>
<span class="nc" id="L241">                ByteBuffer element = CollectionSerializer.readValue(buffer, version);</span>
<span class="nc" id="L242">                target.append(elements.toCQLLiteral(element, version));</span>
            }
<span class="nc" id="L244">        }</span>

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if(!(o instanceof Collection))</span>
<span class="nc" id="L250">                return false;</span>

<span class="nc" id="L252">            Collection that = (Collection)o;</span>
<span class="nc" id="L253">            return type.equals(that.type);</span>
        }

        @Override
        public final int hashCode()
        {
<span class="nc" id="L259">            return type.hashCode();</span>
        }

        @Override
        public String toString()
        {
<span class="fc bfc" id="L265" title="All 2 branches covered.">            boolean isFrozen = !this.type.isMultiCell();</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">            StringBuilder sb = new StringBuilder(isFrozen ? &quot;frozen&lt;&quot; : &quot;&quot;);</span>
<span class="pc bpc" id="L267" title="1 of 4 branches missed.">            switch (type.kind)</span>
            {
                case LIST:
<span class="fc" id="L270">                    AbstractType&lt;?&gt; listType = ((ListType)type).getElementsType();</span>
<span class="fc" id="L271">                    sb.append(&quot;list&lt;&quot;).append(listType.asCQL3Type());</span>
<span class="fc" id="L272">                    break;</span>
                case SET:
<span class="fc" id="L274">                    AbstractType&lt;?&gt; setType = ((SetType)type).getElementsType();</span>
<span class="fc" id="L275">                    sb.append(&quot;set&lt;&quot;).append(setType.asCQL3Type());</span>
<span class="fc" id="L276">                    break;</span>
                case MAP:
<span class="fc" id="L278">                    AbstractType&lt;?&gt; keysType = ((MapType)type).getKeysType();</span>
<span class="fc" id="L279">                    AbstractType&lt;?&gt; valuesType = ((MapType)type).getValuesType();</span>
<span class="fc" id="L280">                    sb.append(&quot;map&lt;&quot;).append(keysType.asCQL3Type()).append(&quot;, &quot;).append(valuesType.asCQL3Type());</span>
<span class="fc" id="L281">                    break;</span>
                default:
<span class="nc" id="L283">                    throw new AssertionError();</span>
            }
<span class="fc" id="L285">            sb.append('&gt;');</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">            if (isFrozen)</span>
<span class="fc" id="L287">                sb.append('&gt;');</span>
<span class="fc" id="L288">            return sb.toString();</span>
        }
    }

    public static class UserDefined implements CQL3Type
    {
        // Keeping this separatly from type just to simplify toString()
        private final String name;
        private final UserType type;

        private UserDefined(String name, UserType type)
<span class="nc" id="L299">        {</span>
<span class="nc" id="L300">            this.name = name;</span>
<span class="nc" id="L301">            this.type = type;</span>
<span class="nc" id="L302">        }</span>

        public static UserDefined create(UserType type)
        {
<span class="nc" id="L306">            return new UserDefined(UTF8Type.instance.compose(type.name), type);</span>
        }

        public boolean isUDT()
        {
<span class="nc" id="L311">            return true;</span>
        }

        public AbstractType&lt;?&gt; getType()
        {
<span class="nc" id="L316">            return type;</span>
        }

        public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
        {
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (buffer == null)</span>
<span class="nc" id="L322">                return &quot;null&quot;;</span>


<span class="nc" id="L325">            StringBuilder target = new StringBuilder();</span>
<span class="nc" id="L326">            buffer = buffer.duplicate();</span>
<span class="nc" id="L327">            target.append('{');</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">            for (int i = 0; i &lt; type.size(); i++)</span>
            {
                // we allow the input to have less fields than declared so as to support field addition.
<span class="nc bnc" id="L331" title="All 2 branches missed.">                if (!buffer.hasRemaining())</span>
<span class="nc" id="L332">                    break;</span>

<span class="nc bnc" id="L334" title="All 2 branches missed.">                if (buffer.remaining() &lt; 4)</span>
<span class="nc" id="L335">                    throw new MarshalException(String.format(&quot;Not enough bytes to read size of %dth field %s&quot;, i, type.fieldName(i)));</span>

<span class="nc" id="L337">                int size = buffer.getInt();</span>

<span class="nc bnc" id="L339" title="All 2 branches missed.">                if (i &gt; 0)</span>
<span class="nc" id="L340">                    target.append(&quot;, &quot;);</span>

<span class="nc" id="L342">                target.append(ColumnIdentifier.maybeQuote(type.fieldNameAsString(i)));</span>
<span class="nc" id="L343">                target.append(&quot;: &quot;);</span>

                // size &lt; 0 means null value
<span class="nc bnc" id="L346" title="All 2 branches missed.">                if (size &lt; 0)</span>
                {
<span class="nc" id="L348">                    target.append(&quot;null&quot;);</span>
<span class="nc" id="L349">                    continue;</span>
                }

<span class="nc bnc" id="L352" title="All 2 branches missed.">                if (buffer.remaining() &lt; size)</span>
<span class="nc" id="L353">                    throw new MarshalException(String.format(&quot;Not enough bytes to read %dth field %s&quot;, i, type.fieldName(i)));</span>

<span class="nc" id="L355">                ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);</span>
<span class="nc" id="L356">                target.append(type.fieldType(i).asCQL3Type().toCQLLiteral(field, version));</span>
            }
<span class="nc" id="L358">            target.append('}');</span>
<span class="nc" id="L359">            return target.toString();</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if(!(o instanceof UserDefined))</span>
<span class="nc" id="L366">                return false;</span>

<span class="nc" id="L368">            UserDefined that = (UserDefined)o;</span>
<span class="nc" id="L369">            return type.equals(that.type);</span>
        }

        @Override
        public final int hashCode()
        {
<span class="nc" id="L375">            return type.hashCode();</span>
        }

        @Override
        public String toString()
        {
<span class="nc bnc" id="L381" title="All 2 branches missed.">            if (type.isMultiCell())</span>
<span class="nc" id="L382">                return ColumnIdentifier.maybeQuote(name);</span>
            else
<span class="nc" id="L384">                return &quot;frozen&lt;&quot; + ColumnIdentifier.maybeQuote(name) + '&gt;';</span>
        }
    }

    public static class Tuple implements CQL3Type
    {
        private final TupleType type;

        private Tuple(TupleType type)
<span class="nc" id="L393">        {</span>
<span class="nc" id="L394">            this.type = type;</span>
<span class="nc" id="L395">        }</span>

        public static Tuple create(TupleType type)
        {
<span class="nc" id="L399">            return new Tuple(type);</span>
        }

        public AbstractType&lt;?&gt; getType()
        {
<span class="nc" id="L404">            return type;</span>
        }

        public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
        {
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (buffer == null)</span>
<span class="nc" id="L410">                return &quot;null&quot;;</span>

<span class="nc" id="L412">            StringBuilder target = new StringBuilder();</span>
<span class="nc" id="L413">            buffer = buffer.duplicate();</span>
<span class="nc" id="L414">            target.append('(');</span>
<span class="nc" id="L415">            boolean first = true;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            for (int i = 0; i &lt; type.size(); i++)</span>
            {
                // we allow the input to have less fields than declared so as to support field addition.
<span class="nc bnc" id="L419" title="All 2 branches missed.">                if (!buffer.hasRemaining())</span>
<span class="nc" id="L420">                    break;</span>

<span class="nc bnc" id="L422" title="All 2 branches missed.">                if (buffer.remaining() &lt; 4)</span>
<span class="nc" id="L423">                    throw new MarshalException(String.format(&quot;Not enough bytes to read size of %dth component&quot;, i));</span>

<span class="nc" id="L425">                int size = buffer.getInt();</span>

<span class="nc bnc" id="L427" title="All 2 branches missed.">                if (first)</span>
<span class="nc" id="L428">                    first = false;</span>
                else
<span class="nc" id="L430">                    target.append(&quot;, &quot;);</span>

                // size &lt; 0 means null value
<span class="nc bnc" id="L433" title="All 2 branches missed.">                if (size &lt; 0)</span>
                {
<span class="nc" id="L435">                    target.append(&quot;null&quot;);</span>
<span class="nc" id="L436">                    continue;</span>
                }

<span class="nc bnc" id="L439" title="All 2 branches missed.">                if (buffer.remaining() &lt; size)</span>
<span class="nc" id="L440">                    throw new MarshalException(String.format(&quot;Not enough bytes to read %dth component&quot;, i));</span>

<span class="nc" id="L442">                ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);</span>
<span class="nc" id="L443">                target.append(type.type(i).asCQL3Type().toCQLLiteral(field, version));</span>
            }
<span class="nc" id="L445">            target.append(')');</span>
<span class="nc" id="L446">            return target.toString();</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if(!(o instanceof Tuple))</span>
<span class="nc" id="L453">                return false;</span>

<span class="nc" id="L455">            Tuple that = (Tuple)o;</span>
<span class="nc" id="L456">            return type.equals(that.type);</span>
        }

        @Override
        public final int hashCode()
        {
<span class="nc" id="L462">            return type.hashCode();</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L468">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L469">            sb.append(&quot;frozen&lt;tuple&lt;&quot;);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            for (int i = 0; i &lt; type.size(); i++)</span>
            {
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (i &gt; 0)</span>
<span class="nc" id="L473">                    sb.append(&quot;, &quot;);</span>
<span class="nc" id="L474">                sb.append(type.type(i).asCQL3Type());</span>
            }
<span class="nc" id="L476">            sb.append(&quot;&gt;&gt;&quot;);</span>
<span class="nc" id="L477">            return sb.toString();</span>
        }
    }

    // For UserTypes, we need to know the current keyspace to resolve the
    // actual type used, so Raw is a &quot;not yet prepared&quot; CQL3Type.
<span class="fc" id="L483">    public abstract class Raw</span>
    {
<span class="fc" id="L485">        protected boolean frozen = false;</span>

        public abstract boolean supportsFreezing();

        public boolean isFrozen()
        {
<span class="nc" id="L491">            return this.frozen;</span>
        }

        public boolean canBeNonFrozen()
        {
<span class="nc" id="L496">            return true;</span>
        }

        public boolean isDuration()
        {
<span class="nc" id="L501">            return false;</span>
        }

        public boolean isCounter()
        {
<span class="fc" id="L506">            return false;</span>
        }

        public boolean isUDT()
        {
<span class="nc" id="L511">            return false;</span>
        }

        public String keyspace()
        {
<span class="nc" id="L516">            return null;</span>
        }

        public void freeze() throws InvalidRequestException
        {
<span class="nc" id="L521">            String message = String.format(&quot;frozen&lt;&gt; is only allowed on collections, tuples, and user-defined types (got %s)&quot;, this);</span>
<span class="nc" id="L522">            throw new InvalidRequestException(message);</span>
        }

        public CQL3Type prepare(String keyspace)
        {
<span class="nc" id="L527">            KeyspaceMetadata ksm = Schema.instance.getKSMetaData(keyspace);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            if (ksm == null)</span>
<span class="nc" id="L529">                throw new ConfigurationException(String.format(&quot;Keyspace %s doesn't exist&quot;, keyspace));</span>
<span class="nc" id="L530">            return prepare(keyspace, ksm.types);</span>
        }

        public abstract CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException;

        public CQL3Type prepareInternal(String keyspace, Types udts) throws InvalidRequestException
        {
<span class="nc" id="L537">            return prepare(keyspace, udts);</span>
        }

        public boolean referencesUserType(String name)
        {
<span class="nc" id="L542">            return false;</span>
        }

        public static Raw from(CQL3Type type)
        {
<span class="fc" id="L547">            return new RawType(type);</span>
        }

        public static Raw userType(UTName name)
        {
<span class="nc" id="L552">            return new RawUT(name);</span>
        }

        public static Raw map(CQL3Type.Raw t1, CQL3Type.Raw t2)
        {
<span class="fc" id="L557">            return new RawCollection(CollectionType.Kind.MAP, t1, t2);</span>
        }

        public static Raw list(CQL3Type.Raw t)
        {
<span class="fc" id="L562">            return new RawCollection(CollectionType.Kind.LIST, null, t);</span>
        }

        public static Raw set(CQL3Type.Raw t)
        {
<span class="fc" id="L567">            return new RawCollection(CollectionType.Kind.SET, null, t);</span>
        }

        public static Raw tuple(List&lt;CQL3Type.Raw&gt; ts)
        {
<span class="nc" id="L572">            return new RawTuple(ts);</span>
        }

        public static Raw frozen(CQL3Type.Raw t) throws InvalidRequestException
        {
<span class="fc" id="L577">            t.freeze();</span>
<span class="fc" id="L578">            return t;</span>
        }

        private static class RawType extends Raw
        {
            private final CQL3Type type;

            private RawType(CQL3Type type)
<span class="fc" id="L586">            {</span>
<span class="fc" id="L587">                this.type = type;</span>
<span class="fc" id="L588">            }</span>

            public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
            {
<span class="fc" id="L592">                return type;</span>
            }

            public boolean supportsFreezing()
            {
<span class="fc" id="L597">                return false;</span>
            }

            public boolean isCounter()
            {
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">                return type == Native.COUNTER;</span>
            }

            public boolean isDuration()
            {
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">                return type == Native.DURATION;</span>
            }

            @Override
            public String toString()
            {
<span class="nc" id="L613">                return type.toString();</span>
            }
        }

<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        private static class RawCollection extends Raw</span>
        {
            private final CollectionType.Kind kind;
            private final CQL3Type.Raw keys;
            private final CQL3Type.Raw values;

            private RawCollection(CollectionType.Kind kind, CQL3Type.Raw keys, CQL3Type.Raw values)
<span class="fc" id="L624">            {</span>
<span class="fc" id="L625">                this.kind = kind;</span>
<span class="fc" id="L626">                this.keys = keys;</span>
<span class="fc" id="L627">                this.values = values;</span>
<span class="fc" id="L628">            }</span>

            public void freeze() throws InvalidRequestException
            {
<span class="pc bpc" id="L632" title="1 of 4 branches missed.">                if (keys != null &amp;&amp; keys.supportsFreezing())</span>
<span class="nc" id="L633">                    keys.freeze();</span>
<span class="pc bpc" id="L634" title="2 of 4 branches missed.">                if (values != null &amp;&amp; values.supportsFreezing())</span>
<span class="nc" id="L635">                    values.freeze();</span>
<span class="fc" id="L636">                frozen = true;</span>
<span class="fc" id="L637">            }</span>

            public boolean supportsFreezing()
            {
<span class="nc" id="L641">                return true;</span>
            }

            public boolean isCollection()
            {
<span class="nc" id="L646">                return true;</span>
            }

            public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
            {
<span class="fc" id="L651">                return prepare(keyspace, udts, false);</span>
            }

            public CQL3Type prepareInternal(String keyspace, Types udts)
            {
<span class="fc" id="L656">                return prepare(keyspace, udts, true);</span>
            }

            public CQL3Type prepare(String keyspace, Types udts, boolean isInternal) throws InvalidRequestException
            {
<span class="pc bpc" id="L661" title="2 of 4 branches missed.">                assert values != null : &quot;Got null values type for a collection&quot;;</span>

<span class="pc bpc" id="L663" title="3 of 6 branches missed.">                if (!frozen &amp;&amp; values.supportsFreezing() &amp;&amp; !values.frozen)</span>
<span class="nc" id="L664">                    throwNestedNonFrozenError(values);</span>

                // we represent Thrift supercolumns as maps, internally, and we do allow counters in supercolumns. Thus,
                // for internal type parsing (think schema) we have to make an exception and allow counters as (map) values
<span class="pc bpc" id="L668" title="3 of 4 branches missed.">                if (values.isCounter() &amp;&amp; !isInternal)</span>
<span class="nc" id="L669">                    throw new InvalidRequestException(&quot;Counters are not allowed inside collections: &quot; + this);</span>

<span class="pc bpc" id="L671" title="3 of 4 branches missed.">                if (values.isDuration() &amp;&amp; kind == Kind.SET)</span>
<span class="nc" id="L672">                    throw new InvalidRequestException(&quot;Durations are not allowed inside sets: &quot; + this);</span>

<span class="fc bfc" id="L674" title="All 2 branches covered.">                if (keys != null)</span>
                {
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">                    if (keys.isCounter())</span>
<span class="nc" id="L677">                        throw new InvalidRequestException(&quot;Counters are not allowed inside collections: &quot; + this);</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                    if (keys.isDuration())</span>
<span class="nc" id="L679">                        throw new InvalidRequestException(&quot;Durations are not allowed as map keys: &quot; + this);</span>
<span class="pc bpc" id="L680" title="3 of 6 branches missed.">                    if (!frozen &amp;&amp; keys.supportsFreezing() &amp;&amp; !keys.frozen)</span>
<span class="nc" id="L681">                        throwNestedNonFrozenError(keys);</span>
                }

<span class="fc" id="L684">                AbstractType&lt;?&gt; valueType = values.prepare(keyspace, udts).getType();</span>
<span class="pc bpc" id="L685" title="1 of 4 branches missed.">                switch (kind)</span>
                {
                    case LIST:
<span class="fc bfc" id="L688" title="All 2 branches covered.">                        return new Collection(ListType.getInstance(valueType, !frozen));</span>
                    case SET:
<span class="fc bfc" id="L690" title="All 2 branches covered.">                        return new Collection(SetType.getInstance(valueType, !frozen));</span>
                    case MAP:
<span class="pc bpc" id="L692" title="2 of 4 branches missed.">                        assert keys != null : &quot;Got null keys type for a collection&quot;;</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">                        return new Collection(MapType.getInstance(keys.prepare(keyspace, udts).getType(), valueType, !frozen));</span>
                }
<span class="nc" id="L695">                throw new AssertionError();</span>
            }

            private void throwNestedNonFrozenError(Raw innerType)
            {
<span class="nc bnc" id="L700" title="All 2 branches missed.">                if (innerType instanceof RawCollection)</span>
<span class="nc" id="L701">                    throw new InvalidRequestException(&quot;Non-frozen collections are not allowed inside collections: &quot; + this);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                else if (innerType.isUDT())</span>
<span class="nc" id="L703">                    throw new InvalidRequestException(&quot;Non-frozen UDTs are not allowed inside collections: &quot; + this);</span>
                else
<span class="nc" id="L705">                    throw new InvalidRequestException(&quot;Non-frozen tuples are not allowed inside collections: &quot; + this);</span>
            }

            public boolean referencesUserType(String name)
            {
<span class="nc bnc" id="L710" title="All 6 branches missed.">                return (keys != null &amp;&amp; keys.referencesUserType(name)) || values.referencesUserType(name);</span>
            }

            @Override
            public String toString()
            {
<span class="nc bnc" id="L716" title="All 2 branches missed.">                String start = frozen? &quot;frozen&lt;&quot; : &quot;&quot;;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                String end = frozen ? &quot;&gt;&quot; : &quot;&quot;;</span>
<span class="nc bnc" id="L718" title="All 4 branches missed.">                switch (kind)</span>
                {
<span class="nc" id="L720">                    case LIST: return start + &quot;list&lt;&quot; + values + '&gt;' + end;</span>
<span class="nc" id="L721">                    case SET:  return start + &quot;set&lt;&quot; + values + '&gt;' + end;</span>
<span class="nc" id="L722">                    case MAP:  return start + &quot;map&lt;&quot; + keys + &quot;, &quot; + values + '&gt;' + end;</span>
                }
<span class="nc" id="L724">                throw new AssertionError();</span>
            }
        }

        private static class RawUT extends Raw
        {
            private final UTName name;

            private RawUT(UTName name)
<span class="nc" id="L733">            {</span>
<span class="nc" id="L734">                this.name = name;</span>
<span class="nc" id="L735">            }</span>

            public String keyspace()
            {
<span class="nc" id="L739">                return name.getKeyspace();</span>
            }

            public void freeze()
            {
<span class="nc" id="L744">                frozen = true;</span>
<span class="nc" id="L745">            }</span>

            public boolean canBeNonFrozen()
            {
<span class="nc" id="L749">                return true;</span>
            }

            public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
            {
<span class="nc bnc" id="L754" title="All 2 branches missed.">                if (name.hasKeyspace())</span>
                {
                    // The provided keyspace is the one of the current statement this is part of. If it's different from the keyspace of
                    // the UTName, we reject since we want to limit user types to their own keyspace (see #6643)
<span class="nc bnc" id="L758" title="All 2 branches missed.">                    if (!keyspace.equals(name.getKeyspace()))</span>
<span class="nc" id="L759">                        throw new InvalidRequestException(String.format(&quot;Statement on keyspace %s cannot refer to a user type in keyspace %s; &quot;</span>
                                                                        + &quot;user types can only be used in the keyspace they are defined in&quot;,
<span class="nc" id="L761">                                                                        keyspace, name.getKeyspace()));</span>
                }
                else
                {
<span class="nc" id="L765">                    name.setKeyspace(keyspace);</span>
                }

<span class="nc" id="L768">                UserType type = udts.getNullable(name.getUserTypeName());</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                if (type == null)</span>
<span class="nc" id="L770">                    throw new InvalidRequestException(&quot;Unknown type &quot; + name);</span>

<span class="nc bnc" id="L772" title="All 2 branches missed.">                if (frozen)</span>
<span class="nc" id="L773">                    type = type.freeze();</span>
<span class="nc" id="L774">                return new UserDefined(name.toString(), type);</span>
            }

            public boolean referencesUserType(String name)
            {
<span class="nc" id="L779">                return this.name.getStringTypeName().equals(name);</span>
            }

            public boolean supportsFreezing()
            {
<span class="nc" id="L784">                return true;</span>
            }

            public boolean isUDT()
            {
<span class="nc" id="L789">                return true;</span>
            }

            @Override
            public String toString()
            {
<span class="nc bnc" id="L795" title="All 2 branches missed.">                if (frozen)</span>
<span class="nc" id="L796">                    return &quot;frozen&lt;&quot; + name.toString() + '&gt;';</span>
                else
<span class="nc" id="L798">                    return name.toString();</span>
            }
        }

        private static class RawTuple extends Raw
        {
            private final List&lt;CQL3Type.Raw&gt; types;

            private RawTuple(List&lt;CQL3Type.Raw&gt; types)
<span class="nc" id="L807">            {</span>
<span class="nc" id="L808">                this.types = types;</span>
<span class="nc" id="L809">            }</span>

            public boolean supportsFreezing()
            {
<span class="nc" id="L813">                return true;</span>
            }

            public void freeze() throws InvalidRequestException
            {
<span class="nc bnc" id="L818" title="All 2 branches missed.">                for (CQL3Type.Raw t : types)</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">                    if (t.supportsFreezing())</span>
<span class="nc" id="L820">                        t.freeze();</span>

<span class="nc" id="L822">                frozen = true;</span>
<span class="nc" id="L823">            }</span>

            public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
            {
<span class="nc bnc" id="L827" title="All 2 branches missed.">                if (!frozen)</span>
<span class="nc" id="L828">                    freeze();</span>

<span class="nc" id="L830">                List&lt;AbstractType&lt;?&gt;&gt; ts = new ArrayList&lt;&gt;(types.size());</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">                for (CQL3Type.Raw t : types)</span>
                {
<span class="nc bnc" id="L833" title="All 2 branches missed.">                    if (t.isCounter())</span>
<span class="nc" id="L834">                        throw new InvalidRequestException(&quot;Counters are not allowed inside tuples&quot;);</span>

<span class="nc" id="L836">                    ts.add(t.prepare(keyspace, udts).getType());</span>
<span class="nc" id="L837">                }</span>
<span class="nc" id="L838">                return new Tuple(new TupleType(ts));</span>
            }

            public boolean referencesUserType(String name)
            {
<span class="nc" id="L843">                return types.stream().anyMatch(t -&gt; t.referencesUserType(name));</span>
            }

            @Override
            public String toString()
            {
<span class="nc" id="L849">                StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L850">                sb.append(&quot;tuple&lt;&quot;);</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">                for (int i = 0; i &lt; types.size(); i++)</span>
                {
<span class="nc bnc" id="L853" title="All 2 branches missed.">                    if (i &gt; 0)</span>
<span class="nc" id="L854">                        sb.append(&quot;, &quot;);</span>
<span class="nc" id="L855">                    sb.append(types.get(i));</span>
                }
<span class="nc" id="L857">                sb.append('&gt;');</span>
<span class="nc" id="L858">                return sb.toString();</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>