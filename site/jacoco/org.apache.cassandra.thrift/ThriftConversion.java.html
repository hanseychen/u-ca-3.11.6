<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ThriftConversion.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.thrift</a> &gt; <span class="el_source">ThriftConversion.java</span></div><h1>ThriftConversion.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.thrift;

import java.util.*;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Strings;
import com.google.common.collect.Maps;

import org.apache.cassandra.config.*;
import org.apache.cassandra.cql3.ColumnIdentifier;
import org.apache.cassandra.cql3.Operator;
import org.apache.cassandra.cql3.SuperColumnCompatibility;
import org.apache.cassandra.cql3.statements.IndexTarget;
import org.apache.cassandra.db.CompactTables;
import org.apache.cassandra.db.LegacyLayout;
import org.apache.cassandra.db.WriteType;
import org.apache.cassandra.db.compaction.AbstractCompactionStrategy;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.exceptions.*;
import org.apache.cassandra.index.TargetParser;
import org.apache.cassandra.io.compress.ICompressor;
import org.apache.cassandra.locator.AbstractReplicationStrategy;
import org.apache.cassandra.locator.LocalStrategy;
import org.apache.cassandra.schema.*;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.UUIDGen;

/**
 * Static utility methods to convert internal structure to and from thrift ones.
 */
<span class="nc" id="L51">public class ThriftConversion</span>
{
    public static org.apache.cassandra.db.ConsistencyLevel fromThrift(ConsistencyLevel cl)
    {
<span class="nc bnc" id="L55" title="All 12 branches missed.">        switch (cl)</span>
        {
<span class="nc" id="L57">            case ANY: return org.apache.cassandra.db.ConsistencyLevel.ANY;</span>
<span class="nc" id="L58">            case ONE: return org.apache.cassandra.db.ConsistencyLevel.ONE;</span>
<span class="nc" id="L59">            case TWO: return org.apache.cassandra.db.ConsistencyLevel.TWO;</span>
<span class="nc" id="L60">            case THREE: return org.apache.cassandra.db.ConsistencyLevel.THREE;</span>
<span class="nc" id="L61">            case QUORUM: return org.apache.cassandra.db.ConsistencyLevel.QUORUM;</span>
<span class="nc" id="L62">            case ALL: return org.apache.cassandra.db.ConsistencyLevel.ALL;</span>
<span class="nc" id="L63">            case LOCAL_QUORUM: return org.apache.cassandra.db.ConsistencyLevel.LOCAL_QUORUM;</span>
<span class="nc" id="L64">            case EACH_QUORUM: return org.apache.cassandra.db.ConsistencyLevel.EACH_QUORUM;</span>
<span class="nc" id="L65">            case SERIAL: return org.apache.cassandra.db.ConsistencyLevel.SERIAL;</span>
<span class="nc" id="L66">            case LOCAL_SERIAL: return org.apache.cassandra.db.ConsistencyLevel.LOCAL_SERIAL;</span>
<span class="nc" id="L67">            case LOCAL_ONE: return org.apache.cassandra.db.ConsistencyLevel.LOCAL_ONE;</span>
        }
<span class="nc" id="L69">        throw new AssertionError();</span>
    }

    public static ConsistencyLevel toThrift(org.apache.cassandra.db.ConsistencyLevel cl)
    {
<span class="nc bnc" id="L74" title="All 12 branches missed.">        switch (cl)</span>
        {
<span class="nc" id="L76">            case ANY: return ConsistencyLevel.ANY;</span>
<span class="nc" id="L77">            case ONE: return ConsistencyLevel.ONE;</span>
<span class="nc" id="L78">            case TWO: return ConsistencyLevel.TWO;</span>
<span class="nc" id="L79">            case THREE: return ConsistencyLevel.THREE;</span>
<span class="nc" id="L80">            case QUORUM: return ConsistencyLevel.QUORUM;</span>
<span class="nc" id="L81">            case ALL: return ConsistencyLevel.ALL;</span>
<span class="nc" id="L82">            case LOCAL_QUORUM: return ConsistencyLevel.LOCAL_QUORUM;</span>
<span class="nc" id="L83">            case EACH_QUORUM: return ConsistencyLevel.EACH_QUORUM;</span>
<span class="nc" id="L84">            case SERIAL: return ConsistencyLevel.SERIAL;</span>
<span class="nc" id="L85">            case LOCAL_SERIAL: return ConsistencyLevel.LOCAL_SERIAL;</span>
<span class="nc" id="L86">            case LOCAL_ONE: return ConsistencyLevel.LOCAL_ONE;</span>
        }
<span class="nc" id="L88">        throw new AssertionError();</span>
    }

    // We never return, but returning a RuntimeException allows to write &quot;throw rethrow(e)&quot; without java complaining
    // for methods that have a return value.
    public static RuntimeException rethrow(RequestExecutionException e) throws UnavailableException, TimedOutException
    {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (e instanceof RequestFailureException)</span>
<span class="nc" id="L96">            throw toThrift((RequestFailureException)e);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">        else if (e instanceof RequestTimeoutException)</span>
<span class="nc" id="L98">            throw toThrift((RequestTimeoutException)e);</span>
        else
<span class="nc" id="L100">            throw new UnavailableException();</span>
    }

    public static InvalidRequestException toThrift(RequestValidationException e)
    {
<span class="nc" id="L105">        return new InvalidRequestException(e.getMessage());</span>
    }

    public static UnavailableException toThrift(org.apache.cassandra.exceptions.UnavailableException e)
    {
<span class="nc" id="L110">        return new UnavailableException();</span>
    }

    public static AuthenticationException toThrift(org.apache.cassandra.exceptions.AuthenticationException e)
    {
<span class="nc" id="L115">        return new AuthenticationException(e.getMessage());</span>
    }

    public static TimedOutException toThrift(RequestTimeoutException e)
    {
<span class="nc" id="L120">        TimedOutException toe = new TimedOutException();</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (e instanceof WriteTimeoutException)</span>
        {
<span class="nc" id="L123">            WriteTimeoutException wte = (WriteTimeoutException)e;</span>
<span class="nc" id="L124">            toe.setAcknowledged_by(wte.received);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (wte.writeType == WriteType.BATCH_LOG)</span>
<span class="nc" id="L126">                toe.setAcknowledged_by_batchlog(false);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">            else if (wte.writeType == WriteType.BATCH)</span>
<span class="nc" id="L128">                toe.setAcknowledged_by_batchlog(true);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            else if (wte.writeType == WriteType.CAS)</span>
<span class="nc" id="L130">                toe.setPaxos_in_progress(true);</span>
        }
<span class="nc" id="L132">        return toe;</span>
    }

    // Thrift does not support RequestFailureExceptions, so we translate them into timeouts
    public static TimedOutException toThrift(RequestFailureException e)
    {
<span class="nc" id="L138">        return new TimedOutException();</span>
    }

    public static RowFilter rowFilterFromThrift(CFMetaData metadata, List&lt;IndexExpression&gt; exprs)
    {
<span class="nc bnc" id="L143" title="All 4 branches missed.">        if (exprs == null || exprs.isEmpty())</span>
<span class="nc" id="L144">            return RowFilter.NONE;</span>

<span class="nc" id="L146">        RowFilter converted = RowFilter.forThrift(exprs.size());</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        for (IndexExpression expr : exprs)</span>
<span class="nc" id="L148">            converted.addThriftExpression(metadata, expr.column_name, Operator.valueOf(expr.op.name()), expr.value);</span>
<span class="nc" id="L149">        return converted;</span>
    }

    public static KeyspaceMetadata fromThrift(KsDef ksd, CFMetaData... cfDefs) throws ConfigurationException
    {
<span class="nc" id="L154">        Class&lt;? extends AbstractReplicationStrategy&gt; cls = AbstractReplicationStrategy.getClass(ksd.strategy_class);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (cls.equals(LocalStrategy.class))</span>
<span class="nc" id="L156">            throw new ConfigurationException(&quot;Unable to use given strategy class: LocalStrategy is reserved for internal use.&quot;);</span>

<span class="nc" id="L158">        Map&lt;String, String&gt; replicationMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (ksd.strategy_options != null)</span>
<span class="nc" id="L160">            replicationMap.putAll(ksd.strategy_options);</span>
<span class="nc" id="L161">        replicationMap.put(ReplicationParams.CLASS, cls.getName());</span>

<span class="nc" id="L163">        return KeyspaceMetadata.create(ksd.name, KeyspaceParams.create(ksd.durable_writes, replicationMap), Tables.of(cfDefs));</span>
    }

    public static KsDef toThrift(KeyspaceMetadata ksm)
    {
<span class="nc" id="L168">        List&lt;CfDef&gt; cfDefs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        for (CFMetaData cfm : ksm.tables) // do not include views</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (cfm.isThriftCompatible()) // Don't expose CF that cannot be correctly handle by thrift; see CASSANDRA-4377 for further details</span>
<span class="nc" id="L171">                cfDefs.add(toThrift(cfm));</span>

<span class="nc" id="L173">        KsDef ksdef = new KsDef(ksm.name, ksm.params.replication.klass.getName(), cfDefs);</span>
<span class="nc" id="L174">        ksdef.setStrategy_options(ksm.params.replication.options);</span>
<span class="nc" id="L175">        ksdef.setDurable_writes(ksm.params.durableWrites);</span>

<span class="nc" id="L177">        return ksdef;</span>
    }

    public static CFMetaData fromThrift(CfDef cf_def)
    throws org.apache.cassandra.exceptions.InvalidRequestException, ConfigurationException
    {
        // This is a creation: the table is dense if it doesn't define any column_metadata
<span class="nc bnc" id="L184" title="All 4 branches missed.">        boolean isDense = cf_def.column_metadata == null || cf_def.column_metadata.isEmpty();</span>
<span class="nc" id="L185">        return internalFromThrift(cf_def, true, Collections.&lt;ColumnDefinition&gt;emptyList(), isDense);</span>
    }

    public static CFMetaData fromThriftForUpdate(CfDef cf_def, CFMetaData toUpdate)
    throws org.apache.cassandra.exceptions.InvalidRequestException, ConfigurationException
    {
<span class="nc" id="L191">        return internalFromThrift(cf_def, false, toUpdate.allColumns(), toUpdate.isDense());</span>
    }

    private static boolean isSuper(String thriftColumnType)
    throws org.apache.cassandra.exceptions.InvalidRequestException
    {
<span class="nc bnc" id="L197" title="All 3 branches missed.">        switch (thriftColumnType.toLowerCase(Locale.ENGLISH))</span>
        {
<span class="nc" id="L199">            case &quot;standard&quot;: return false;</span>
<span class="nc" id="L200">            case &quot;super&quot;: return true;</span>
<span class="nc" id="L201">            default: throw new org.apache.cassandra.exceptions.InvalidRequestException(&quot;Invalid column type &quot; + thriftColumnType);</span>
        }
    }

    /**
     * Convert a thrift CfDef.
     * &lt;p&gt;,
     * This is used both for creation and update of CF.
     *
     * @param cf_def the thrift CfDef to convert.
     * @param isCreation whether that is a new table creation or not.
     * @param previousCQLMetadata if it is not a table creation, the previous
     * definitions of the tables (which we use to preserve the CQL metadata).
     * If it is a table creation, this will be empty.
     * @param isDense whether the table is dense or not.
     *
     * @return the converted table definition.
     */
    private static CFMetaData internalFromThrift(CfDef cf_def,
                                                 boolean isCreation,
                                                 Collection&lt;ColumnDefinition&gt; previousCQLMetadata,
                                                 boolean isDense)
    throws org.apache.cassandra.exceptions.InvalidRequestException, ConfigurationException
    {
<span class="nc" id="L225">        applyImplicitDefaults(cf_def);</span>

        try
        {
<span class="nc" id="L229">            boolean isSuper = isSuper(cf_def.column_type);</span>
<span class="nc" id="L230">            AbstractType&lt;?&gt; rawComparator = TypeParser.parse(cf_def.comparator_type);</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">            AbstractType&lt;?&gt; subComparator = isSuper</span>
<span class="nc" id="L232">                                          ? cf_def.subcomparator_type == null ? BytesType.instance : TypeParser.parse(cf_def.subcomparator_type)</span>
                                          : null;

<span class="nc bnc" id="L235" title="All 2 branches missed.">            AbstractType&lt;?&gt; keyValidator = cf_def.isSetKey_validation_class() ? TypeParser.parse(cf_def.key_validation_class) : BytesType.instance;</span>
<span class="nc" id="L236">            AbstractType&lt;?&gt; defaultValidator = TypeParser.parse(cf_def.default_validation_class);</span>

            // Convert the definitions from the input CfDef
<span class="nc" id="L239">            List&lt;ColumnDefinition&gt; defs = fromThrift(cf_def.keyspace, cf_def.name, rawComparator, subComparator, cf_def.column_metadata);</span>

            // Add the keyAlias if there is one, since that's a CQL metadata that thrift can actually change (for
            // historical reasons)
<span class="nc bnc" id="L243" title="All 6 branches missed.">            boolean hasKeyAlias = cf_def.isSetKey_alias() &amp;&amp; keyValidator != null &amp;&amp; !(keyValidator instanceof CompositeType);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (hasKeyAlias)</span>
<span class="nc" id="L245">                defs.add(ColumnDefinition.partitionKeyDef(cf_def.keyspace, cf_def.name, UTF8Type.instance.getString(cf_def.key_alias), keyValidator, 0));</span>

            // Now add any CQL metadata that we want to copy, skipping the keyAlias if there was one
<span class="nc bnc" id="L248" title="All 2 branches missed.">            for (ColumnDefinition def : previousCQLMetadata)</span>
            {
                // isPartOfCellName basically means 'is not just a CQL metadata'
<span class="nc bnc" id="L251" title="All 2 branches missed.">                if (def.isPartOfCellName(false, isSuper))</span>
<span class="nc" id="L252">                    continue;</span>

<span class="nc bnc" id="L254" title="All 4 branches missed.">                if (def.kind == ColumnDefinition.Kind.PARTITION_KEY &amp;&amp; hasKeyAlias)</span>
<span class="nc" id="L255">                    continue;</span>

<span class="nc" id="L257">                defs.add(def);</span>
<span class="nc" id="L258">            }</span>

<span class="nc" id="L260">            UUID cfId = Schema.instance.getId(cf_def.keyspace, cf_def.name);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (cfId == null)</span>
<span class="nc" id="L262">                cfId = UUIDGen.getTimeUUID();</span>

<span class="nc bnc" id="L264" title="All 4 branches missed.">            boolean isCompound = !isSuper &amp;&amp; (rawComparator instanceof CompositeType);</span>
<span class="nc" id="L265">            boolean isCounter = defaultValidator instanceof CounterColumnType;</span>

            // If it's a thrift table creation, adds the default CQL metadata for the new table
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (isCreation)</span>
            {
<span class="nc bnc" id="L270" title="All 2 branches missed.">                addDefaultCQLMetadata(defs,</span>
                                      cf_def.keyspace,
                                      cf_def.name,
                                      hasKeyAlias ? null : keyValidator,
                                      rawComparator,
                                      subComparator,
                                      defaultValidator,
                                      isDense);
            }

            // We do not allow Thrift views, so we always set it to false
<span class="nc" id="L281">            boolean isView = false;</span>

<span class="nc" id="L283">            CFMetaData newCFMD = CFMetaData.create(cf_def.keyspace,</span>
                                                   cf_def.name,
                                                   cfId,
                                                   isDense,
                                                   isCompound,
                                                   isSuper,
                                                   isCounter,
                                                   isView,
                                                   defs,
<span class="nc" id="L292">                                                   DatabaseDescriptor.getPartitioner());</span>

            // Convert any secondary indexes defined in the thrift column_metadata
<span class="nc" id="L295">            newCFMD.indexes(indexDefsFromThrift(newCFMD,</span>
                                                cf_def.keyspace,
                                                cf_def.name,
                                                rawComparator,
                                                subComparator,
                                                cf_def.column_metadata));

<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (cf_def.isSetGc_grace_seconds())</span>
<span class="nc" id="L303">                newCFMD.gcGraceSeconds(cf_def.gc_grace_seconds);</span>

<span class="nc" id="L305">            newCFMD.compaction(compactionParamsFromThrift(cf_def));</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">            if (cf_def.isSetBloom_filter_fp_chance())</span>
<span class="nc" id="L308">                newCFMD.bloomFilterFpChance(cf_def.bloom_filter_fp_chance);</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (cf_def.isSetMemtable_flush_period_in_ms())</span>
<span class="nc" id="L310">                newCFMD.memtableFlushPeriod(cf_def.memtable_flush_period_in_ms);</span>
<span class="nc bnc" id="L311" title="All 4 branches missed.">            if (cf_def.isSetCaching() || cf_def.isSetCells_per_row_to_cache())</span>
<span class="nc" id="L312">                newCFMD.caching(cachingFromThrift(cf_def.caching, cf_def.cells_per_row_to_cache));</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">            if (cf_def.isSetRead_repair_chance())</span>
<span class="nc" id="L314">                newCFMD.readRepairChance(cf_def.read_repair_chance);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (cf_def.isSetDefault_time_to_live())</span>
<span class="nc" id="L316">                newCFMD.defaultTimeToLive(cf_def.default_time_to_live);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (cf_def.isSetDclocal_read_repair_chance())</span>
<span class="nc" id="L318">                newCFMD.dcLocalReadRepairChance(cf_def.dclocal_read_repair_chance);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (cf_def.isSetMin_index_interval())</span>
<span class="nc" id="L320">                newCFMD.minIndexInterval(cf_def.min_index_interval);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (cf_def.isSetMax_index_interval())</span>
<span class="nc" id="L322">                newCFMD.maxIndexInterval(cf_def.max_index_interval);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (cf_def.isSetSpeculative_retry())</span>
<span class="nc" id="L324">                newCFMD.speculativeRetry(SpeculativeRetryParam.fromString(cf_def.speculative_retry));</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (cf_def.isSetTriggers())</span>
<span class="nc" id="L326">                newCFMD.triggers(triggerDefinitionsFromThrift(cf_def.triggers));</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">            if (cf_def.isSetComment())</span>
<span class="nc" id="L328">                newCFMD.comment(cf_def.comment);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            if (cf_def.isSetCompression_options())</span>
<span class="nc" id="L330">                newCFMD.compression(compressionParametersFromThrift(cf_def.compression_options));</span>

<span class="nc" id="L332">            return newCFMD;</span>
        }
<span class="nc" id="L334">        catch (SyntaxException | MarshalException e)</span>
        {
<span class="nc" id="L336">            throw new ConfigurationException(e.getMessage());</span>
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static CompactionParams compactionParamsFromThrift(CfDef cf_def)
    {
<span class="nc" id="L343">        Class&lt;? extends AbstractCompactionStrategy&gt; klass =</span>
<span class="nc" id="L344">            CFMetaData.createCompactionStrategy(cf_def.compaction_strategy);</span>
<span class="nc" id="L345">        Map&lt;String, String&gt; options = new HashMap&lt;&gt;(cf_def.compaction_strategy_options);</span>

<span class="nc" id="L347">        int minThreshold = cf_def.min_compaction_threshold;</span>
<span class="nc" id="L348">        int maxThreshold = cf_def.max_compaction_threshold;</span>

<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (CompactionParams.supportsThresholdParams(klass))</span>
        {
<span class="nc" id="L352">            options.putIfAbsent(CompactionParams.Option.MIN_THRESHOLD.toString(), Integer.toString(minThreshold));</span>
<span class="nc" id="L353">            options.putIfAbsent(CompactionParams.Option.MAX_THRESHOLD.toString(), Integer.toString(maxThreshold));</span>
        }

<span class="nc" id="L356">        return CompactionParams.create(klass, options);</span>
    }

    private static CompressionParams compressionParametersFromThrift(Map&lt;String, String&gt; compression_options)
    {
<span class="nc" id="L361">        CompressionParams compressionParameter = CompressionParams.fromMap(compression_options);</span>
<span class="nc" id="L362">        compressionParameter.validate();</span>
<span class="nc" id="L363">        return compressionParameter;</span>
    }

    private static void addDefaultCQLMetadata(Collection&lt;ColumnDefinition&gt; defs,
                                              String ks,
                                              String cf,
                                              AbstractType&lt;?&gt; keyValidator,
                                              AbstractType&lt;?&gt; comparator,
                                              AbstractType&lt;?&gt; subComparator,
                                              AbstractType&lt;?&gt; defaultValidator,
                                              boolean isDense)
    {
<span class="nc" id="L375">        CompactTables.DefaultNames names = CompactTables.defaultNameGenerator(defs);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (keyValidator != null)</span>
        {
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (keyValidator instanceof CompositeType)</span>
            {
<span class="nc" id="L380">                List&lt;AbstractType&lt;?&gt;&gt; subTypes = ((CompositeType)keyValidator).types;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">                for (int i = 0; i &lt; subTypes.size(); i++)</span>
<span class="nc" id="L382">                    defs.add(ColumnDefinition.partitionKeyDef(ks, cf, names.defaultPartitionKeyName(), subTypes.get(i), i));</span>
<span class="nc" id="L383">            }</span>
            else
            {
<span class="nc" id="L386">                defs.add(ColumnDefinition.partitionKeyDef(ks, cf, names.defaultPartitionKeyName(), keyValidator, 0));</span>
            }
        }

<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (subComparator != null)</span>
        {
            // SuperColumn tables: we use a special map to hold dynamic values within a given super column
<span class="nc" id="L393">            defs.add(ColumnDefinition.clusteringDef(ks, cf, names.defaultClusteringName(), comparator, 0));</span>
<span class="nc" id="L394">            defs.add(ColumnDefinition.regularDef(ks, cf, SuperColumnCompatibility.SUPER_COLUMN_MAP_COLUMN_STR, MapType.getInstance(subComparator, defaultValidator, true)));</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            if (isDense)</span>
            {
<span class="nc" id="L397">                defs.add(ColumnDefinition.clusteringDef(ks, cf, names.defaultClusteringName(), subComparator, 1));</span>
<span class="nc" id="L398">                defs.add(ColumnDefinition.regularDef(ks, cf, names.defaultCompactValueName(), defaultValidator));</span>
            }
        }
        else
        {
<span class="nc bnc" id="L403" title="All 2 branches missed.">            List&lt;AbstractType&lt;?&gt;&gt; subTypes = comparator instanceof CompositeType</span>
                                           ? ((CompositeType)comparator).types
<span class="nc" id="L405">                                           : Collections.&lt;AbstractType&lt;?&gt;&gt;singletonList(comparator);</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">            for (int i = 0; i &lt; subTypes.size(); i++)</span>
<span class="nc" id="L408">                defs.add(ColumnDefinition.clusteringDef(ks, cf, names.defaultClusteringName(), subTypes.get(i), i));</span>

<span class="nc" id="L410">            defs.add(ColumnDefinition.regularDef(ks, cf, names.defaultCompactValueName(), defaultValidator));</span>
        }
<span class="nc" id="L412">    }</span>

    /* applies implicit defaults to cf definition. useful in updates */
    @SuppressWarnings(&quot;deprecation&quot;)
    private static void applyImplicitDefaults(org.apache.cassandra.thrift.CfDef cf_def)
    {
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (!cf_def.isSetComment())</span>
<span class="nc" id="L419">            cf_def.setComment(&quot;&quot;);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (!cf_def.isSetMin_compaction_threshold())</span>
<span class="nc" id="L421">            cf_def.setMin_compaction_threshold(CompactionParams.DEFAULT_MIN_THRESHOLD);</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (!cf_def.isSetMax_compaction_threshold())</span>
<span class="nc" id="L423">            cf_def.setMax_compaction_threshold(CompactionParams.DEFAULT_MAX_THRESHOLD);</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (!cf_def.isSetCompaction_strategy())</span>
<span class="nc" id="L425">            cf_def.setCompaction_strategy(CompactionParams.DEFAULT.klass().getSimpleName());</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (!cf_def.isSetCompaction_strategy_options())</span>
<span class="nc" id="L427">            cf_def.setCompaction_strategy_options(Collections.emptyMap());</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (!cf_def.isSetCompression_options())</span>
<span class="nc" id="L429">            cf_def.setCompression_options(Collections.singletonMap(CompressionParams.SSTABLE_COMPRESSION, CompressionParams.DEFAULT.klass().getCanonicalName()));</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (!cf_def.isSetDefault_time_to_live())</span>
<span class="nc" id="L431">            cf_def.setDefault_time_to_live(TableParams.DEFAULT_DEFAULT_TIME_TO_LIVE);</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (!cf_def.isSetDclocal_read_repair_chance())</span>
<span class="nc" id="L433">            cf_def.setDclocal_read_repair_chance(TableParams.DEFAULT_DCLOCAL_READ_REPAIR_CHANCE);</span>

        // if index_interval was set, use that for the min_index_interval default
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (!cf_def.isSetMin_index_interval())</span>
        {
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (cf_def.isSetIndex_interval())</span>
<span class="nc" id="L439">                cf_def.setMin_index_interval(cf_def.getIndex_interval());</span>
            else
<span class="nc" id="L441">                cf_def.setMin_index_interval(TableParams.DEFAULT_MIN_INDEX_INTERVAL);</span>
        }

<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (!cf_def.isSetMax_index_interval())</span>
        {
            // ensure the max is at least as large as the min
<span class="nc" id="L447">            cf_def.setMax_index_interval(Math.max(cf_def.min_index_interval, TableParams.DEFAULT_MAX_INDEX_INTERVAL));</span>
        }
<span class="nc" id="L449">    }</span>

    public static CfDef toThrift(CFMetaData cfm)
    {
<span class="nc" id="L453">        CfDef def = new CfDef(cfm.ksName, cfm.cfName);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">        def.setColumn_type(cfm.isSuper() ? &quot;Super&quot; : &quot;Standard&quot;);</span>

<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (cfm.isSuper())</span>
        {
<span class="nc" id="L458">            def.setComparator_type(cfm.comparator.subtype(0).toString());</span>
<span class="nc" id="L459">            def.setSubcomparator_type(cfm.thriftColumnNameType().toString());</span>
        }
        else
        {
<span class="nc" id="L463">            def.setComparator_type(LegacyLayout.makeLegacyComparator(cfm).toString());</span>
        }

<span class="nc" id="L466">        def.setComment(cfm.params.comment);</span>
<span class="nc" id="L467">        def.setRead_repair_chance(cfm.params.readRepairChance);</span>
<span class="nc" id="L468">        def.setDclocal_read_repair_chance(cfm.params.dcLocalReadRepairChance);</span>
<span class="nc" id="L469">        def.setGc_grace_seconds(cfm.params.gcGraceSeconds);</span>
<span class="nc" id="L470">        def.setDefault_validation_class(cfm.makeLegacyDefaultValidator().toString());</span>
<span class="nc" id="L471">        def.setKey_validation_class(cfm.getKeyValidator().toString());</span>
<span class="nc" id="L472">        def.setMin_compaction_threshold(cfm.params.compaction.minCompactionThreshold());</span>
<span class="nc" id="L473">        def.setMax_compaction_threshold(cfm.params.compaction.maxCompactionThreshold());</span>
        // We only return the alias if only one is set since thrift don't know about multiple key aliases
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (cfm.partitionKeyColumns().size() == 1)</span>
<span class="nc" id="L476">            def.setKey_alias(cfm.partitionKeyColumns().get(0).name.bytes);</span>
<span class="nc" id="L477">        def.setColumn_metadata(columnDefinitionsToThrift(cfm, cfm.allColumns()));</span>
<span class="nc" id="L478">        def.setCompaction_strategy(cfm.params.compaction.klass().getName());</span>
<span class="nc" id="L479">        def.setCompaction_strategy_options(cfm.params.compaction.options());</span>
<span class="nc" id="L480">        def.setCompression_options(compressionParametersToThrift(cfm.params.compression));</span>
<span class="nc" id="L481">        def.setBloom_filter_fp_chance(cfm.params.bloomFilterFpChance);</span>
<span class="nc" id="L482">        def.setMin_index_interval(cfm.params.minIndexInterval);</span>
<span class="nc" id="L483">        def.setMax_index_interval(cfm.params.maxIndexInterval);</span>
<span class="nc" id="L484">        def.setMemtable_flush_period_in_ms(cfm.params.memtableFlushPeriodInMs);</span>
<span class="nc" id="L485">        def.setCaching(toThrift(cfm.params.caching));</span>
<span class="nc" id="L486">        def.setCells_per_row_to_cache(toThriftCellsPerRow(cfm.params.caching));</span>
<span class="nc" id="L487">        def.setDefault_time_to_live(cfm.params.defaultTimeToLive);</span>
<span class="nc" id="L488">        def.setSpeculative_retry(cfm.params.speculativeRetry.toString());</span>
<span class="nc" id="L489">        def.setTriggers(triggerDefinitionsToThrift(cfm.getTriggers()));</span>

<span class="nc" id="L491">        return def;</span>
    }

    public static ColumnDefinition fromThrift(String ksName,
                                              String cfName,
                                              AbstractType&lt;?&gt; thriftComparator,
                                              AbstractType&lt;?&gt; thriftSubcomparator,
                                              ColumnDef thriftColumnDef)
    throws SyntaxException, ConfigurationException
    {
<span class="nc bnc" id="L501" title="All 2 branches missed.">        boolean isSuper = thriftSubcomparator != null;</span>
        // For super columns, the componentIndex is 1 because the ColumnDefinition applies to the column component.
<span class="nc bnc" id="L503" title="All 2 branches missed.">        AbstractType&lt;?&gt; comparator = thriftSubcomparator == null ? thriftComparator : thriftSubcomparator;</span>
        try
        {
<span class="nc" id="L506">            comparator.validate(thriftColumnDef.name);</span>
        }
<span class="nc" id="L508">        catch (MarshalException e)</span>
        {
<span class="nc" id="L510">            throw new ConfigurationException(String.format(&quot;Column name %s is not valid for comparator %s&quot;, ByteBufferUtil.bytesToHex(thriftColumnDef.name), comparator));</span>
<span class="nc" id="L511">        }</span>

        // In our generic layout, we store thrift defined columns as static, but this doesn't work for super columns so we
        // use a regular definition (and &quot;dynamic&quot; columns are handled in a map).
<span class="nc bnc" id="L515" title="All 2 branches missed.">        ColumnDefinition.Kind kind = isSuper ? ColumnDefinition.Kind.REGULAR : ColumnDefinition.Kind.STATIC;</span>
<span class="nc" id="L516">        return new ColumnDefinition(ksName,</span>
                                    cfName,
<span class="nc" id="L518">                                    ColumnIdentifier.getInterned(ByteBufferUtil.clone(thriftColumnDef.name), comparator),</span>
<span class="nc" id="L519">                                    TypeParser.parse(thriftColumnDef.validation_class),</span>
                                    ColumnDefinition.NO_POSITION,
                                    kind);
    }

    private static List&lt;ColumnDefinition&gt; fromThrift(String ksName,
                                                     String cfName,
                                                     AbstractType&lt;?&gt; thriftComparator,
                                                     AbstractType&lt;?&gt; thriftSubcomparator,
                                                     List&lt;ColumnDef&gt; thriftDefs)
    throws SyntaxException, ConfigurationException
    {
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (thriftDefs == null)</span>
<span class="nc" id="L532">            return new ArrayList&lt;&gt;();</span>

<span class="nc" id="L534">        List&lt;ColumnDefinition&gt; defs = new ArrayList&lt;&gt;(thriftDefs.size());</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">        for (ColumnDef thriftColumnDef : thriftDefs)</span>
<span class="nc" id="L536">            defs.add(fromThrift(ksName, cfName, thriftComparator, thriftSubcomparator, thriftColumnDef));</span>

<span class="nc" id="L538">        return defs;</span>
    }

    private static Indexes indexDefsFromThrift(CFMetaData cfm,
                                               String ksName,
                                               String cfName,
                                               AbstractType&lt;?&gt; thriftComparator,
                                               AbstractType&lt;?&gt; thriftSubComparator,
                                               List&lt;ColumnDef&gt; thriftDefs)
    {
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (thriftDefs == null)</span>
<span class="nc" id="L549">            return Indexes.none();</span>

<span class="nc" id="L551">        Set&lt;String&gt; indexNames = new HashSet&lt;&gt;();</span>
<span class="nc" id="L552">        Indexes.Builder indexes = Indexes.builder();</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        for (ColumnDef def : thriftDefs)</span>
        {
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (def.isSetIndex_type())</span>
            {
<span class="nc" id="L557">                ColumnDefinition column = fromThrift(ksName, cfName, thriftComparator, thriftSubComparator, def);</span>

<span class="nc" id="L559">                String indexName = def.getIndex_name();</span>
                // add a generated index name if none was supplied
<span class="nc bnc" id="L561" title="All 2 branches missed.">                if (Strings.isNullOrEmpty(indexName))</span>
<span class="nc" id="L562">                    indexName = Indexes.getAvailableIndexName(ksName, cfName, column.name.toString());</span>

<span class="nc bnc" id="L564" title="All 2 branches missed.">                if (indexNames.contains(indexName))</span>
<span class="nc" id="L565">                    throw new ConfigurationException(&quot;Duplicate index name &quot; + indexName);</span>

<span class="nc" id="L567">                indexNames.add(indexName);</span>

<span class="nc" id="L569">                Map&lt;String, String&gt; indexOptions = def.getIndex_options();</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">                if (indexOptions != null &amp;&amp; indexOptions.containsKey(IndexTarget.TARGET_OPTION_NAME))</span>
<span class="nc" id="L571">                        throw new ConfigurationException(&quot;Reserved index option 'target' cannot be used&quot;);</span>

<span class="nc" id="L573">                IndexMetadata.Kind kind = IndexMetadata.Kind.valueOf(def.index_type.name());</span>

<span class="nc" id="L575">                indexes.add(IndexMetadata.fromLegacyMetadata(cfm, column, indexName, kind, indexOptions));</span>
            }
<span class="nc" id="L577">        }</span>
<span class="nc" id="L578">        return indexes.build();</span>
    }

    @VisibleForTesting
    public static ColumnDef toThrift(CFMetaData cfMetaData, ColumnDefinition column)
    {
<span class="nc" id="L584">        ColumnDef cd = new ColumnDef();</span>

<span class="nc" id="L586">        cd.setName(ByteBufferUtil.clone(column.name.bytes));</span>
<span class="nc" id="L587">        cd.setValidation_class(column.type.toString());</span>

        // we include the index in the ColumnDef iff its targets are compatible with
        // pre-3.0 indexes AND it is the only index defined on the given column, that is:
        //   * it is the only index on the column (i.e. with this column as its target)
        //   * it has only a single target, which matches the pattern for pre-3.0 indexes
        //     i.e. keys/values/entries/full, with exactly 1 argument that matches the
        //     column name OR a simple column name (for indexes on non-collection columns)
        // n.b. it's a guess that using a pre-compiled regex and checking the group is
        // cheaper than compiling a new regex for each column, but as this isn't on
        // any hot path this hasn't been verified yet.
<span class="nc" id="L598">        IndexMetadata matchedIndex = null;</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        for (IndexMetadata index : cfMetaData.getIndexes())</span>
        {
<span class="nc" id="L601">            Pair&lt;ColumnDefinition, IndexTarget.Type&gt; target  = TargetParser.parse(cfMetaData, index);</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            if (target.left.equals(column))</span>
            {
                // we already found an index for this column, we've no option but to
                // ignore both of them (and any others we've yet to find)
<span class="nc bnc" id="L606" title="All 2 branches missed.">                if (matchedIndex != null)</span>
<span class="nc" id="L607">                    return cd;</span>

<span class="nc" id="L609">                matchedIndex = index;</span>
            }
<span class="nc" id="L611">        }</span>

<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (matchedIndex != null)</span>
        {
<span class="nc" id="L615">            cd.setIndex_type(org.apache.cassandra.thrift.IndexType.valueOf(matchedIndex.kind.name()));</span>
<span class="nc" id="L616">            cd.setIndex_name(matchedIndex.name);</span>
<span class="nc" id="L617">            Map&lt;String, String&gt; filteredOptions = Maps.filterKeys(matchedIndex.options,</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                                                                  s -&gt; !IndexTarget.TARGET_OPTION_NAME.equals(s));</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            cd.setIndex_options(filteredOptions.isEmpty()</span>
                                ? null
<span class="nc" id="L621">                                : Maps.newHashMap(filteredOptions));</span>
        }

<span class="nc" id="L624">        return cd;</span>
    }

    private static List&lt;ColumnDef&gt; columnDefinitionsToThrift(CFMetaData metadata, Collection&lt;ColumnDefinition&gt; columns)
    {
<span class="nc" id="L629">        List&lt;ColumnDef&gt; thriftDefs = new ArrayList&lt;&gt;(columns.size());</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">        for (ColumnDefinition def : columns)</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (def.isPartOfCellName(metadata.isCQLTable(), metadata.isSuper()))</span>
<span class="nc" id="L632">                thriftDefs.add(ThriftConversion.toThrift(metadata, def));</span>
<span class="nc" id="L633">        return thriftDefs;</span>
    }

    private static Triggers triggerDefinitionsFromThrift(List&lt;TriggerDef&gt; thriftDefs)
    {
<span class="nc" id="L638">        Triggers.Builder triggers = Triggers.builder();</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">        for (TriggerDef thriftDef : thriftDefs)</span>
<span class="nc" id="L640">            triggers.add(new TriggerMetadata(thriftDef.getName(), thriftDef.getOptions().get(TriggerMetadata.CLASS)));</span>
<span class="nc" id="L641">        return triggers.build();</span>
    }

    private static List&lt;TriggerDef&gt; triggerDefinitionsToThrift(Triggers triggers)
    {
<span class="nc" id="L646">        List&lt;TriggerDef&gt; thriftDefs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">        for (TriggerMetadata def : triggers)</span>
        {
<span class="nc" id="L649">            TriggerDef td = new TriggerDef();</span>
<span class="nc" id="L650">            td.setName(def.name);</span>
<span class="nc" id="L651">            td.setOptions(Collections.singletonMap(TriggerMetadata.CLASS, def.classOption));</span>
<span class="nc" id="L652">            thriftDefs.add(td);</span>
<span class="nc" id="L653">        }</span>
<span class="nc" id="L654">        return thriftDefs;</span>
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    public static Map&lt;String, String&gt; compressionParametersToThrift(CompressionParams parameters)
    {
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (!parameters.isEnabled())</span>
<span class="nc" id="L661">            return Collections.emptyMap();</span>

<span class="nc" id="L663">        Map&lt;String, String&gt; options = new HashMap&lt;&gt;(parameters.getOtherOptions());</span>
<span class="nc" id="L664">        Class&lt;? extends ICompressor&gt; klass = parameters.getSstableCompressor().getClass();</span>
<span class="nc" id="L665">        options.put(CompressionParams.SSTABLE_COMPRESSION, klass.getName());</span>
<span class="nc" id="L666">        options.put(CompressionParams.CHUNK_LENGTH_KB, parameters.chunkLengthInKB());</span>
<span class="nc" id="L667">        return options;</span>
    }

    private static String toThrift(CachingParams caching)
    {
<span class="nc bnc" id="L672" title="All 4 branches missed.">        if (caching.cacheRows() &amp;&amp; caching.cacheKeys())</span>
<span class="nc" id="L673">            return &quot;ALL&quot;;</span>

<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (caching.cacheRows())</span>
<span class="nc" id="L676">            return &quot;ROWS_ONLY&quot;;</span>

<span class="nc bnc" id="L678" title="All 2 branches missed.">        if (caching.cacheKeys())</span>
<span class="nc" id="L679">            return &quot;KEYS_ONLY&quot;;</span>

<span class="nc" id="L681">        return &quot;NONE&quot;;</span>
    }

    private static CachingParams cachingFromTrhfit(String caching)
    {
<span class="nc bnc" id="L686" title="All 5 branches missed.">        switch (caching.toUpperCase(Locale.ENGLISH))</span>
        {
            case &quot;ALL&quot;:
<span class="nc" id="L689">                return CachingParams.CACHE_EVERYTHING;</span>
            case &quot;ROWS_ONLY&quot;:
<span class="nc" id="L691">                return new CachingParams(false, Integer.MAX_VALUE);</span>
            case &quot;KEYS_ONLY&quot;:
<span class="nc" id="L693">                return CachingParams.CACHE_KEYS;</span>
            case &quot;NONE&quot;:
<span class="nc" id="L695">                return CachingParams.CACHE_NOTHING;</span>
            default:
<span class="nc" id="L697">                throw new ConfigurationException(String.format(&quot;Invalid value %s for caching parameter&quot;, caching));</span>
        }
    }

    private static String toThriftCellsPerRow(CachingParams caching)
    {
<span class="nc bnc" id="L703" title="All 2 branches missed.">        return caching.cacheAllRows()</span>
             ? &quot;ALL&quot;
<span class="nc" id="L705">             : String.valueOf(caching.rowsPerPartitionToCache());</span>
    }

    private static int fromThriftCellsPerRow(String value)
    {
<span class="nc bnc" id="L710" title="All 2 branches missed.">        return &quot;ALL&quot;.equals(value)</span>
             ? Integer.MAX_VALUE
<span class="nc" id="L712">             : Integer.parseInt(value);</span>
    }

    public static CachingParams cachingFromThrift(String caching, String cellsPerRow)
    {
<span class="nc" id="L717">        boolean cacheKeys = true;</span>
<span class="nc" id="L718">        int rowsPerPartitionToCache = 0;</span>

        // if we get a caching string from thrift it is legacy, &quot;ALL&quot;, &quot;KEYS_ONLY&quot; etc
<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (caching != null)</span>
        {
<span class="nc" id="L723">            CachingParams parsed = cachingFromTrhfit(caching);</span>
<span class="nc" id="L724">            cacheKeys = parsed.cacheKeys();</span>
<span class="nc" id="L725">            rowsPerPartitionToCache = parsed.rowsPerPartitionToCache();</span>
        }

        // if we get cells_per_row from thrift, it is either &quot;ALL&quot; or &quot;&lt;number of cells to cache&gt;&quot;.
<span class="nc bnc" id="L729" title="All 4 branches missed.">        if (cellsPerRow != null &amp;&amp; rowsPerPartitionToCache &gt; 0)</span>
<span class="nc" id="L730">            rowsPerPartitionToCache = fromThriftCellsPerRow(cellsPerRow);</span>

<span class="nc" id="L732">        return new CachingParams(cacheKeys, rowsPerPartitionToCache);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>