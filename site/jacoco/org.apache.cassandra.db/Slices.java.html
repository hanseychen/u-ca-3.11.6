<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Slices.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">Slices.java</span></div><h1>Slices.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.*;

import com.google.common.collect.Iterators;

import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.ColumnDefinition;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;

/**
 * Represents the selection of multiple range of rows within a partition.
 * &lt;p&gt;
 * A {@code Slices} is basically a list of {@code Slice}, though those are guaranteed to be non-overlapping
 * and always in clustering order.
 */
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">public abstract class Slices implements Iterable&lt;Slice&gt;</span>
{
<span class="fc" id="L40">    public static final Serializer serializer = new Serializer();</span>

    /** Slices selecting all the rows of a partition. */
<span class="fc" id="L43">    public static final Slices ALL = new SelectAllSlices();</span>
    /** Slices selecting no rows in a partition. */
<span class="fc" id="L45">    public static final Slices NONE = new SelectNoSlices();</span>

    protected Slices()
<span class="fc" id="L48">    {</span>
<span class="fc" id="L49">    }</span>

    /**
     * Creates a {@code Slices} object that contains a single slice.
     *
     * @param comparator the comparator for the table {@code slice} is a slice of.
     * @param slice the single slice that the return object should contains.
     *
     * @return the newly created {@code Slices} object.
     */
    public static Slices with(ClusteringComparator comparator, Slice slice)
    {
<span class="pc bpc" id="L61" title="1 of 4 branches missed.">        if (slice.start() == ClusteringBound.BOTTOM &amp;&amp; slice.end() == ClusteringBound.TOP)</span>
<span class="fc" id="L62">            return Slices.ALL;</span>

<span class="pc bpc" id="L64" title="2 of 4 branches missed.">        assert comparator.compare(slice.start(), slice.end()) &lt;= 0;</span>
<span class="fc" id="L65">        return new ArrayBackedSlices(comparator, new Slice[]{ slice });</span>
    }

    /**
     * Whether the slices has a lower bound, that is whether it's first slice start is {@code Slice.BOTTOM}.
     *
     * @return whether the slices has a lower bound.
     */
    public abstract boolean hasLowerBound();

    /**
     * Whether the slices has an upper bound, that is whether it's last slice end is {@code Slice.TOP}.
     *
     * @return whether the slices has an upper bound.
     */
    public abstract boolean hasUpperBound();

    /**
     * The number of slice this object contains.
     *
     * @return the number of slice this object contains.
     */
    public abstract int size();

    /**
     * Returns the ith slice of this {@code Slices} object.
     *
     * @return the ith slice of this object.
     */
    public abstract Slice get(int i);

    /**
     * Returns slices for continuing the paging of those slices given the last returned clustering prefix.
     *
     * @param comparator the comparator for the table this is a filter for.
     * @param lastReturned the last clustering that was returned for the query we are paging for. The
     * resulting slices will be such that only results coming stricly after {@code lastReturned} are returned
     * (where coming after means &quot;greater than&quot; if {@code !reversed} and &quot;lesser than&quot; otherwise).
     * @param inclusive whether or not we want to include the {@code lastReturned} in the newly returned page of results.
     * @param reversed whether the query we're paging for is reversed or not.
     *
     * @return new slices that select results coming after {@code lastReturned}.
     */
    public abstract Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed);

    /**
     * An object that allows to test whether rows are selected by this {@code Slices} objects assuming those rows
     * are tested in clustering order.
     *
     * @param reversed if true, the rows passed to the returned object will be assumed to be in reversed clustering
     * order, otherwise they should be in clustering order.
     *
     * @return an object that tests for selection of rows by this {@code Slices} object.
     */
    public abstract InOrderTester inOrderTester(boolean reversed);

    /**
     * Whether a given clustering (row) is selected by this {@code Slices} object.
     *
     * @param clustering the clustering to test for selection.
     *
     * @return whether a given clustering (row) is selected by this {@code Slices} object.
     */
    public abstract boolean selects(Clustering clustering);


    /**
     * Given the per-clustering column minimum and maximum value a sstable contains, whether or not this slices potentially
     * intersects that sstable or not.
     *
     * @param minClusteringValues the smallest values for each clustering column that a sstable contains.
     * @param maxClusteringValues the biggest values for each clustering column that a sstable contains.
     *
     * @return whether the slices might intersects with the sstable having {@code minClusteringValues} and
     * {@code maxClusteringValues}.
     */
    public abstract boolean intersects(List&lt;ByteBuffer&gt; minClusteringValues, List&lt;ByteBuffer&gt; maxClusteringValues);

    public abstract String toCQLString(CFMetaData metadata);

    /**
     * Checks if this &lt;code&gt;Slices&lt;/code&gt; is empty.
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Slices&lt;/code&gt; is empty, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public final boolean isEmpty()
    {
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        return size() == 0;</span>
    }

    /**
     * In simple object that allows to test the inclusion of rows in those slices assuming those rows
     * are passed (to {@link #includes}) in clustering order (or reverse clustering ordered, depending
     * of the argument passed to {@link #inOrderTester}).
     */
    public interface InOrderTester
    {
        public boolean includes(Clustering value);
        public boolean isDone();
    }

    /**
     * Builder to create {@code Slices} objects.
     */
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">    public static class Builder</span>
    {
        private final ClusteringComparator comparator;

        private final List&lt;Slice&gt; slices;

        private boolean needsNormalizing;

        public Builder(ClusteringComparator comparator)
<span class="nc" id="L177">        {</span>
<span class="nc" id="L178">            this.comparator = comparator;</span>
<span class="nc" id="L179">            this.slices = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L180">        }</span>

        public Builder(ClusteringComparator comparator, int initialSize)
<span class="fc" id="L183">        {</span>
<span class="fc" id="L184">            this.comparator = comparator;</span>
<span class="fc" id="L185">            this.slices = new ArrayList&lt;&gt;(initialSize);</span>
<span class="fc" id="L186">        }</span>

        public Builder add(ClusteringBound start, ClusteringBound end)
        {
<span class="nc" id="L190">            return add(Slice.make(start, end));</span>
        }

        public Builder add(Slice slice)
        {
<span class="pc bpc" id="L195" title="2 of 4 branches missed.">            assert comparator.compare(slice.start(), slice.end()) &lt;= 0;</span>
<span class="pc bpc" id="L196" title="3 of 4 branches missed.">            if (slices.size() &gt; 0 &amp;&amp; comparator.compare(slices.get(slices.size()-1).end(), slice.start()) &gt; 0)</span>
<span class="nc" id="L197">                needsNormalizing = true;</span>
<span class="fc" id="L198">            slices.add(slice);</span>
<span class="fc" id="L199">            return this;</span>
        }

        public Builder addAll(Slices slices)
        {
<span class="nc bnc" id="L204" title="All 2 branches missed.">            for (Slice slice : slices)</span>
<span class="nc" id="L205">                add(slice);</span>
<span class="nc" id="L206">            return this;</span>
        }

        public int size()
        {
<span class="nc" id="L211">            return slices.size();</span>
        }

        public Slices build()
        {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (slices.isEmpty())</span>
<span class="nc" id="L217">                return NONE;</span>

<span class="pc bpc" id="L219" title="2 of 4 branches missed.">            if (slices.size() == 1 &amp;&amp; slices.get(0) == Slice.ALL)</span>
<span class="nc" id="L220">                return ALL;</span>

<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            List&lt;Slice&gt; normalized = needsNormalizing</span>
<span class="pc" id="L223">                                   ? normalize(slices)</span>
                                   : slices;

<span class="fc" id="L226">            return new ArrayBackedSlices(comparator, normalized.toArray(new Slice[normalized.size()]));</span>
        }

        /**
         * Given an array of slices (potentially overlapping and in any order) and return an equivalent array
         * of non-overlapping slices in clustering order.
         *
         * @param slices an array of slices. This may be modified by this method.
         * @return the smallest possible array of non-overlapping slices in clustering order. If the original
         * slices are already non-overlapping and in comparator order, this may or may not return the provided slices
         * directly.
         */
        private List&lt;Slice&gt; normalize(List&lt;Slice&gt; slices)
        {
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (slices.size() &lt;= 1)</span>
<span class="nc" id="L241">                return slices;</span>

<span class="nc" id="L243">            Collections.sort(slices, new Comparator&lt;Slice&gt;()</span>
<span class="nc" id="L244">            {</span>
                @Override
                public int compare(Slice s1, Slice s2)
                {
<span class="nc" id="L248">                    int c = comparator.compare(s1.start(), s2.start());</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">                    if (c != 0)</span>
<span class="nc" id="L250">                        return c;</span>

<span class="nc" id="L252">                    return comparator.compare(s1.end(), s2.end());</span>
                }
            });

<span class="nc" id="L256">            List&lt;Slice&gt; slicesCopy = new ArrayList&lt;&gt;(slices.size());</span>

<span class="nc" id="L258">            Slice last = slices.get(0);</span>

<span class="nc bnc" id="L260" title="All 2 branches missed.">            for (int i = 1; i &lt; slices.size(); i++)</span>
            {
<span class="nc" id="L262">                Slice s2 = slices.get(i);</span>

<span class="nc" id="L264">                boolean includesStart = last.includes(comparator, s2.start());</span>
<span class="nc" id="L265">                boolean includesFinish = last.includes(comparator, s2.end());</span>

<span class="nc bnc" id="L267" title="All 4 branches missed.">                if (includesStart &amp;&amp; includesFinish)</span>
<span class="nc" id="L268">                    continue;</span>

<span class="nc bnc" id="L270" title="All 4 branches missed.">                if (!includesStart &amp;&amp; !includesFinish)</span>
                {
<span class="nc" id="L272">                    slicesCopy.add(last);</span>
<span class="nc" id="L273">                    last = s2;</span>
<span class="nc" id="L274">                    continue;</span>
                }

<span class="nc bnc" id="L277" title="All 2 branches missed.">                if (includesStart)</span>
                {
<span class="nc" id="L279">                    last = Slice.make(last.start(), s2.end());</span>
<span class="nc" id="L280">                    continue;</span>
                }

<span class="nc bnc" id="L283" title="All 4 branches missed.">                assert !includesFinish;</span>
            }

<span class="nc" id="L286">            slicesCopy.add(last);</span>
<span class="nc" id="L287">            return slicesCopy;</span>
        }
    }

<span class="fc" id="L291">    public static class Serializer</span>
    {
        public void serialize(Slices slices, DataOutputPlus out, int version) throws IOException
        {
<span class="nc" id="L295">            int size = slices.size();</span>
<span class="nc" id="L296">            out.writeUnsignedVInt(size);</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (size == 0)</span>
<span class="nc" id="L299">                return;</span>

<span class="nc bnc" id="L301" title="All 2 branches missed.">            List&lt;AbstractType&lt;?&gt;&gt; types = slices == ALL</span>
<span class="nc" id="L302">                                        ? Collections.&lt;AbstractType&lt;?&gt;&gt;emptyList()</span>
<span class="nc" id="L303">                                        : ((ArrayBackedSlices)slices).comparator.subtypes();</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">            for (Slice slice : slices)</span>
<span class="nc" id="L306">                Slice.serializer.serialize(slice, out, version, types);</span>
<span class="nc" id="L307">        }</span>

        public long serializedSize(Slices slices, int version)
        {
<span class="nc" id="L311">            long size = TypeSizes.sizeofUnsignedVInt(slices.size());</span>

<span class="nc bnc" id="L313" title="All 2 branches missed.">            if (slices.size() == 0)</span>
<span class="nc" id="L314">                return size;</span>

<span class="nc bnc" id="L316" title="All 2 branches missed.">            List&lt;AbstractType&lt;?&gt;&gt; types = slices instanceof SelectAllSlices</span>
<span class="nc" id="L317">                                        ? Collections.&lt;AbstractType&lt;?&gt;&gt;emptyList()</span>
<span class="nc" id="L318">                                        : ((ArrayBackedSlices)slices).comparator.subtypes();</span>

<span class="nc bnc" id="L320" title="All 2 branches missed.">            for (Slice slice : slices)</span>
<span class="nc" id="L321">                size += Slice.serializer.serializedSize(slice, version, types);</span>

<span class="nc" id="L323">            return size;</span>
        }

        public Slices deserialize(DataInputPlus in, int version, CFMetaData metadata) throws IOException
        {
<span class="nc" id="L328">            int size = (int)in.readUnsignedVInt();</span>

<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (size == 0)</span>
<span class="nc" id="L331">                return NONE;</span>

<span class="nc" id="L333">            Slice[] slices = new Slice[size];</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++)</span>
<span class="nc" id="L335">                slices[i] = Slice.serializer.deserialize(in, version, metadata.comparator.subtypes());</span>

<span class="nc bnc" id="L337" title="All 6 branches missed.">            if (size == 1 &amp;&amp; slices[0].start() == ClusteringBound.BOTTOM &amp;&amp; slices[0].end() == ClusteringBound.TOP)</span>
<span class="nc" id="L338">                return ALL;</span>

<span class="nc" id="L340">            return new ArrayBackedSlices(metadata.comparator, slices);</span>
        }
    }

    /**
     * Simple {@code Slices} implementation that stores its slices in an array.
     */
    private static class ArrayBackedSlices extends Slices
    {
        private final ClusteringComparator comparator;

        private final Slice[] slices;

        private ArrayBackedSlices(ClusteringComparator comparator, Slice[] slices)
<span class="fc" id="L354">        {</span>
<span class="fc" id="L355">            this.comparator = comparator;</span>
<span class="fc" id="L356">            this.slices = slices;</span>
<span class="fc" id="L357">        }</span>

        public int size()
        {
<span class="fc" id="L361">            return slices.length;</span>
        }

        public boolean hasLowerBound()
        {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">            return slices[0].start().size() != 0;</span>
        }

        public boolean hasUpperBound()
        {
<span class="nc bnc" id="L371" title="All 2 branches missed.">            return slices[slices.length - 1].end().size() != 0;</span>
        }

        public Slice get(int i)
        {
<span class="fc" id="L376">            return slices[i];</span>
        }

        public boolean selects(Clustering clustering)
        {
<span class="nc bnc" id="L381" title="All 2 branches missed.">            for (int i = 0; i &lt; slices.length; i++)</span>
            {
<span class="nc" id="L383">                Slice slice = slices[i];</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">                if (comparator.compare(clustering, slice.start()) &lt; 0)</span>
<span class="nc" id="L385">                    return false;</span>

<span class="nc bnc" id="L387" title="All 2 branches missed.">                if (comparator.compare(clustering, slice.end()) &lt;= 0)</span>
<span class="nc" id="L388">                    return true;</span>
            }
<span class="nc" id="L390">            return false;</span>
        }

        public InOrderTester inOrderTester(boolean reversed)
        {
<span class="nc bnc" id="L395" title="All 2 branches missed.">            return reversed ? new InReverseOrderTester() : new InForwardOrderTester();</span>
        }

        public Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
        {
<span class="nc bnc" id="L400" title="All 2 branches missed.">            return reversed ? forReversePaging(comparator, lastReturned, inclusive) : forForwardPaging(comparator, lastReturned, inclusive);</span>
        }

        private Slices forForwardPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive)
        {
<span class="nc bnc" id="L405" title="All 2 branches missed.">            for (int i = 0; i &lt; slices.length; i++)</span>
            {
<span class="nc" id="L407">                Slice slice = slices[i];</span>
<span class="nc" id="L408">                Slice newSlice = slice.forPaging(comparator, lastReturned, inclusive, false);</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">                if (newSlice == null)</span>
<span class="nc" id="L410">                    continue;</span>

<span class="nc bnc" id="L412" title="All 4 branches missed.">                if (slice == newSlice &amp;&amp; i == 0)</span>
<span class="nc" id="L413">                    return this;</span>

<span class="nc" id="L415">                ArrayBackedSlices newSlices = new ArrayBackedSlices(comparator, Arrays.copyOfRange(slices, i, slices.length));</span>
<span class="nc" id="L416">                newSlices.slices[0] = newSlice;</span>
<span class="nc" id="L417">                return newSlices;</span>
            }
<span class="nc" id="L419">            return Slices.NONE;</span>
        }

        private Slices forReversePaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive)
        {
<span class="nc bnc" id="L424" title="All 2 branches missed.">            for (int i = slices.length - 1; i &gt;= 0; i--)</span>
            {
<span class="nc" id="L426">                Slice slice = slices[i];</span>
<span class="nc" id="L427">                Slice newSlice = slice.forPaging(comparator, lastReturned, inclusive, true);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (newSlice == null)</span>
<span class="nc" id="L429">                    continue;</span>

<span class="nc bnc" id="L431" title="All 4 branches missed.">                if (slice == newSlice &amp;&amp; i == slices.length - 1)</span>
<span class="nc" id="L432">                    return this;</span>

<span class="nc" id="L434">                ArrayBackedSlices newSlices = new ArrayBackedSlices(comparator, Arrays.copyOfRange(slices, 0, i + 1));</span>
<span class="nc" id="L435">                newSlices.slices[i] = newSlice;</span>
<span class="nc" id="L436">                return newSlices;</span>
            }
<span class="nc" id="L438">            return Slices.NONE;</span>
        }

        public boolean intersects(List&lt;ByteBuffer&gt; minClusteringValues, List&lt;ByteBuffer&gt; maxClusteringValues)
        {
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">            for (Slice slice : this)</span>
            {
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">                if (slice.intersects(comparator, minClusteringValues, maxClusteringValues))</span>
<span class="fc" id="L446">                    return true;</span>
<span class="nc" id="L447">            }</span>
<span class="nc" id="L448">            return false;</span>
        }

        public Iterator&lt;Slice&gt; iterator()
        {
<span class="fc" id="L453">            return Iterators.forArray(slices);</span>
        }

<span class="nc" id="L456">        private class InForwardOrderTester implements InOrderTester</span>
        {
            private int idx;
            private boolean inSlice;

            public boolean includes(Clustering value)
            {
<span class="nc bnc" id="L463" title="All 2 branches missed.">                while (idx &lt; slices.length)</span>
                {
<span class="nc bnc" id="L465" title="All 2 branches missed.">                    if (!inSlice)</span>
                    {
<span class="nc" id="L467">                        int cmp = comparator.compare(value, slices[idx].start());</span>
                        // value &lt; start
<span class="nc bnc" id="L469" title="All 2 branches missed.">                        if (cmp &lt; 0)</span>
<span class="nc" id="L470">                            return false;</span>

<span class="nc" id="L472">                        inSlice = true;</span>

<span class="nc bnc" id="L474" title="All 2 branches missed.">                        if (cmp == 0)</span>
<span class="nc" id="L475">                            return true;</span>
                    }

                    // Here, start &lt; value and inSlice
<span class="nc bnc" id="L479" title="All 2 branches missed.">                    if (comparator.compare(value, slices[idx].end()) &lt;= 0)</span>
<span class="nc" id="L480">                        return true;</span>

<span class="nc" id="L482">                    ++idx;</span>
<span class="nc" id="L483">                    inSlice = false;</span>
                }
<span class="nc" id="L485">                return false;</span>
            }

            public boolean isDone()
            {
<span class="nc bnc" id="L490" title="All 2 branches missed.">                return idx &gt;= slices.length;</span>
            }
        }

        private class InReverseOrderTester implements InOrderTester
        {
            private int idx;
            private boolean inSlice;

            public InReverseOrderTester()
<span class="nc" id="L500">            {</span>
<span class="nc" id="L501">                this.idx = slices.length - 1;</span>
<span class="nc" id="L502">            }</span>

            public boolean includes(Clustering value)
            {
<span class="nc bnc" id="L506" title="All 2 branches missed.">                while (idx &gt;= 0)</span>
                {
<span class="nc bnc" id="L508" title="All 2 branches missed.">                    if (!inSlice)</span>
                    {
<span class="nc" id="L510">                        int cmp = comparator.compare(slices[idx].end(), value);</span>
                        // value &gt; end
<span class="nc bnc" id="L512" title="All 2 branches missed.">                        if (cmp &gt; 0)</span>
<span class="nc" id="L513">                            return false;</span>

<span class="nc" id="L515">                        inSlice = true;</span>

<span class="nc bnc" id="L517" title="All 2 branches missed.">                        if (cmp == 0)</span>
<span class="nc" id="L518">                            return true;</span>
                    }

                    // Here, value &lt;= end and inSlice
<span class="nc bnc" id="L522" title="All 2 branches missed.">                    if (comparator.compare(slices[idx].start(), value) &lt;= 0)</span>
<span class="nc" id="L523">                        return true;</span>

<span class="nc" id="L525">                    --idx;</span>
<span class="nc" id="L526">                    inSlice = false;</span>
                }
<span class="nc" id="L528">                return false;</span>
            }

            public boolean isDone()
            {
<span class="nc bnc" id="L533" title="All 2 branches missed.">                return idx &lt; 0;</span>
            }
        }

        @Override
        public String toString()
        {
<span class="nc" id="L540">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L541">            sb.append(&quot;{&quot;);</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            for (int i = 0; i &lt; slices.length; i++)</span>
            {
<span class="nc bnc" id="L544" title="All 2 branches missed.">                if (i &gt; 0)</span>
<span class="nc" id="L545">                    sb.append(&quot;, &quot;);</span>
<span class="nc" id="L546">                sb.append(slices[i].toString(comparator));</span>
            }
<span class="nc" id="L548">            return sb.append(&quot;}&quot;).toString();</span>
        }

        public String toCQLString(CFMetaData metadata)
        {
<span class="nc" id="L553">            StringBuilder sb = new StringBuilder();</span>

            // In CQL, condition are expressed by column, so first group things that way,
            // i.e. for each column, we create a list of what each slice contains on that column
<span class="nc" id="L557">            int clusteringSize = metadata.clusteringColumns().size();</span>
<span class="nc" id="L558">            List&lt;List&lt;ComponentOfSlice&gt;&gt; columnComponents = new ArrayList&lt;&gt;(clusteringSize);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">            for (int i = 0; i &lt; clusteringSize; i++)</span>
            {
<span class="nc" id="L561">                List&lt;ComponentOfSlice&gt; perSlice = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L562">                columnComponents.add(perSlice);</span>

<span class="nc bnc" id="L564" title="All 2 branches missed.">                for (int j = 0; j &lt; slices.length; j++)</span>
                {
<span class="nc" id="L566">                    ComponentOfSlice c = ComponentOfSlice.fromSlice(i, slices[j]);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                    if (c != null)</span>
<span class="nc" id="L568">                        perSlice.add(c);</span>
                }
            }

<span class="nc" id="L572">            boolean needAnd = false;</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">            for (int i = 0; i &lt; clusteringSize; i++)</span>
            {
<span class="nc" id="L575">                ColumnDefinition column = metadata.clusteringColumns().get(i);</span>
<span class="nc" id="L576">                List&lt;ComponentOfSlice&gt; componentInfo = columnComponents.get(i);</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                if (componentInfo.isEmpty())</span>
<span class="nc" id="L578">                    break;</span>

                // For a given column, there is only 3 cases that CQL currently generates:
                //   1) every slice are EQ with the same value, it's a simple '=' relation.
                //   2) every slice are EQ but with different values, it's a IN relation.
                //   3) every slice aren't EQ but have the same values, we have inequality relations.
                // Note that this doesn't cover everything that ReadCommand can express, but
                // as it's all that CQL support for now, we'll ignore other cases (which would then
                // display a bogus query but that's not the end of the world).
                // TODO: we should improve this at some point.
<span class="nc" id="L588">                ComponentOfSlice first = componentInfo.get(0);</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                if (first.isEQ())</span>
                {
<span class="nc bnc" id="L591" title="All 2 branches missed.">                    if (needAnd)</span>
<span class="nc" id="L592">                        sb.append(&quot; AND &quot;);</span>
<span class="nc" id="L593">                    needAnd = true;</span>

<span class="nc" id="L595">                    sb.append(column.name);</span>

<span class="nc" id="L597">                    Set&lt;ByteBuffer&gt; values = new LinkedHashSet&lt;&gt;();</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">                    for (int j = 0; j &lt; componentInfo.size(); j++)</span>
<span class="nc" id="L599">                        values.add(componentInfo.get(j).startValue);</span>

<span class="nc bnc" id="L601" title="All 2 branches missed.">                    if (values.size() == 1)</span>
                    {
<span class="nc" id="L603">                        sb.append(&quot; = &quot;).append(column.type.getString(first.startValue));</span>
                    }
                    else
                    {
<span class="nc" id="L607">                        sb.append(&quot; IN (&quot;);</span>
<span class="nc" id="L608">                        int j = 0;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                        for (ByteBuffer value : values)</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">                            sb.append(j++ == 0 ? &quot;&quot; : &quot;, &quot;).append(column.type.getString(value));</span>
<span class="nc" id="L611">                        sb.append(&quot;)&quot;);</span>
                    }
<span class="nc" id="L613">                }</span>
                else
                {
                    // As said above, we assume (without checking) that this means all ComponentOfSlice for this column
                    // are the same, so we only bother about the first.
<span class="nc bnc" id="L618" title="All 2 branches missed.">                    if (first.startValue != null)</span>
                    {
<span class="nc bnc" id="L620" title="All 2 branches missed.">                        if (needAnd)</span>
<span class="nc" id="L621">                            sb.append(&quot; AND &quot;);</span>
<span class="nc" id="L622">                        needAnd = true;</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">                        sb.append(column.name).append(first.startInclusive ? &quot; &gt;= &quot; : &quot; &gt; &quot;).append(column.type.getString(first.startValue));</span>
                    }
<span class="nc bnc" id="L625" title="All 2 branches missed.">                    if (first.endValue != null)</span>
                    {
<span class="nc bnc" id="L627" title="All 2 branches missed.">                        if (needAnd)</span>
<span class="nc" id="L628">                            sb.append(&quot; AND &quot;);</span>
<span class="nc" id="L629">                        needAnd = true;</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                        sb.append(column.name).append(first.endInclusive ? &quot; &lt;= &quot; : &quot; &lt; &quot;).append(column.type.getString(first.endValue));</span>
                    }
                }
            }
<span class="nc" id="L634">            return sb.toString();</span>
        }

        // An somewhat adhoc utility class only used by toCQLString
        private static class ComponentOfSlice
        {
            public final boolean startInclusive;
            public final ByteBuffer startValue;
            public final boolean endInclusive;
            public final ByteBuffer endValue;

            private ComponentOfSlice(boolean startInclusive, ByteBuffer startValue, boolean endInclusive, ByteBuffer endValue)
<span class="nc" id="L646">            {</span>
<span class="nc" id="L647">                this.startInclusive = startInclusive;</span>
<span class="nc" id="L648">                this.startValue = startValue;</span>
<span class="nc" id="L649">                this.endInclusive = endInclusive;</span>
<span class="nc" id="L650">                this.endValue = endValue;</span>
<span class="nc" id="L651">            }</span>

            public static ComponentOfSlice fromSlice(int component, Slice slice)
            {
<span class="nc" id="L655">                ClusteringBound start = slice.start();</span>
<span class="nc" id="L656">                ClusteringBound end = slice.end();</span>

<span class="nc bnc" id="L658" title="All 4 branches missed.">                if (component &gt;= start.size() &amp;&amp; component &gt;= end.size())</span>
<span class="nc" id="L659">                    return null;</span>

<span class="nc" id="L661">                boolean startInclusive = true, endInclusive = true;</span>
<span class="nc" id="L662">                ByteBuffer startValue = null, endValue = null;</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">                if (component &lt; start.size())</span>
                {
<span class="nc" id="L665">                    startInclusive = start.isInclusive();</span>
<span class="nc" id="L666">                    startValue = start.get(component);</span>
                }
<span class="nc bnc" id="L668" title="All 2 branches missed.">                if (component &lt; end.size())</span>
                {
<span class="nc" id="L670">                    endInclusive = end.isInclusive();</span>
<span class="nc" id="L671">                    endValue = end.get(component);</span>
                }
<span class="nc" id="L673">                return new ComponentOfSlice(startInclusive, startValue, endInclusive, endValue);</span>
            }

            public boolean isEQ()
            {
<span class="nc" id="L678">                return Objects.equals(startValue, endValue);</span>
            }
        }
    }

    /**
     * Specialized implementation of {@code Slices} that selects all rows.
     * &lt;p&gt;
     * This is equivalent to having the single {@code Slice.ALL} slice, but is somewhat more effecient.
     */
    private static class SelectAllSlices extends Slices
    {
<span class="fc" id="L690">        private static final InOrderTester trivialTester = new InOrderTester()</span>
<span class="fc" id="L691">        {</span>
            public boolean includes(Clustering value)
            {
<span class="nc" id="L694">                return true;</span>
            }

            public boolean isDone()
            {
<span class="nc" id="L699">                return false;</span>
            }
        };

        public int size()
        {
<span class="fc" id="L705">            return 1;</span>
        }

        public Slice get(int i)
        {
<span class="fc" id="L710">            return Slice.ALL;</span>
        }

        public boolean hasLowerBound()
        {
<span class="fc" id="L715">            return false;</span>
        }

        public boolean hasUpperBound()
        {
<span class="fc" id="L720">            return false;</span>
        }

        public boolean selects(Clustering clustering)
        {
<span class="nc" id="L725">            return true;</span>
        }

        public Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
        {
<span class="nc" id="L730">            return new ArrayBackedSlices(comparator, new Slice[]{ Slice.ALL.forPaging(comparator, lastReturned, inclusive, reversed) });</span>
        }

        public InOrderTester inOrderTester(boolean reversed)
        {
<span class="nc" id="L735">            return trivialTester;</span>
        }

        public boolean intersects(List&lt;ByteBuffer&gt; minClusteringValues, List&lt;ByteBuffer&gt; maxClusteringValues)
        {
<span class="fc" id="L740">            return true;</span>
        }

        public Iterator&lt;Slice&gt; iterator()
        {
<span class="nc" id="L745">            return Iterators.singletonIterator(Slice.ALL);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L751">            return &quot;ALL&quot;;</span>
        }

        public String toCQLString(CFMetaData metadata)
        {
<span class="nc" id="L756">            return &quot;&quot;;</span>
        }
    }

    /**
     * Specialized implementation of {@code Slices} that selects no rows.
     */
    private static class SelectNoSlices extends Slices
    {
<span class="fc" id="L765">        private static final InOrderTester trivialTester = new InOrderTester()</span>
<span class="fc" id="L766">        {</span>
            public boolean includes(Clustering value)
            {
<span class="nc" id="L769">                return false;</span>
            }

            public boolean isDone()
            {
<span class="nc" id="L774">                return true;</span>
            }
        };

        public int size()
        {
<span class="nc" id="L780">            return 0;</span>
        }

        public Slice get(int i)
        {
<span class="nc" id="L785">            throw new UnsupportedOperationException();</span>
        }

        public boolean hasLowerBound()
        {
<span class="nc" id="L790">            return false;</span>
        }

        public boolean hasUpperBound()
        {
<span class="nc" id="L795">            return false;</span>
        }

        public Slices forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive, boolean reversed)
        {
<span class="nc" id="L800">            return this;</span>
        }

        public boolean selects(Clustering clustering)
        {
<span class="nc" id="L805">            return false;</span>
        }

        public InOrderTester inOrderTester(boolean reversed)
        {
<span class="nc" id="L810">            return trivialTester;</span>
        }

        public boolean intersects(List&lt;ByteBuffer&gt; minClusteringValues, List&lt;ByteBuffer&gt; maxClusteringValues)
        {
<span class="nc" id="L815">            return false;</span>
        }

        public Iterator&lt;Slice&gt; iterator()
        {
<span class="nc" id="L820">            return Collections.emptyIterator();</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L826">            return &quot;NONE&quot;;</span>
        }

        public String toCQLString(CFMetaData metadata)
        {
<span class="nc" id="L831">            return &quot;&quot;;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>